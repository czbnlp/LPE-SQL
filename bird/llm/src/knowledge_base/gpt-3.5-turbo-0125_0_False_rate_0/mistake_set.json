[
    {
        "question": "In 2012, who had the least consumption in LAM?",
        "hint": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT CustomerID, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nWHERE Date BETWEEN '201201' AND '201212'\nGROUP BY CustomerID\nORDER BY TotalConsumption ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT SUBSTR(Date, 1, 4) AS Year, SUM(Consumption) AS TotalConsumption\nFROM yearmonth \nJOIN customers ON yearmonth.CustomerID = customers.CustomerID \nWHERE customers.Currency = 'CZK' \nGROUP BY Year \nORDER BY TotalConsumption DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "hint": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT Date, SUM(Consumption) AS TotalConsumption\nFROM yearmonth\nJOIN customers ON yearmonth.CustomerID = customers.CustomerID\nWHERE customers.Segment = 'SME' AND Date BETWEEN '201301' AND '201312'\nGROUP BY Date\nORDER BY TotalConsumption DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "hint": "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT \n    'SME' AS Segment,\n    AVG(Consumption) AS AnnualAverage \nFROM \n    yearmonth \nWHERE \n    CustomerID IN (SELECT CustomerID \n                   FROM customers \n                   WHERE Segment = 'SME') \n    AND Date BETWEEN '201301' AND '201312' \nGROUP BY \n    CustomerID \nORDER BY \n    AnnualAverage \nLIMIT 1\n\nUNION ALL \n\nSELECT \n    'LAM' AS Segment,\n    AVG(Consumption) AS AnnualAverage \nFROM \n    yearmonth \nWHERE \n    CustomerID IN (SELECT CustomerID \n                   FROM customers \n                   WHERE Segment = 'LAM') \n    AND Date BETWEEN '201301' AND '201312' \nGROUP BY \n    CustomerID \nORDER BY \n    AnnualAverage \nLIMIT 1\n\nUNION ALL \n\nSELECT \n    'KAM' AS Segment,\n    AVG(Consumption) AS AnnualAverage \nFROM \n    yearmonth \nWHERE \n    CustomerID IN (SELECT CustomerID \n                   FROM customers \n                   WHERE Segment = 'KAM') \n    AND Date BETWEEN '201301' AND '201312' \nGROUP BY \n    CustomerID \nORDER BY \n    AnnualAverage \nLIMIT 1;",
        "compiler_hint": "ORDER BY clause should come after UNION ALL not before",
        "reflective_cot": "### Reflection on the Error\n\nThe original SQL query faced an issue because it attempted to use the `ORDER BY` clause within each individual `SELECT` statement prior to the `UNION ALL`. In SQL, the `ORDER BY` clause should be applied to the final result set after all `UNION` operations, not within each segment.\n\n### Correction\n\nIn the corrected query, the `ORDER BY` statements are removed from within the individual segments. Instead, you should gather the lowest average consumption values first and then order or calculate differences on the aggregated results if needed.\n\n### Tip to Avoid Future Mistakes\n\nTo avoid similar errors, remember the following: **always place the `ORDER BY` after the entire `UNION` operation**, when you're aiming to sort the final combined result. Additionally, checking logical flow and structure of SQL queries before execution can help identify potential misplacements.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "difficulty": "challenging"
    },
    {
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "hint": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
        "error_sql": "SELECT Segment, \n       (SUM(CASE WHEN strftime('%Y', Date) = '2013' AND Currency = 'EUR' THEN Consumption ELSE 0 END) - \n        SUM(CASE WHEN strftime('%Y', Date) = '2012' AND Currency = 'EUR' THEN Consumption ELSE 0 END)) * 100.0 /\n       NULLIF(SUM(CASE WHEN strftime('%Y', Date) = '2013' AND Currency = 'EUR' THEN Consumption ELSE 0 END), 0) AS PercentageIncrease\nFROM yearmonth\nJOIN customers ON yearmonth.CustomerID = customers.CustomerID\nWHERE strftime('%Y', Date) IN ('2012', '2013')\nGROUP BY Segment\nORDER BY PercentageIncrease;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "difficulty": "challenging"
    },
    {
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "hint": "Czech Republic can be represented as the Country value in gasstations table is 'CZE'; Slovakia can be represented as the Country value in the gasstations table is 'SVK';  Computation of more \"discount\" gas stations= Total no. of discount gas stations in Czech Republic - Total no. of discount gas stations in Slovakia",
        "error_sql": "SELECT \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'discount') - \n    (SELECT COUNT(*) FROM gasstations WHERE Country = 'SVK' AND Segment = 'discount') AS Difference;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "difficulty": "simple"
    },
    {
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "hint": "Amount of more SMEs = Total of SMEs pay using Currency CZK - Total of SMEs pay using Currency EUR",
        "error_sql": "SELECT \n    (SELECT COUNT(DISTINCT c.CustomerID) \n     FROM transactions_1k t \n     JOIN customers c ON t.CustomerID = c.CustomerID \n     WHERE c.Segment = 'SME' AND c.Currency = 'CZK') -\n    (SELECT COUNT(DISTINCT c.CustomerID) \n     FROM transactions_1k t \n     JOIN customers c ON t.CustomerID = c.CustomerID \n     WHERE c.Segment = 'SME' AND c.Currency = 'EUR') AS More_SMEs;",
        "compiler_hint": "ambiguous column name: CustomerID",
        "reflective_cot": "### Reflection on Error and Correction\n\nThe error \"ambiguous column name: CustomerID\" occurred because the SQL engine could not determine which `CustomerID` column to reference when both the `transactions_1k` and `customers` tables were joined. This ambiguity arises when the same column name exists in multiple tables involved in a query.\n\nIn the corrected SQL, the alias `c` was explicitly used to specify the `CustomerID` column from the `customers` table in both subqueries. This provided clarity and resolved the ambiguity.\n\n### Tip to Avoid Future Errors\n\nAlways use table aliases to qualify column names in SQL queries, especially when joining multiple tables that may have overlapping column names. This practice reduces ambiguity and enhances readability.",
        "ground_truth_sql": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
        "difficulty": "simple"
    },
    {
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "hint": "Percentage of LAM customer consumed more than 46.73 = (Total no. of LAM customers who consumed more than 46.73 / Total no. of LAM customers) * 100.",
        "error_sql": "SELECT (COUNT(DISTINCT y.CustomerID) * 100.0 / (SELECT COUNT(*) FROM customers WHERE Segment = 'LAM')) AS Percentage\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'LAM' AND y.Consumption > 46.73;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the highest monthly consumption in the year 2012?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT MAX(Consumption)\nFROM yearmonth\nWHERE Date LIKE '2012%';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "hint": "Pays in euro = Currency = 'EUR'.",
        "error_sql": "SELECT COUNT(DISTINCT y.CustomerID)\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'EUR' AND y.Consumption > 1000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "hint": "'2012/8/25' can be represented by '2012-08-25'",
        "error_sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN Currency = 'EUR' THEN CustomerID END) * 100.0) / \n    COUNT(DISTINCT CustomerID) AS Percentage\nFROM \n    customers \nWHERE \n    CustomerID IN (\n        SELECT DISTINCT CustomerID \n        FROM transactions_1k \n        WHERE Date = '2012-08-25'\n    );",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "difficulty": "simple"
    },
    {
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
        "error_sql": "SELECT \n    (c2012.Consumption - c2013.Consumption) / c2012.Consumption AS ConsumptionDecreaseRate\nFROM \n    yearmonth c2012\nJOIN \n    transactions_1k t ON c2012.CustomerID = t.CustomerID\nJOIN \n    yearmonth c2013 ON c2012.CustomerID = c2013.CustomerID\nWHERE \n    t.Price = 634.8 \n    AND t.Date = '2012-08-25' \n    AND c2012.Date LIKE '2012-%' \n    AND c2013.Date LIKE '2013-%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price  = 1513.12 )",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "hint": "",
        "error_sql": "SELECT \n    (SUM(CASE WHEN g.Segment = 'premium' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS premium_percentage\nFROM gasstations g\nWHERE g.Country = 'SVK';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "difficulty": "simple"
    },
    {
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "hint": "January 2012 refers to the Date value = '201201'",
        "error_sql": "SELECT SUM(Price * Amount) AS TotalSpent, \n       (SELECT SUM(Price * Amount) FROM transactions_1k \n        WHERE CustomerID = 38508 AND strftime('%Y%m', Date) = '201201') AS JanuaryTotal \nFROM transactions_1k \nWHERE CustomerID = 38508;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(T1.Price ) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "difficulty": "moderate"
    },
    {
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "hint": "average price per single item = Total(price) / Total(amount)",
        "error_sql": "SELECT c.CustomerID, \n       SUM(t.Price) AS TotalSpent, \n       SUM(t.Price) / NULLIF(SUM(t.Amount), 0) AS AveragePricePerItem, \n       c.Currency\nFROM transactions_1k t\nJOIN customers c ON t.CustomerID = c.CustomerID\nGROUP BY c.CustomerID\nORDER BY TotalSpent DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "difficulty": "moderate"
    },
    {
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "hint": "August of 2012 refers to the Date value = '201208' ; Price per unit of product = Price / Amount;",
        "error_sql": "SELECT y.CustomerID, y.Consumption\nFROM transactions_1k t\nJOIN yearmonth y ON t.CustomerID = y.CustomerID\nWHERE t.ProductID = 5 \n  AND (t.Price / t.Amount) > 29.00\n  AND y.Date = '201208';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "hint": "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
        "error_sql": "SELECT COUNT(DISTINCT a.link_to_event) \nFROM attendance a \nJOIN event e ON a.link_to_event = e.event_id \nGROUP BY a.link_to_event \nHAVING COUNT(a.link_to_member) > 10 AND e.type = 'Meeting';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "hint": "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20.",
        "error_sql": "SELECT e.event_name\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'fundraiser'\nGROUP BY e.event_name\nHAVING COUNT(a.link_to_member) > 20;",
        "compiler_hint": "misuse of aggregate: COUNT()",
        "reflective_cot": "### Reflection:\nThe error in the original SQL query stemmed from attempting to use the `COUNT()` aggregate function in the `WHERE` clause. Aggregates must be used in the `HAVING` clause after the results are grouped. The corrected SQL moves the `COUNT()` condition to `HAVING`, which is correct because `HAVING` is designed to filter results based on aggregate functions after grouping.\n\n### Tip:\nTo avoid similar mistakes in the future, remember that any condition involving aggregate functions should always be placed in the `HAVING` clause, while non-aggregate conditions belong in the `WHERE` clause. It's crucial to understand the order of operations in SQL: filter first with `WHERE`, then group with `GROUP BY`, and finally filter the grouped results with `HAVING`.",
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "difficulty": "moderate"
    },
    {
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "hint": "full name of member refers to first_name, last_name",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nWHERE zip IN (SELECT zip_code FROM zip_code WHERE state = 'Illinois');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "difficulty": "simple"
    },
    {
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "hint": "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved",
        "error_sql": "SELECT e.event_name, ex.approved \nFROM event e \nJOIN budget b ON e.event_id = b.link_to_event \nJOIN expense ex ON b.budget_id = ex.link_to_budget \nWHERE e.event_name = 'October Meeting' AND e.event_date = '2019-10-08';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "hint": "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)",
        "error_sql": "SELECT \n    SUM(CASE WHEN SUBSTR(event_date, 1, 4) = '2019' THEN spent ELSE 0 END) - \n    SUM(CASE WHEN SUBSTR(event_date, 1, 4) = '2020' THEN spent ELSE 0 END) AS difference\nFROM \n    budget \nJOIN \n    event ON budget.link_to_event = event.event_id\nWHERE \n    event.event_name = 'Student_Club';",
        "compiler_hint": "no such column: event_date",
        "reflective_cot": "### Reflection on the Error\n\nThe error arose because the original query attempted to reference the `event_date` column directly from the `budget` table, which doesn't contain this column. Instead, the `event_date` is part of the `event` table. The corrected SQL query correctly joins the `budget` and `event` tables, allowing access to the `event_date` field.\n\n### Tip for Future Avoidance\n\nTo avoid similar mistakes, always verify the schema to ensure you're accessing the correct tables and columns. Using joins judiciously will allow you to reference fields from related tables seamlessly. A good practice is to double-check the chosen columns in the `SELECT` statement, especially when dealing with multiple tables.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "difficulty": "moderate"
    },
    {
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "hint": "'Post Cards, Posters' is an expense description; on 2019/8/20 refers to expense_date = '2019-8-20'; status of event refers to event_status",
        "error_sql": "SELECT e.status \nFROM event e \nJOIN budget b ON e.event_id = b.link_to_event \nJOIN expense ex ON b.budget_id = ex.link_to_budget \nWHERE ex.expense_description = 'Post Cards, Posters' \nAND ex.expense_date = '2019-8-20';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "difficulty": "moderate"
    },
    {
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "hint": "list all members means to list all the full name; full name refers to first_name, last_name;",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nJOIN major ON member.link_to_major = major.major_id \nWHERE major.department = 'School of Applied Sciences, Technology and Education';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "difficulty": "moderate"
    },
    {
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "hint": "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
        "error_sql": "SELECT e.event_name, MAX(spent / amount) AS spend_to_budget_ratio\nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.status = 'Closed'\nGROUP BY e.event_name\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List the name of students that have attended more than 7 events.",
        "hint": "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nGROUP BY m.member_id\nHAVING COUNT(a.link_to_event) > 7;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "difficulty": "moderate"
    },
    {
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "hint": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN budget b ON b.link_to_event = a.link_to_event\nJOIN event e ON e.event_id = a.link_to_event\nWHERE e.event_name = 'Yearly Kickoff';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "difficulty": "moderate"
    },
    {
        "question": "Which event has the lowest cost?",
        "hint": "event refers to event_name; lowest cost means MIN(cost)",
        "error_sql": "SELECT e.event_name, MIN(exp.cost) AS lowest_cost \nFROM event e\nJOIN budget b ON e.event_id = b.link_to_event\nJOIN expense exp ON b.budget_id = exp.link_to_budget\nGROUP BY e.event_name\nORDER BY lowest_cost ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "hint": "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100",
        "error_sql": "SELECT (SUM(CASE WHEN e.event_name = 'Yearly Kickoff' THEN ex.cost ELSE 0 END) / SUM(ex.cost)) * 100 AS percentage\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nJOIN expense ex ON a.link_to_event = ex.link_to_budget;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "difficulty": "moderate"
    },
    {
        "question": "Indicate the top source of funds received in September 2019 based on their amount.",
        "hint": "top source funds refers to MAX(source); September 2019 means date_received BETWEEN '2019-09-01' and '2019-09-30'",
        "error_sql": "SELECT source, MAX(amount) AS top_amount\nFROM income\nWHERE date_received BETWEEN '2019-09-01' AND '2019-09-30'\nGROUP BY source\nORDER BY top_amount DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "hint": "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
        "error_sql": "SELECT a.link_to_event \nFROM member m \nJOIN attendance a ON m.member_id = a.link_to_member \nJOIN event e ON a.link_to_event = e.event_id \nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean' AND e.event_name = 'Women''s Soccer';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "hint": "total value refers to SUM(cost); 'October Meeting' is an event name;",
        "error_sql": "SELECT expense.expense_description, SUM(expense.cost) AS total_value\nFROM expense\nJOIN budget ON expense.link_to_budget = budget.budget_id\nJOIN event ON budget.link_to_event = event.event_id\nWHERE event.event_name = 'October Meeting' AND expense.approved = 'Yes'\nGROUP BY expense.expense_description;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "hint": "full name refers to first_name, last name",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_cost \nFROM member m \nJOIN expense e ON m.member_id = e.link_to_member \nWHERE m.member_id = 'rec4BLdZHS2Blfp4v' \nGROUP BY m.member_id;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "difficulty": "simple"
    },
    {
        "question": "State the category of events were held at MU 215.",
        "hint": "'MU 215' is the location of event; ",
        "error_sql": "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "difficulty": "simple"
    },
    {
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "hint": "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
        "error_sql": "SELECT b.category \nFROM event e \nJOIN budget b ON e.event_id = b.link_to_event \nWHERE e.location = 'MU 215' \nAND e.type = 'Guest Speaker' \nAND b.spent = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "difficulty": "moderate"
    },
    {
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "hint": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone \nFROM member m\nJOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > (SELECT AVG(cost) FROM expense);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "difficulty": "challenging"
    },
    {
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "hint": "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, e.cost \nFROM expense e \nJOIN member m ON e.link_to_member = m.member_id \nWHERE e.expense_description = 'Water, Veggie tray, supplies';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "difficulty": "challenging"
    },
    {
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "hint": "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name, amount \nFROM member \nJOIN income ON member.member_id = income.link_to_member \nWHERE income.date_received = '9/9/2019';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of female patient were born after 1930?",
        "hint": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
        "error_sql": "SELECT \n    (COUNT(ID) * 1.0 / (SELECT COUNT(ID) FROM Patient WHERE SEX = 'F')) * 100 AS Percentage\nFROM Patient\nWHERE Birthday > '1930-12-31' AND SEX = 'F';",
        "compiler_hint": "no such function: year",
        "reflective_cot": "The error in the original SQL query stems from the use of the `year()` function, which is not recognized in some SQL dialects, leading to the error \"no such function: year.\" In contrast, the corrected SQL directly compares the `Birthday` field with a date string ('1930-12-31'), which avoids the need for an unsupported function.\n\n### Reasoning:\n1. The `year()` function was an incorrect approach for extracting the year part of a date in the SQL environment being used.\n2. Using a straightforward date comparison (`Birthday > '1930-12-31'`) is universally supported and more efficient.\n\n### Tip to Avoid Mistake:\nAlways check the SQL dialect documentation for supported functions. When dealing with dates, prefer direct comparisons, as they ensure compatibility across different SQL environments.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "difficulty": "moderate"
    },
    {
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
        "error_sql": "SELECT E.Symptoms, E.Diagnosis\nFROM Patient P\nJOIN Examination E ON P.ID = E.ID\nWHERE P.Birthday = (SELECT MAX(Birthday) FROM Patient)\nAND E.Symptoms IS NOT NULL;",
        "compiler_hint": "no such column: P.Symptoms",
        "reflective_cot": "### Reflection on the Error\n\nThe initial SQL query attempted to select `Symptoms` and `Diagnosis` from the `Patient` table, where `Symptoms` exists in the `Examination` table instead. This caused an error because the `Patient` table does not contain a `Symptoms` column. The corrected SQL accurately references `E.Symptoms` and `E.Diagnosis` from the `Examination` table, aligning with the appropriate table structure.\n\n### Tip\n\nWhen writing SQL queries, always ensure that you are selecting columns from the correct tables based on your `JOIN` conditions. Double-check the column names and their corresponding tables before executing the query to avoid reference errors.",
        "ground_truth_sql": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)",
        "error_sql": "SELECT `Date`, (strftime('%Y', `First Date`) - strftime('%Y', Birthday)) AS age\nFROM Laboratory \nJOIN Patient ON Laboratory.ID = Patient.ID \nWHERE Diagnosis = 'SJS' \nORDER BY Birthday ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "hint": "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Examination E ON P.ID = E.ID \nWHERE strftime('%Y', P.Birthday) <= strftime('%Y', E.`Examination Date`) - 18 \nAND strftime('%Y', E.`Examination Date`) BETWEEN '1990' AND '1993';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "difficulty": "challenging"
    },
    {
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "hint": "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
        "error_sql": "SELECT \n    strftime('%Y', Examination.`Examination Date`) - strftime('%Y', Patient.Birthday) AS Age,\n    Examination.Diagnosis\nFROM \n    Examination\nJOIN \n    Patient ON Examination.ID = Patient.ID\nJOIN \n    Laboratory ON Laboratory.ID = Patient.ID\nWHERE \n    Laboratory.HGB = (SELECT MAX(HGB) FROM Laboratory)\nLIMIT 1;",
        "compiler_hint": "no such column: Examination.HGB",
        "reflective_cot": "### Reflection on Error and Correction\n\nThe initial SQL query failed because it attempted to access a column (`HGB`) from the `Examination` table, which does not contain that column. Instead, `HGB` resides in the `Laboratory` table. The corrected SQL properly joins the `Laboratory` table to access `HGB`, ensuring that the age calculation reflects the examination date and the birthday from the appropriate tables.\n\n### Tip to Avoid Future Errors\n\nAlways verify the source of the columns being queried. Before executing a query, double-check that the columns come from the correct tables, particularly when using multiple joins. Familiarizing yourself with the database schema will also help in accurately identifying which table holds the required fields.",
        "ground_truth_sql": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "hint": "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
        "error_sql": "SELECT `aCL IgM` \nFROM Examination \nWHERE ID = (SELECT ID \n            FROM Patient \n            WHERE Diagnosis = 'SLE' \n            AND Description = '1994-02-19') \nAND `Examination Date` = '1993-11-12';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "hint": "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = DIVISION(SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN `T-CHO`), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`)), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`))",
        "error_sql": "SELECT \n    (SUM(CASE WHEN Date LIKE '1981-11-%' THEN `T-CHO` ELSE 0 END) - \n    SUM(CASE WHEN Date LIKE '1981-12-%' THEN `T-CHO` ELSE 0 END)) / \n    NULLIF(SUM(CASE WHEN Date LIKE '1981-12-%' THEN `T-CHO` ELSE 0 END), 0) AS Decrease_Rate\nFROM \n    Patient \nJOIN \n    Laboratory ON Patient.ID = Laboratory.ID \nWHERE \n    Birthday = '1959-02-18';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "hint": "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4",
        "error_sql": "SELECT DISTINCT p.ID \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nJOIN Examination e ON p.ID = e.ID \nWHERE e.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' \n  AND l.GPT > 30 \n  AND l.ALB < 4;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "difficulty": "moderate"
    },
    {
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "hint": "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)",
        "error_sql": "SELECT COUNT(*) \nFROM Examination \nWHERE Thrombosis = 2 \nAND ANA = 'S' \nAND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "difficulty": "challenging"
    },
    {
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "hint": "followed up at the outpatient clinic refers to Admission = '-'; laboratory test in April 1981 refers to Date like '1991-10%'; blood bilirubin level within the normal range refers to T-BIL < 2.0; ",
        "error_sql": "SELECT DISTINCT Patient.ID, Patient.SEX, Patient.Birthday, Patient.Description, Patient.`First Date`, Patient.Admission, Patient.Diagnosis\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.Admission = '-'\nAND Laboratory.Date LIKE '1991-10%'\nAND Laboratory.`T-BIL` < 2.0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "hint": "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100",
        "error_sql": "SELECT (SUM(SEX = 'F') * 100.0 / COUNT(SEX)) AS percentage_women\nFROM Patient\nWHERE YEAR(Birthday) = '1980' AND Diagnosis = 'RA';",
        "compiler_hint": "no such function: DIVIDE",
        "reflective_cot": "### Reflection on the Error\n\nThe initial error stemmed from the use of the `DIVIDE` function, which is not recognized in standard SQL syntax. Instead, the corrected query employed basic arithmetic for division by multiplying the numerator (`SUM(SEX = 'F')`) by 100.0 to ensure floating-point division, which prevents integer truncation.\n\n### Tip to Avoid Similar Errors\n\nTo avoid similar mistakes, always refer to the documentation of the specific SQL dialect you are using. Familiarize yourself with the available functions and syntax, ensuring you utilize supported operations for arithmetic calculations. Additionally, consider testing smaller queries to confirm basic operations function as intended before implementing complex calculations.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "difficulty": "moderate"
    },
    {
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "hint": "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'",
        "error_sql": "SELECT \n    CASE \n        WHEN (p.SEX = 'M' AND l.UA > 8.0) OR (p.SEX = 'F' AND l.UA > 6.5) THEN 'Yes' \n        ELSE 'No' \n    END AS Uric_Acid_Normal_Range\nFROM \n    Patient p \nJOIN \n    Laboratory l ON p.ID = l.ID\nWHERE \n    p.ID = 57266;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "difficulty": "moderate"
    },
    {
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "hint": "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
        "error_sql": "SELECT SEX, GROUP_CONCAT(DISTINCT P.ID) AS PatientIDs\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE L.`T-BIL` >= 2.0\nGROUP BY SEX;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "difficulty": "moderate"
    },
    {
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "hint": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); ",
        "error_sql": "SELECT P.ID, (STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday)) AS Age, P.Diagnosis \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.RBC < 3.5;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "difficulty": "moderate"
    },
    {
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "hint": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;",
        "error_sql": "SELECT \n    SUM(PLT < 100) AS Lower_Than_Normal_Range,\n    SUM(PLT > 400) AS Higher_Than_Normal_Range,\n    SUM(PLT < 100) - SUM(PLT > 400) AS Difference\nFROM Laboratory\nWHERE PLT <= 100 OR PLT >= 400;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "difficulty": "challenging"
    },
    {
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "hint": "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; ",
        "error_sql": "SELECT DISTINCT p.ID, p.SEX, p.Birthday, p.Admission, p.Diagnosis \nFROM Patient p\nJOIN Laboratory l ON p.ID = l.ID\nWHERE strftime('%Y', l.Date) = '1984' \nAND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) < 50 \nAND l.PLT BETWEEN 100 AND 400;",
        "compiler_hint": "no such function: YEAR",
        "reflective_cot": "### Reflection on the Error:\n\nThe initial query attempted to use the `YEAR()` function, which is not supported in SQLite. The error message indicated that the function does not exist. Upon revisiting, the corrected SQL utilized `strftime('%Y', ...)`, a valid function in SQLite for extracting the year from a date.\n\n### Tip to Avoid Future Errors:\n\nAlways refer to the specific database documentation for supported functions and syntax before writing queries. Familiarizing yourself with the available functions in the database system you are using can prevent similar mistakes. Additionally, consider using test queries to verify functionality before finalizing your SQL statements.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "difficulty": "challenging"
    },
    {
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "hint": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
        "error_sql": "SELECT \n    (SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 ELSE 0 END) * 100.0) / \n    NULLIF(SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END), 0) AS Female_Percentage_Abnormal_PT\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    (STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday)) > 55;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "difficulty": "challenging"
    },
    {
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "hint": "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones.",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE P.SEX = 'M' \nAND L.WBC > 3.5 AND L.WBC < 9.0 \nAND (L.FG <= 150 OR L.FG >= 450);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients with an Ig G higher than normal?",
        "hint": "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE IGG >= 2000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "difficulty": "simple"
    },
    {
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "hint": "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(`First Date`) > = 1990;",
        "error_sql": "SELECT COUNT(*) \nFROM Patient \nJOIN Laboratory ON Patient.ID = Laboratory.ID \nWHERE Laboratory.IGA > 80 AND Laboratory.IGA < 500 \nAND Patient.`First Date` >= '1990-01-01';",
        "compiler_hint": "no such function: YEAR",
        "reflective_cot": "### Reflection on the Error:\nThe initial SQL query attempted to use the `YEAR` function, which is not available in all SQL databases, particularly SQLite. This led to the error \"no such function: YEAR.\" Instead, the date filtering should be done directly using a valid date format. \n\n### Corrected Query Reasoning:\nThe corrected SQL uses a direct comparison of the `First Date` with a specific date (`'1990-01-01'`), which is universally supported across SQL databases. This method avoids relying on database-specific functions and ensures compatibility.\n\n### Tip to Avoid Future Mistakes:\nAlways check the compatibility of SQL functions with the specific database system you are using. When possible, use standard SQL syntax and date formats instead of functions that may not be supported.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
        "hint": "abnormal Ig M level refers to IGM <=40 OR IGM >= 400; most common disease refers to MAX(COUNT(Diagnosis));",
        "error_sql": "SELECT Diagnosis, COUNT(Diagnosis) as DiagnosisCount \nFROM Patient \nJOIN Laboratory ON Patient.ID = Laboratory.ID \nWHERE IGM <= 40 OR IGM >= 400 \nGROUP BY Diagnosis \nORDER BY DiagnosisCount DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "hint": "abnormal C-reactive protein refers to CRP ='+'; don't have data recorded refers to Description IS NULL;",
        "error_sql": "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nWHERE l.CRP = '+' AND p.Description IS NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "hint": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nWHERE l.RNP IN ('-', '+-') AND p.Admission = '+';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "hint": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
        "error_sql": "SELECT COUNT(*) \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nJOIN Examination e ON p.ID = e.ID \nWHERE l.SM NOT IN ('-', '+-') AND e.Thrombosis = 0;",
        "compiler_hint": "no such column: e.SM",
        "reflective_cot": "The error in the initial SQL query occurred because the `SM` column is not present in the `Examination` table, leading to the \"no such column: e.SM\" error. The corrected SQL query joined the `Laboratory` table (where the `SM` column is present) to get the necessary information.\n\n### Reasoning:\n1. The original query attempted to directly reference a column (`SM`) not contained in the `Examination` table.\n2. The corrected SQL query accurately retrieves the `SM` column from the `Laboratory` table, allowing for proper filtering on normal anti-SM values.\n\n### Tip to Avoid Future Mistakes:\nAlways verify the presence of columns in the respective tables before writing the JOIN conditions. Review the schema and ensure that any fields you reference are available in the corresponding tables used in the query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "hint": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient P \nJOIN Laboratory L ON P.ID = L.ID \nWHERE L.CENTROMEA IN ('-', '+-') \nAND L.SSB IN ('-', '+-') \nAND P.SEX = 'M';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "hint": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT MIN(Birthday) AS Youngest_Birthday \nFROM Patient \nWHERE ID IN (\n    SELECT ID \n    FROM Laboratory \n    WHERE GOT >= 60\n);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "hint": "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;",
        "error_sql": "SELECT COUNT(DISTINCT p.ID) \nFROM Patient p \nJOIN Laboratory l ON p.ID = l.ID \nJOIN Examination e ON p.ID = e.ID \nWHERE l.CPK < 250 AND (e.KCT = '+' OR e.RVVT = '+' OR e.LAC = '+');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "difficulty": "challenging"
    },
    {
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "hint": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
        "error_sql": "SELECT team_api_id, buildUpPlaySpeed \nFROM Team_Attributes \nORDER BY buildUpPlaySpeed DESC \nLIMIT 4;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "difficulty": "moderate"
    },
    {
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "hint": "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';",
        "error_sql": "SELECT L.name\nFROM Match M\nJOIN League L ON M.league_id = L.id\nWHERE M.season = '2015/2016'\nGROUP BY L.id\nHAVING SUM(home_team_goal = away_team_goal) = (\n    SELECT MAX(draw_count)\n    FROM (\n        SELECT COUNT(*) AS draw_count\n        FROM Match\n        WHERE season = '2015/2016'\n        GROUP BY league_id\n        HAVING home_team_goal = away_team_goal\n    )\n)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "hint": "players age at present = SUBTRACT((DATETIME(), birthday)); sprint speed of no less than 97 refers to sprint_speed > = 97; between 2013 to 2015 refers to YEAR(date) > = '2013' AND YEAR(date) < = '2015'; ",
        "error_sql": "SELECT player_name, \n       (strftime('%Y', 'now') - strftime('%Y', birthday)) AS age \nFROM Player P \nJOIN Player_Attributes PA ON P.player_api_id = PA.player_api_id \nWHERE sprint_speed >= 97 \n  AND date BETWEEN '2013-01-01' AND '2015-12-31';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "difficulty": "challenging"
    },
    {
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "hint": " league with highest matches of all time refers to MAX(COUNT(league_id));",
        "error_sql": "SELECT League.name, COUNT(Match.id) AS total_matches \nFROM Match \nJOIN League ON Match.league_id = League.id \nGROUP BY League.id \nORDER BY total_matches DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "hint": "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
        "error_sql": "SELECT \n    (SUM(pa.preferred_foot = 'left') * 100.0 / COUNT(p.player_fifa_api_id)) AS percentage_left_foot_players\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\nWHERE \n    YEAR(p.birthday) BETWEEN 1987 AND 1992;",
        "compiler_hint": "no such column: preferred_foot",
        "reflective_cot": "The error in the initial SQL query arose because the `preferred_foot` column does not exist in the `Player` table; it is located in the `Player_Attributes` table. The corrected query properly joins the `Player` and `Player_Attributes` tables to access the `preferred_foot` column.\n\n### Tip to Avoid Future Mistakes:\nAlways confirm the table and column names before writing your queries, especially when dealing with multiple related tables. This helps ensure that you reference the correct fields and reduces the chances of encountering \"no such column\" errors. Using a database schema diagram can also be beneficial for visualizing relationships.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "difficulty": "challenging"
    },
    {
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "hint": "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';",
        "error_sql": "SELECT * FROM Player WHERE substr(birthday, 1, 7) = '1970-10';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "difficulty": "simple"
    },
    {
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "hint": "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);",
        "error_sql": "SELECT AVG(finishing) AS average_finishing_rate, player_name\nFROM Player\nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id\nWHERE height IN (SELECT MAX(height) FROM Player) OR height IN (SELECT MIN(height) FROM Player)\nGROUP BY player_name\nORDER BY average_finishing_rate DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "hint": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
        "error_sql": "SELECT AVG(pa.overall_rating) AS average_overall_rating\nFROM Player_Attributes pa\nJOIN Player p ON pa.player_api_id = p.player_api_id\nWHERE strftime('%Y', pa.date) BETWEEN '2010' AND '2015'\nAND p.height > 170;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "hint": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)",
        "error_sql": "SELECT \n    (SELECT SUM(CASE WHEN p.player_name = 'Abdou Diallo' THEN pa.ball_control ELSE 0 END) / \n            COUNT(CASE WHEN p.player_name = 'Abdou Diallo' THEN pa.id ELSE NULL END) \n     FROM Player p \n     JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id) - \n    (SELECT SUM(CASE WHEN p.player_name = 'Aaron Appindangoye' THEN pa.ball_control ELSE 0 END) / \n            COUNT(CASE WHEN p.player_name = 'Aaron Appindangoye' THEN pa.id ELSE NULL END) \n     FROM Player p \n     JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id) AS difference;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "hint": "The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT player_name, birthday\nFROM Player\nWHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada')\nORDER BY birthday ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which player is the tallest?",
        "hint": "tallest player refers to MAX(height);",
        "error_sql": "SELECT player_name, height FROM Player ORDER BY height DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "hint": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
        "error_sql": "SELECT L.name \nFROM Match M \nJOIN League L ON M.league_id = L.id \nWHERE M.season = '2008/2009' \nGROUP BY L.name \nORDER BY COUNT(M.id) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "difficulty": "simple"
    },
    {
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "hint": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
        "error_sql": "SELECT \n    ((SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ariel Borysiuk')) - \n    (SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel'))) / \n    (SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel')) * 100 AS percentage_difference;",
        "compiler_hint": "no such column: difference",
        "reflective_cot": "### Reflection:\nThe initial error occurred because SQL does not support the use of column aliases in the same select level where they are defined. In the original query, trying to use `difference` in the same select statement where it was calculated resulted in the \"no such column\" error.\n\nIn the corrected SQL, I computed the percentage difference directly within the select statement, referencing the overall ratings without trying to create a reusable alias for `difference`. Hence, the calculation is done in one step, allowing for a successful execution.\n\n### Tip:\nTo avoid such mistakes in the future, remember that SQL does not allow the referencing of computed columns in the same level of the select statement. If necessary, perform calculations in a subquery or use `WITH` clauses to define common table expressions (CTEs) which can be referenced subsequently.",
        "ground_truth_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "hint": "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)",
        "error_sql": "SELECT date \nFROM Player_Attributes \nWHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Kevin Constant') \nAND crossing = (SELECT MAX(crossing) FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Kevin Constant'));",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "hint": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100",
        "error_sql": "SELECT \n    (SELECT overall_rating FROM Player_Attributes \n     WHERE player_fifa_api_id = (SELECT player_fifa_api_id FROM Player WHERE player_name = 'Landon Donovan') \n     AND date = '2013-07-12') - \n    (SELECT overall_rating FROM Player_Attributes \n     WHERE player_fifa_api_id = (SELECT player_fifa_api_id FROM Player WHERE player_name = 'Jordan Bowery') \n     AND date = '2013-07-12') AS rating_difference,\n    ((SELECT overall_rating FROM Player_Attributes \n      WHERE player_fifa_api_id = (SELECT player_fifa_api_id FROM Player WHERE player_name = 'Landon Donovan') \n      AND date = '2013-07-12') - \n    (SELECT overall_rating FROM Player_Attributes \n     WHERE player_fifa_api_id = (SELECT player_fifa_api_id FROM Player WHERE player_name = 'Jordan Bowery') \n     AND date = '2013-07-12')) * 100.0 / \n    (SELECT overall_rating FROM Player_Attributes \n     WHERE player_fifa_api_id = (SELECT player_fifa_api_id FROM Player WHERE player_name = 'Jordan Bowery') \n     AND date = '2013-07-12') AS percentage_higher;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "difficulty": "challenging"
    },
    {
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "hint": "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'",
        "error_sql": "SELECT COUNT(*) \nFROM Player \nWHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "difficulty": "simple"
    },
    {
        "question": "Please provide top four football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "hint": "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
        "error_sql": "SELECT player_api_id \nFROM Player_Attributes \nWHERE potential = (SELECT MIN(potential) FROM Player_Attributes) \nAND preferred_foot = 'right' \nLIMIT 4;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 4",
        "difficulty": "moderate"
    },
    {
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "hint": "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
        "error_sql": "SELECT pa.finishing AS finishing_rate, pa.curve AS curve_score \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.weight = (SELECT MAX(weight) FROM Player);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which top 4 leagues had the most games in the 2015-2016 season?",
        "hint": "in the 2015-2016 season refers to season = '2015/2016'; league with most games refers to League.name where MAX(COUNT(id))",
        "error_sql": "SELECT L.name, COUNT(M.id) as games_count\nFROM Match M\nJOIN League L ON M.league_id = L.id\nWHERE M.season = '2015/2016'\nGROUP BY L.name\nORDER BY games_count DESC\nLIMIT 4;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4",
        "difficulty": "simple"
    },
    {
        "question": "Please name one player whose overall strength is the greatest.",
        "hint": "overall strength is the greatest refers to MAX(overall_rating)",
        "error_sql": "SELECT P.player_name, PA.overall_rating",
        "compiler_hint": "no such column: player_name",
        "reflective_cot": "### Reflection on the Error\n\nThe original SQL query failed because the `player_name` column does not exist in the `Player_Attributes` table; instead, it resides in the `Player` table. Therefore, the correct approach involves a JOIN between `Player_Attributes` (PA) and `Player` (P) to access the player's name alongside their overall rating.\n\n### Corrected SQL\n```sql\nSELECT P.player_name, PA.overall_rating\nFROM Player_Attributes PA\nJOIN Player P ON PA.player_api_id = P.player_api_id\nORDER BY PA.overall_rating DESC\nLIMIT 1;\n```\n\n### Tip to Avoid This Mistake\nAlways ensure that you verify the existence of columns in the appropriate tables when using multiple tables. Familiarity with the schema helps prevent such mistakes and ensures accurate JOIN conditions.",
        "ground_truth_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "difficulty": "simple"
    },
    {
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "hint": "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);",
        "error_sql": "SELECT d.surname \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 19 AND q.q2 = (SELECT MIN(q2) FROM qualifying WHERE raceId = 19);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "hint": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'",
        "error_sql": "SELECT driverId FROM qualifying WHERE raceId = 903 AND q3 LIKE '0:01:54%';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "difficulty": "simple"
    },
    {
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "hint": "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT d.forename, d.surname, d.dob \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.raceId = 592 AND r.time IS NOT NULL \nORDER BY d.dob ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "hint": "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
        "error_sql": "SELECT d.url \nFROM lapTimes lt \nJOIN drivers d ON lt.driverId = d.driverId \nWHERE lt.time LIKE '0:01:27' AND lt.raceId = 161;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "difficulty": "moderate"
    },
    {
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "hint": "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'",
        "error_sql": "SELECT d.code \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 45 AND q.q3 LIKE '0:01:33%';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "difficulty": "simple"
    },
    {
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "hint": "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);",
        "error_sql": "SELECT driverId, dob \nFROM drivers \nJOIN results ON drivers.driverId = results.driverId \nWHERE results.raceId = 872 AND results.time IS NOT NULL \nORDER BY dob DESC \nLIMIT 1;",
        "compiler_hint": "no such column: dob",
        "reflective_cot": "### Reflection on the Error\n\nThe initial SQL query attempted to select the `dob` column directly from the `results` table, which does not contain this field. The `dob` (date of birth) actually resides in the `drivers` table. This results in an SQL error since the column doesn't exist in the context of the query. \n\nThe corrected query addresses this by properly joining the `drivers` table with the `results` table to access the `dob` column. It then filters for race ID 872 and only considers drivers who finished (i.e., have a non-null `time`), finally ordering by birth date to find the youngest driver.\n\n### Tip to Avoid Similar Errors\n\nAlways ensure you understand the structure of your tables and which columns reside in which tables. When crafting queries, double-check column references to ensure they exist in the specified tables, especially after joins, to avoid runtime errors.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "hint": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
        "error_sql": "SELECT \n    (SELECT fastestLapSpeed FROM results \n     WHERE raceId = 853 \n     AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta')) - \n    (SELECT fastestLapSpeed FROM results \n     WHERE raceId = 854 \n     AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta')) AS speed_difference,\n    ((SELECT fastestLapSpeed FROM results \n      WHERE raceId = 853 \n      AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta')) - \n    (SELECT fastestLapSpeed FROM results \n     WHERE raceId = 854 \n     AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta'))) * 100.0 / \n    (SELECT fastestLapSpeed FROM results \n     WHERE raceId = 854 \n     AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Paul' AND surname = 'di Resta')) AS percent_faster;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "hint": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name",
        "error_sql": "SELECT d.forename, d.surname, r.name \nFROM lapTimes lt \nJOIN drivers d ON lt.driverId = d.driverId \nJOIN races r ON lt.raceId = r.raceId \nWHERE lt.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "hint": "average lap time = AVG(milliseconds); 'Lewis Hamilton' refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; 'Malaysian Grand Prix' refers to races.name = 'Malaysian Grand Prix'",
        "error_sql": "SELECT AVG(lapTimes.milliseconds) AS average_lap_time\nFROM lapTimes\nJOIN races ON lapTimes.raceId = races.raceId\nJOIN drivers ON lapTimes.driverId = drivers.driverId\nWHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' \nAND races.name = 'Malaysian Grand Prix';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "hint": "percentage = DIVIDE(COUNT(raceId) where surname = 'Hamilton' and position>1), (COUNT(raceId) where surname = 'Hamilton'); since 2010 refers to year >= 2010",
        "error_sql": "SELECT \n    (COUNT(raceId) * 1.0 - COUNT(CASE WHEN results.position = 1 THEN 1 END)) * 100.0 / COUNT(raceId) AS percentage\nFROM results \nJOIN drivers ON results.driverId = drivers.driverId \nJOIN races ON results.raceId = races.raceId \nWHERE drivers.surname = 'Hamilton' AND races.year >= 2010;",
        "compiler_hint": "ambiguous column name: raceId",
        "reflective_cot": "The error encountered in the SQL query was due to an ambiguous reference to `raceId`, which was present in both the `results` and `races` tables. In SQL, when multiple tables have columns with the same name and they are joined, you need to explicitly specify which table's column you are referring to.\n\n### Reasoning:\nIn the original query, the SQL engine could not determine whether `raceId` referred to the `results` or `races` table, leading to the 'ambiguous column name' error. By prefixing `raceId` with the `results` table alias (`results.raceId`), the ambiguity was resolved in the corrected query.\n\n### Tip to Avoid Errors:\nAlways qualify column names with their respective table aliases (e.g., `table_name.column_name`) when dealing with joins involving multiple tables. This practice enhances clarity and prevents ambiguity errors in SQL queries.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "difficulty": "challenging"
    },
    {
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS driver_full_name, d.nationality, MAX(ds.points) AS max_points\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nGROUP BY d.driverId\nHAVING SUM(ds.wins) = (SELECT MAX(total_wins)\n                       FROM (SELECT SUM(wins) AS total_wins\n                             FROM driverStandings\n                             GROUP BY driverId));",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How old is the youngest Japanese driver? What is his name?",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
        "error_sql": "SELECT forename, surname, (strftime('%Y', 'now') - strftime('%Y', dob)) AS age \nFROM drivers \nWHERE nationality = 'Japanese' \nORDER BY dob DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "hint": "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
        "error_sql": "SELECT r.name, r.date \nFROM results res \nJOIN drivers d ON res.driverId = d.driverId \nJOIN races r ON res.raceId = r.raceId \nWHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.position < 20;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "difficulty": "simple"
    },
    {
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "hint": "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT r.name, r.year \nFROM results res \nJOIN races r ON res.raceId = r.raceId \nJOIN drivers d ON res.driverId = d.driverId \nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher' \nORDER BY res.fastestLapTime ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "hint": "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT r.raceId, rs.points \nFROM results rs\nJOIN races r ON rs.raceId = r.raceId\nJOIN drivers d ON rs.driverId = d.driverId\nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton'\nORDER BY r.year, r.round\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which country is the oldest driver from?",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT nationality FROM drivers ORDER BY dob ASC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "hint": "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';",
        "error_sql": "SELECT d.driverRef \nFROM results r \nJOIN races ra ON r.raceId = ra.raceId \nJOIN drivers d ON r.driverId = d.driverId \nWHERE ra.name = 'Canadian Grand Prix' AND ra.year = 2007 AND r.positionOrder = 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "difficulty": "moderate"
    },
    {
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "hint": "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT races.name, results.rank \nFROM results \nJOIN drivers ON results.driverId = drivers.driverId \nJOIN races ON results.raceId = races.raceId \nWHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' \nORDER BY results.rank ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "difficulty": "simple"
    },
    {
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "hint": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "error_sql": "SELECT r.time \nFROM results res \nJOIN races r ON res.raceId = r.raceId \nWHERE r.name = 'Chinese Grand Prix' AND r.year = 2008 AND res.positionOrder = 2;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "difficulty": "simple"
    },
    {
        "question": "Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?",
        "hint": "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value.",
        "error_sql": "SELECT COUNT(DISTINCT d.driverId) \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.raceId = (SELECT raceId FROM races WHERE year = 2008 AND name LIKE '%Chinese Grand Prix%') \nAND r.position IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the constructor names with 0 points at race 291.",
        "hint": "race at 291 refers to raceID = 291;",
        "error_sql": "SELECT c.name \nFROM constructors c \nJOIN constructorResults cr ON c.constructorId = cr.constructorId \nWHERE cr.raceId = 291 AND cr.points = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "difficulty": "simple"
    },
    {
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "hint": "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';",
        "error_sql": "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors c\nJOIN constructorResults cr ON c.constructorId = cr.constructorId\nWHERE c.nationality = 'Japanese' \nGROUP BY c.constructorId \nHAVING COUNT(DISTINCT cr.raceId) = 2 AND SUM(cr.points) = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "difficulty": "simple"
    },
    {
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "hint": "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
        "error_sql": "SELECT \n    year, \n    AVG(\n        (CAST(SUBSTR(time, 1, 2) AS INTEGER) * 3600) + \n         (CAST(SUBSTR(time, 4, 2) AS INTEGER) * 60) + \n         (CAST(SUBSTR(time, 7, 2) AS INTEGER) + \n         (CAST(SUBSTR(time, 10) AS INTEGER) / 1000))\n        )\n    ) AS average_time_seconds\nFROM \n    results \nJOIN \n    races ON results.raceId = races.raceId \nWHERE \n    statusId IS NOT NULL \n    AND year < 1975 \n    AND time IS NOT NULL \n    AND positionOrder = 1 \nGROUP BY \n    year;",
        "compiler_hint": "near \")\": syntax error",
        "reflective_cot": "The error in the original SQL query occurred due to a misplaced parentheses that resulted in a syntax error. Specifically, the parentheses for calculating the average time were misaligned, causing the SQL parser to be confused about the structure of the expression.\n\nIn the corrected SQL, I ensured that the parentheses correctly encapsulated the calculations for converting the 'HH:MM:SS.mmm' format to seconds. \n\n**Tip to Avoid Future Mistakes:** Always double-check the alignment of your parentheses, especially in complex expressions involving multiple calculations. Writing out the expression step-by-step or using indentation can help clarify the structure and prevent syntax errors. Additionally, validating the query with smaller parts can make it easier to catch such mistakes.",
        "ground_truth_sql": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "difficulty": "challenging"
    },
    {
        "question": "What is the fastest lap number of the champion in 2009?",
        "hint": "in 2009 refers to year = 2009; Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\"",
        "error_sql": "SELECT fastestLap FROM results \nWHERE raceId IN (SELECT raceId FROM races WHERE year = 2009) \nAND driverId IN (SELECT driverId FROM driverStandings WHERE raceId IN (SELECT raceId FROM races WHERE year = 2009) ORDER BY points DESC LIMIT 1) \nORDER BY fastestLap;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "simple"
    },
    {
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "hint": "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;",
        "error_sql": "SELECT \n    (COUNT(DISTINCT r.driverId) * 100.0 / NULLIF(COUNT(DISTINCT d.driverId), 0)) AS percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nWHERE \n    d.dob < '1985-01-01' \n    AND r.laps > 50 \n    AND r.raceId IN (\n        SELECT raceId \n        FROM races \n        WHERE year BETWEEN 2000 AND 2005\n    );",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "difficulty": "challenging"
    },
    {
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "hint": "lap time less than 02:00.00 refers to seconds < 120;",
        "error_sql": "SELECT COUNT(DISTINCT d.driverId) \nFROM drivers d \nJOIN lapTimes l ON d.driverId = l.driverId \nWHERE d.nationality = 'French' AND l.milliseconds < 120000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "difficulty": "moderate"
    },
    {
        "question": "List out the code for drivers who have nationality in American.",
        "hint": "nationality = 'American'",
        "error_sql": "SELECT driverId, driverRef, forename, surname FROM drivers WHERE nationality = 'American';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "difficulty": "simple"
    },
    {
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "hint": "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country",
        "error_sql": "SELECT driverId, code FROM drivers WHERE driverId IN (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 3); \nSELECT COUNT(*) FROM drivers WHERE nationality = 'Netherlands' AND driverId IN (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 3);",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "The error in the original SQL query arises from attempting to execute multiple statements simultaneously, which is not permitted in many SQL environments. The corrected version separated the queries, but it still executes multiple statements.\n\nTo efficiently retrieve the top 3 youngest drivers and count how many are from the Netherlands in one go, you can use a single query with a common table expression (CTE) or a subquery.\n\nHere\u2019s a single-query alternative:\n\n```sql\nWITH YoungestDrivers AS (\n    SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 3\n)\nSELECT COUNT(*) \nFROM drivers \nWHERE nationality = 'Netherlands' AND driverId IN (SELECT driverId FROM YoungestDrivers);\n```\n\n### Tip:\nAlways aim to consolidate multiple operations into a single SQL statement (e.g., using CTEs or subqueries) when possible. This reduces execution errors and enhances performance.",
        "ground_truth_sql": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "difficulty": "simple"
    },
    {
        "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "hint": "location coordinates refers to (lat,lng); Austria refers to country = 'Austria';",
        "error_sql": "SELECT COUNT(circuitId) AS timesHeld, location, lat, lng \nFROM circuits \nWHERE country = 'Austria' \nGROUP BY location, lat, lng;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "difficulty": "simple"
    },
    {
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);",
        "error_sql": "SELECT d.forename, d.surname, MIN(r.date) AS first_qualifying_date, r.time, strftime('%Y', d.dob) AS birth_year\nFROM drivers d\nJOIN qualifying q ON d.driverId = q.driverId\nJOIN races r ON q.raceId = r.raceId\nGROUP BY d.driverId\nORDER BY d.dob DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980<= year(dob) <=1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name, \n       AVG(ps.milliseconds) / 1000.0 AS avg_pit_stop_duration\nFROM drivers d\nJOIN pitStops ps ON d.driverId = ps.driverId\nWHERE d.nationality = 'German' \n  AND strftime('%Y', d.dob) BETWEEN '1980' AND '1985'\nGROUP BY d.driverId\nORDER BY avg_pit_stop_duration\nLIMIT 3;",
        "compiler_hint": "no such function: PARSE_DURATION",
        "reflective_cot": "### Reflection on the SQL Error\n\nThe original SQL query encountered an error because it attempted to use a function `PARSE_DURATION` that is not recognized in SQLite. This led to a failure in the query execution. \n\nIn the corrected SQL, the approach was modified to use `ps.milliseconds`, which captures the duration in milliseconds directly. The division by 1000.0 converts this value into seconds, which is a straightforward method of calculating average pit stop duration while ensuring compatibility with SQLite's available functions.\n\n### Tip to Avoid Future Mistakes\n\nAlways verify the functions and methods used in SQL queries against the specific database documentation. If a function isn\u2019t supported (like `PARSE_DURATION` in this case), look for alternate ways to achieve the desired outcome using available functions or straightforward mathematical operations. This practice will help prevent errors related to unsupported functions and ensure query stability.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "difficulty": "challenging"
    },
    {
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "hint": "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS champion, r.time\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2008 AND ra.name = 'Canadian Grand Prix' AND r.positionOrder = 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "moderate"
    },
    {
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "hint": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
        "error_sql": "SELECT SUM(cs.points) AS total_points, c.name, c.nationality \nFROM constructorStandings cs\nJOIN races r ON cs.raceId = r.raceId\nJOIN constructors c ON cs.constructorId = c.constructorId\nWHERE r.year BETWEEN 1980 AND 2010 AND r.name = 'Monaco Grand Prix'\nGROUP BY cs.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "hint": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name \nFROM qualifying q\nJOIN races r ON q.raceId = r.raceId\nJOIN drivers d ON q.driverId = d.driverId\nWHERE r.year = 2008 AND r.round = 3 AND q.q3 IS NOT NULL\nORDER BY q.q3 \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "hint": "full name refers to forename+surname; Youngest racer = MAX(dob)",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name, d.nationality, r.name AS first_race\nFROM drivers d\nJOIN results res ON d.driverId = res.driverId\nJOIN races r ON res.raceId = r.raceId\nWHERE d.dob = (SELECT MAX(dob) FROM drivers)\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "hint": "number of accidents refers to the number where statusid = 3; Canadian Grand Prix refers to the race of name\n",
        "error_sql": "SELECT driverId, COUNT(*) AS accidents \nFROM results \nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Canadian Grand Prix') \nAND statusId = 3 \nGROUP BY driverId \nORDER BY accidents DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "hint": "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name\nFROM lapTimes lt\nJOIN drivers d ON lt.driverId = d.driverId\nWHERE lt.time IS NOT NULL\nORDER BY lt.milliseconds ASC\nLIMIT 20;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "difficulty": "challenging"
    },
    {
        "question": "Please list the lap records for the circuits in Italy.",
        "hint": "lap record means the fastest time recorded which refers to time",
        "error_sql": "SELECT l.raceId, l.driverId, l.lap, l.time, l.milliseconds, c.circuitRef, c.name, c.country\nFROM lapTimes l\nJOIN races r ON l.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE c.country = 'Italy'\nORDER BY l.milliseconds ASC;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "hint": "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
        "error_sql": "SELECT superhero.superhero_name, superhero.height_cm\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics'\nORDER BY superhero.height_cm DESC;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "difficulty": "moderate"
    },
    {
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "hint": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
        "error_sql": "SELECT c.colour, COUNT(s.id) AS superhero_count \nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN colour c ON s.eye_colour_id = c.id\nWHERE p.publisher_name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "difficulty": "moderate"
    },
    {
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "hint": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';",
        "error_sql": "SELECT s.superhero_name, s.full_name \nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_power hp ON s.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE p.publisher_name = 'Marvel Comics' AND sp.power_name = 'Super Strength';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "difficulty": "challenging"
    },
    {
        "question": "Who is the dumbest superhero?",
        "hint": "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'",
        "error_sql": "SELECT s.superhero_name, ha.attribute_value \nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Intelligence'\nORDER BY ha.attribute_value ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "hint": "durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50",
        "error_sql": "SELECT h.superhero_name, h.full_name \nFROM superhero h\nJOIN hero_attribute ha ON h.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Durability' AND ha.attribute_value < 50;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "hint": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Bad' THEN 1 END) * 100.0) / COUNT(s.id) AS percentage_bad_superheroes,\n    COUNT(CASE WHEN a.alignment = 'Bad' AND p.publisher_name = 'Marvel Comics' THEN 1 END) AS marvel_bad_superheroes\nFROM \n    superhero s\nJOIN \n    alignment a ON s.alignment_id = a.id\nJOIN \n    publisher p ON s.publisher_id = p.id;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "difficulty": "challenging"
    },
    {
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "hint": "height from 170 to 190 refers to height_cm BETWEEN 170 AND 190; no eye color refers to colour = 'No Colour'",
        "error_sql": "SELECT superhero_name \nFROM superhero \nWHERE height_cm BETWEEN 170 AND 190 \nAND eye_colour_id IS NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "hint": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
        "error_sql": "SELECT c.colour \nFROM superhero s \nJOIN race r ON s.race_id = r.id \nJOIN colour c ON s.hair_colour_id = c.id \nWHERE s.height_cm = 185 AND r.race = 'human';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the hero's full name with the highest attribute in strength?",
        "hint": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "error_sql": "SELECT sh.full_name \nFROM superhero sh \nJOIN hero_attribute ha ON sh.id = ha.hero_id \nJOIN attribute a ON ha.attribute_id = a.id \nWHERE a.attribute_name = 'strength' \nAND ha.attribute_value = (SELECT MAX(attribute_value) \n                          FROM hero_attribute \n                          JOIN attribute ON hero_attribute.attribute_id = attribute.id \n                          WHERE attribute.attribute_name = 'strength');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "hint": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "error_sql": "SELECT s.superhero_name\nFROM superhero s\nJOIN publisher p ON s.publisher_id = p.id\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'durability' AND p.publisher_name = 'Dark Horse Comics'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "hint": "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "error_sql": "SELECT c1.colour AS eye_colour, c2.colour AS hair_colour, c3.colour AS skin_colour \nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN publisher p ON s.publisher_id = p.id\nJOIN colour c1 ON s.eye_colour_id = c1.id\nJOIN colour c2 ON s.hair_colour_id = c2.id\nJOIN colour c3 ON s.skin_colour_id = c3.id\nWHERE g.gender = 'Female' AND p.publisher_name = 'Dark Horse Comics';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average height for all superhero.",
        "hint": "average = DIVIDE(SUM(height_cm), COUNT(all heros));",
        "error_sql": "SELECT AVG(height_cm) AS average_height FROM superhero;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "difficulty": "simple"
    },
    {
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "hint": "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;",
        "error_sql": "SELECT \n    (SUM(CASE WHEN eye_colour_id = 7 THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN eye_colour_id IS NULL THEN 1 ELSE 0 END)) AS difference\nFROM superhero\nWHERE weight_kg IS NULL OR weight_kg = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "difficulty": "challenging"
    },
    {
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "hint": "\"Harlan\" and \"Jarrod Dixon\" are both DisplayName; highest reputation refers to Max(Reputation)",
        "error_sql": "SELECT DisplayName, MAX(Reputation) AS MaxReputation \nFROM users \nWHERE DisplayName IN ('Harlan', 'Jarrod Dixon') \nGROUP BY DisplayName \nORDER BY MaxReputation DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "difficulty": "simple"
    },
    {
        "question": "How many users last accessed the website after 2014/9/1?",
        "hint": "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
        "error_sql": "SELECT COUNT(*) FROM users WHERE LastAccessDate > '2014-09-01';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "difficulty": "simple"
    },
    {
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "hint": "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId",
        "error_sql": "SELECT LastEditorDisplayName FROM posts WHERE Title = 'Examples for teaching: Correlation does not mean causation';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "difficulty": "moderate"
    },
    {
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "hint": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
        "error_sql": "SELECT FavoriteCount \nFROM posts \nWHERE Id = (SELECT PostId \n            FROM comments \n            WHERE UserId = 3025 \n            AND CreationDate = '2014/4/23 20:29:39.0');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "difficulty": "moderate"
    },
    {
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "hint": "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa",
        "error_sql": "SELECT CASE WHEN p.ClosedDate IS NULL THEN 'Yes' ELSE 'No' END AS WellFinished\nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "difficulty": "moderate"
    },
    {
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "hint": "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
        "error_sql": "SELECT COUNT(posts.Id) * 1.0 / COUNT(votes.Id) AS PostToVoteRatio \nFROM posts \nLEFT JOIN votes ON posts.Id = votes.PostId \nWHERE posts.OwnerUserId = 24;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "difficulty": "moderate"
    },
    {
        "question": "Name the user that commented 'thank you user93!'",
        "hint": "\"thank you user93\" is the Text of comment; user refers to DisplayName",
        "error_sql": "SELECT UserDisplayName FROM comments WHERE Text = 'thank you user93!';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "difficulty": "simple"
    },
    {
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "hint": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
        "error_sql": "SELECT c.Text \nFROM comments c\nJOIN posts p ON c.PostId = p.Id\nWHERE p.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "difficulty": "moderate"
    },
    {
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "hint": "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'",
        "error_sql": "SELECT u.DisplayName \nFROM votes v \nJOIN posts p ON v.PostId = p.Id \nJOIN users u ON v.UserId = u.Id \nWHERE v.BountyAmount = 50 AND p.Title LIKE '%variance%';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "hint": "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)",
        "error_sql": "SELECT p.Title, c.Text, AVG(p.ViewCount) AS AverageViewCount\nFROM posts p\nJOIN tags t ON t.Id = p.Tags\nJOIN comments c ON c.PostId = p.Id\nWHERE t.TagName = 'humor'\nGROUP BY p.Id, c.Id;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "difficulty": "moderate"
    },
    {
        "question": "How many users are awarded with more than 5 badges?",
        "hint": "more than 5 badges refers to Count (Name) > 5; user refers to UserId",
        "error_sql": "SELECT COUNT(DISTINCT UserId) \nFROM badges \nGROUP BY UserId \nHAVING COUNT(Name) > 5;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "difficulty": "simple"
    },
    {
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "hint": "having at least 1000 view refers to Views > = 1000; user refers to UserId",
        "error_sql": "SELECT ph.UserId\nFROM postHistory ph\nJOIN posts p ON ph.PostId = p.Id\nGROUP BY ph.PostId, ph.UserId\nHAVING COUNT(ph.Id) = 1 AND p.ViewCount >= 1000;",
        "compiler_hint": "no such column: p.Views",
        "reflective_cot": "The initial SQL query encountered an error because it incorrectly referenced `p.Views`, a non-existent column. Upon reflection, the correct schema indicates that the column for tracking views is `ViewCount`, not `Views`.\n\nIn the corrected SQL, the appropriate column `p.ViewCount` was used instead of the incorrect `p.Views`. This demonstrates the importance of closely inspecting the table schema to ensure accurate column names are referenced in queries.\n\n**Tip to Avoid Similar Mistakes:** Always double-check the schema definitions before writing SQL queries to ensure correct column names and types are being used. Having documentation access can prevent confusion and errors in future queries.",
        "ground_truth_sql": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "hint": "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
        "error_sql": "SELECT MAX(ViewCount) AS MaxViewCount \nFROM posts \nWHERE OwnerUserId IN (SELECT Id FROM users WHERE DisplayName IN ('Harvey Motulsky', 'Noah Snyder')) \nGROUP BY OwnerUserId;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "hint": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
        "error_sql": "SELECT t.TagName \nFROM tags t \nJOIN posts p ON t.ExcerptPostId = p.Id \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName = 'Mark Meckes' AND p.CommentCount = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "hint": "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN t.TagName = 'r' THEN p.Id END) * 100.0 / COUNT(p.Id)) AS percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nJOIN \n    tags t ON p.Tags LIKE '%' || t.TagName || '%'\nWHERE \n    u.DisplayName = 'Community';",
        "compiler_hint": "no such table: postTags",
        "reflective_cot": "The original SQL query encountered an error because it tried to reference a non-existent `postTags` table for the association between posts and tags. The error highlights the importance of understanding the database schema and existing relationships.\n\nIn the corrected SQL, I used a `LIKE` clause to check for the presence of the tag name in the `Tags` column of the `posts` table. However, this might not be the most reliable solution, as it assumes that tags are stored as comma-separated values in the `Tags` text and does not ensure exact matching.\n\n**Tip to Avoid Future Mistakes:**\nAlways double-check the database schema for relationships between tables, and be careful with string matching to ensure accuracy. Use proper foreign keys and join tables when needed, and avoid ambiguous operations like substring matching unless it's explicitly intended.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "hint": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
        "error_sql": "SELECT \n    (SELECT SUM(ViewCount) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Mornington') - \n    (SELECT SUM(ViewCount) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Amos') AS ViewCountDifference;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "difficulty": "moderate"
    },
    {
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "hint": "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';",
        "error_sql": "SELECT COUNT(DISTINCT u.Id) \nFROM users u \nJOIN posts p ON u.Id = p.OwnerUserId \nWHERE u.Location = 'United Kingdom' AND p.FavoriteCount >= 4;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "difficulty": "moderate"
    },
    {
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "hint": "the most valuable post in 2010 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
        "error_sql": "SELECT Id, OwnerDisplayName \nFROM posts \nWHERE FavoriteCount = (SELECT MAX(FavoriteCount) \n                       FROM posts \n                       WHERE strftime('%Y', CreaionDate) = '2010');",
        "compiler_hint": "no such column: CreationDate",
        "reflective_cot": "### Reflection on the Error:\nThe original SQL query failed because it referenced the column `CreationDate`, which was misspelled as `CreaionDate` in the `posts` table schema. This discrepancy led to the error \"no such column.\" The corrected SQL adjusted the spelling, properly aligning the column name with the schema.\n\n### Tip to Avoid Similar Mistakes:\nAlways double-check column names against the database schema before writing queries. Using consistent naming conventions and careful typing can help prevent such errors. Additionally, consider using an Integrated Development Environment (IDE) or tools that provide autocompletion for column names to minimize typographical errors.",
        "ground_truth_sql": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "hint": "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;",
        "error_sql": "SELECT (COUNT(p.Id) * 100.0 / (SELECT COUNT(*) FROM posts)) AS percentage\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE strftime('%Y', p.CreaionDate) = '2011' AND u.Reputation > 1000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "hint": "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';",
        "error_sql": "SELECT p.ViewCount, u.DisplayName \nFROM posts p \nJOIN users u ON p.LastEditorUserId = u.Id \nWHERE p.Title = 'Computer Game Datasets';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "hint": "the latest comment refers to MAX(CreationDate);",
        "error_sql": "SELECT c.Text, c.UserDisplayName \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.Title = 'Analysing wind data with R' \nORDER BY c.CreationDate DESC \nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "hint": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN p.Score > 50 THEN 1 END) * 100.0 / COUNT(*)) AS Percentage\nFROM \n    posts p\nJOIN \n    users u ON p.OwnerUserId = u.Id\nWHERE \n    u.Reputation = (SELECT MAX(Reputation) FROM users);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "difficulty": "challenging"
    },
    {
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "hint": "in posts with 1 comment refers to CommentCount = 1;",
        "error_sql": "SELECT COUNT(*) \nFROM comments \nWHERE PostId IN (\n    SELECT Id \n    FROM posts \n    WHERE CommentCount = 1\n) AND Score = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "difficulty": "simple"
    },
    {
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "hint": "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));",
        "error_sql": "SELECT \n    (COUNT(DISTINCT c.UserId) * 100.0 / NULLIF(COUNT(DISTINCT c.UserId), 0)) AS Percentage\nFROM \n    comments c\nJOIN \n    users u ON c.UserId = u.Id\nWHERE \n    c.Score BETWEEN 5 AND 10 AND u.UpVotes = 0;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "difficulty": "moderate"
    },
    {
        "question": "Which are the cards that have incredibly powerful foils.",
        "hint": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "error_sql": "SELECT * FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What are the borderless cards available without powerful foils?",
        "hint": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
        "error_sql": "SELECT * FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "difficulty": "simple"
    },
    {
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "hint": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "error_sql": "SELECT DISTINCT cards.name\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE cards.rarity = 'mythic' AND legalities.status = 'Banned' AND legalities.format = 'gladiator';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "difficulty": "moderate"
    },
    {
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "hint": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
        "error_sql": "SELECT c.id, r.text, \n       CASE WHEN c.hasContentWarning = 1 THEN 'Missing or degraded properties' ELSE 'No issues' END AS properties_status\nFROM cards c\nLEFT JOIN rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniele';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "hint": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
        "error_sql": "SELECT c.name, c.artist, COUNT(r.uuid) as ruling_count, c.isPromo \nFROM cards c \nLEFT JOIN rulings r ON c.uuid = r.uuid \nGROUP BY c.uuid \nORDER BY ruling_count DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "hint": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
        "error_sql": "SELECT (SUM(CASE WHEN language = 'Chinese Simplified' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage \nFROM foreign_data;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "difficulty": "moderate"
    },
    {
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "hint": "Benalish Knight' is the name of card; rule of playing card refers to format;",
        "error_sql": "SELECT l.format, l.status \nFROM cards c \nJOIN legalities l ON c.uuid = l.uuid \nWHERE c.name = 'Benalish Knight';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "hint": "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
        "error_sql": "SELECT \n    (COUNT(fd.id) * 100.0 / (SELECT COUNT(id) FROM cards WHERE isStorySpotlight = 1)) AS percentage \nFROM \n    foreign_data fd \nJOIN \n    cards c ON fd.uuid = c.uuid \nWHERE \n    fd.language = 'French' AND c.isStorySpotlight = 1;",
        "compiler_hint": "no such column: language",
        "reflective_cot": "The initial error occurred because the `language` column is not present in the `cards` table; instead, it exists in the `foreign_data` table. The corrected SQL query accurately joins `foreign_data` with `cards` using the `uuid` field to filter for French-language Story Spotlight cards.\n\n**Tip to Avoid Similar Errors:**\nAlways check the data model relationships and table structures to ensure you reference the correct tables and columns. Use aliases for clarity and to prevent ambiguity, especially in joins.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "difficulty": "challenging"
    },
    {
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "hint": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
        "error_sql": "SELECT cards.name, foreign_data.language, foreign_data.text \nFROM cards \nJOIN foreign_data ON cards.uuid = foreign_data.uuid \nWHERE cards.originalType = 'Artifact' AND cards.colors = 'B';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "hint": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
        "error_sql": "SELECT \n    (SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage,\n    GROUP_CONCAT(id) AS ids\nFROM \n    cards;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isTextless = 0 AND  isStorySpotlight = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "difficulty": "moderate"
    },
    {
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "hint": "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'",
        "error_sql": "SELECT COUNT(*) \nFROM sets s \nJOIN set_translations st ON s.code = st.setCode \nWHERE s.block = 'Commander' AND st.language = 'Portuguese (Brasil)';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "difficulty": "moderate"
    },
    {
        "question": "How many unknown power cards contain info about the triggered ability",
        "hint": "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'",
        "error_sql": "SELECT COUNT(*) \nFROM cards \nWHERE (power IS NULL OR power = '*') AND text LIKE '%triggered ability%';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT Count(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "hint": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
        "error_sql": "SELECT fd.name \nFROM cards c \nJOIN foreign_data fd ON c.uuid = fd.uuid \nWHERE fd.language = 'French' \nAND c.type = 'Creature' \nAND c.layout = 'normal' \nAND c.borderColor = 'black' \nAND c.artist = 'Matthew D. Wilson';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "hint": "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(c.id)) AS percentage \nFROM \n    cards c \nJOIN \n    legalities l ON c.uuid = l.uuid \nWHERE \n    l.format = 'commander' AND l.status = 'legal';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of cards without power are in French?",
        "hint": "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; percentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100",
        "error_sql": "SELECT (COUNT(f.language) * 100.0 / COUNT(c.power)) AS percentage\nFROM cards c\nLEFT JOIN foreign_data f ON c.uuid = f.uuid\nWHERE (c.power IS NULL OR c.power = '*') AND f.language = 'French';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'",
        "difficulty": "challenging"
    },
    {
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "hint": "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
        "error_sql": "SELECT language FROM foreign_data WHERE uuid = (SELECT uuid FROM cards WHERE name = 'A Pedra Fellwar');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "difficulty": "simple"
    },
    {
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "hint": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater",
        "error_sql": "SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "hint": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
        "error_sql": "SELECT fd.*\nFROM cards c\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'Korean';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "difficulty": "moderate"
    },
    {
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "hint": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
        "error_sql": "SELECT COUNT(*) > 0 \nFROM cards \nJOIN sets ON cards.setCode = sets.code \nWHERE cards.name = 'Angel of Mercy' AND sets.mtgoCode IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "difficulty": "moderate"
    },
    {
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "hint": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
        "error_sql": "SELECT s.isForeignOnly \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nWHERE c.name = 'Adarkar Valkyrie';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "hint": "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'",
        "error_sql": "SELECT flavorText FROM foreign_data WHERE language = 'Italian' AND name = 'Ancestor''s Chosen';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
        "error_sql": "SELECT f.name \nFROM cards c \nJOIN sets s ON c.setCode = s.code \nJOIN foreign_data f ON c.uuid = f.uuid \nWHERE s.name = 'Coldsnap' AND f.language = 'Italian' \nAND c.convertedManaCost = (SELECT MAX(convertedManaCost) FROM cards WHERE setCode = s.code);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100",
        "error_sql": "SELECT (SUM(CASE WHEN cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_incredibly_powerful\nFROM cards\nWHERE name = 'Coldsnap';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "difficulty": "challenging"
    },
    {
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "hint": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
        "error_sql": "SELECT l.format, GROUP_CONCAT(c.name) AS banned_cards\nFROM legalities l\nJOIN cards c ON l.uuid = c.uuid\nWHERE l.status = 'Banned'\nGROUP BY l.format\nHAVING COUNT(l.status) = (\n    SELECT MAX(banned_count)\n    FROM (\n        SELECT COUNT(l.status) AS banned_count\n        FROM legalities l\n        WHERE l.status = 'Banned'\n        GROUP BY l.format\n    )\n)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "difficulty": "moderate"
    },
    {
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "hint": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
        "error_sql": "SELECT s.name \nFROM sets s \nLEFT JOIN set_translations st ON s.code = st.setCode \nWHERE st.language = 'Korean' \nAND s.code NOT IN (SELECT setCode FROM set_translations WHERE language LIKE '%Japanese%');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "difficulty": "moderate"
    },
    {
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "hint": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
        "error_sql": "SELECT DISTINCT frameVersion FROM cards WHERE artist = 'Allen Williams';  \nSELECT name FROM cards WHERE artist = 'Allen Williams';  \nSELECT * FROM legalities WHERE status = 'Banned';  ",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "The error occurred because SQL statements cannot be executed in multiple batches in many database systems. Each statement needs to be executed separately. \n\nIn the corrected SQL, the individual queries are separated for execution, ensuring each retrieves the necessary data without causing an error. \n\nTo avoid this mistake in the future, remember that when working with SQL, especially in environments that enforce single query execution, always execute one statement at a time. Consider using a script or tool that allows batch execution if you need to run multiple related queries.",
        "ground_truth_sql": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "hint": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
        "error_sql": "SELECT AVG(oxygen_count) FROM (\n    SELECT m.molecule_id, COUNT(a.atom_id) AS oxygen_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id AND b.bond_type = '-'\n    JOIN connected c ON b.bond_id = c.bond_id\n    JOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id\n    WHERE a.element = 'o'\n    GROUP BY m.molecule_id\n) AS subquery;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "difficulty": "moderate"
    },
    {
        "question": "On average how many carcinogenic molecules are single bonded?",
        "hint": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
        "error_sql": "SELECT AVG(single_bond_count) AS average_single_bonded_carcinogenic \nFROM (\n    SELECT COUNT(c.atom_id) AS single_bond_count\n    FROM molecule m\n    JOIN bond b ON m.molecule_id = b.molecule_id AND b.bond_type = '-'\n    JOIN connected c ON b.bond_id = c.bond_id\n    WHERE m.label = '+'\n    GROUP BY m.molecule_id\n);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "difficulty": "challenging"
    },
    {
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "hint": "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'",
        "error_sql": "SELECT DISTINCT m.molecule_id, m.label \nFROM molecule m \nJOIN bond b ON m.molecule_id = b.molecule_id \nWHERE b.bond_type = '#' AND m.label = '+';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of carbon in double-bond molecules?",
        "hint": "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
        "error_sql": "SELECT (SUM(CASE WHEN a.element = 'c' THEN 1 ELSE 0 END) * 1.0 / COUNT(a.atom_id)) * 100 AS carbon_percentage\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = '=' \nGROUP BY b.molecule_id;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "difficulty": "moderate"
    },
    {
        "question": "What elements are in a double type bond?",
        "hint": "double type bond refers to bond_type = '=';",
        "error_sql": "SELECT DISTINCT a.element \nFROM bond b \nJOIN connected c ON b.bond_id = c.bond_id \nJOIN atom a ON c.atom_id = a.atom_id \nWHERE b.bond_type = '=';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "difficulty": "challenging"
    },
    {
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "hint": "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); ",
        "error_sql": "SELECT label, COUNT(label) as label_count \nFROM atom \nJOIN molecule ON atom.molecule_id = molecule.molecule_id \nWHERE element = 'h' \nGROUP BY label \nORDER BY label_count DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "difficulty": "moderate"
    },
    {
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "hint": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT COUNT(DISTINCT a.atom_id) AS distinct_atoms_count\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (a.element = 'i' OR a.element = 's') AND b.bond_type = '-';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "hint": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT \n    (100.0 * (COUNT(DISTINCT m.molecule_id) - SUM(CASE WHEN a.element = 'f' THEN 1 ELSE 0 END)) / COUNT(DISTINCT m.molecule_id)) AS percentage_not_containing_fluorine\nFROM \n    molecule m\nLEFT JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "hint": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
        "error_sql": "SELECT (SUM(bond.bond_type = '#') * 100.0 / COUNT(bond.bond_id)) AS percent\nFROM molecule\nJOIN bond ON molecule.molecule_id = bond.molecule_id\nWHERE molecule.label = '+';",
        "compiler_hint": "no such function: DIVIDE",
        "reflective_cot": "The error in the original SQL query stemmed from the use of the non-existent `DIVIDE` function, which is not a standard SQL function. The corrected SQL accurately replaces `DIVIDE` with an arithmetic expression that calculates the percentage by using division directly in the SELECT clause.\n\nTo avoid such mistakes in the future, it is essential to understand and review the SQL functions and syntax available for the specific database management system (DBMS) being used. Always refer to the official documentation or resources to confirm function availability and syntax before implementing them in your queries.",
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "difficulty": "challenging"
    },
    {
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "hint": "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); ",
        "error_sql": "SELECT bond_type \nFROM bond \nWHERE molecule_id = 'TR010' \nGROUP BY bond_type \nORDER BY COUNT(*) DESC \nLIMIT 1;\n\nSELECT CASE \n    WHEN EXISTS (\n        SELECT 1 \n        FROM molecule \n        WHERE molecule_id = 'TR010' AND label LIKE '%carcinogenic%'\n    ) THEN 'Yes' \n    ELSE 'No' \nEND as is_carcinogenic;",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "The initial error occurred because two separate SQL statements were attempted to be executed at once, which is not allowed in many database systems. Each statement must be executed independently.\n\nThe corrected SQL split the queries to address each question separately: the first query retrieves the bond type with the maximum count for the specified molecule, and the second verifies if the molecule is carcinogenic.\n\n### Tip:\nTo avoid such errors in the future, always ensure that you separate queries into distinct execution blocks when working with SQL. Maintain clarity by running one query at a time, especially when checking for conditions or aggregating data.",
        "ground_truth_sql": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "difficulty": "challenging"
    },
    {
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "hint": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
        "error_sql": "SELECT COUNT(*) \nFROM connected \nWHERE (atom_id = 'TR009_12' OR atom_id2 = 'TR009_12') \nAND bond_id IN (SELECT bond_id FROM bond WHERE molecule_id = 'TR009');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' OR T2.atom_id2 = T1.molecule_id || '_2'",
        "difficulty": "moderate"
    },
    {
        "question": "How many connections does the atom 19 have?",
        "hint": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
        "error_sql": "SELECT COUNT(bond_id) AS connections FROM connected WHERE atom_id = 'TR%_19' OR atom_id2 = 'TR%_19';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "difficulty": "simple"
    },
    {
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "hint": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT m.molecule_id, m.label, COUNT(b.bond_id) AS double_bond_count\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = ' = '\nGROUP BY m.molecule_id\nORDER BY double_bond_count DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "difficulty": "moderate"
    },
    {
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "hint": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
        "error_sql": "SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "difficulty": "challenging"
    },
    {
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "hint": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
        "error_sql": "SELECT \n    (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percent \nFROM \n    atom a \nJOIN \n    connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 \nJOIN \n    bond b ON c.bond_id = b.bond_id \nWHERE \n    b.bond_type = '-'\nGROUP BY \n    b.molecule_id;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "hint": "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'",
        "error_sql": "SELECT \n    (SUM(a.element = 'cl') * 100.0) / COUNT(DISTINCT m.molecule_id) AS percentage\nFROM \n    molecule m\nJOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "hint": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
        "error_sql": "SELECT a.element \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nWHERE m.label = '+' AND substr(a.atom_id, 7, 1) = '4';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "difficulty": "challenging"
    },
    {
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "hint": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "error_sql": "SELECT label, \n       CAST(SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(element) AS hydrogen_ratio \nFROM atom \nJOIN molecule ON atom.molecule_id = molecule.molecule_id \nWHERE molecule.molecule_id = 'TR006' \nGROUP BY label;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "difficulty": "challenging"
    },
    {
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "hint": "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
        "error_sql": "SELECT m.molecule_id, m.label, COUNT(a.atom_id) AS atom_count\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = '-'\nGROUP BY m.molecule_id\nHAVING COUNT(a.atom_id) > 5;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "hint": "Total enrollment can be represented by `Enrollment (K-12)` + `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT frpm.CDSCode \nFROM frpm \nWHERE (`Enrollment (K-12)` + `Enrollment (Ages 5-17)`) > 500;",
        "compiler_hint": "near \"5\": syntax error",
        "reflective_cot": "### Reflection on the Error:\nThe original SQL query failed due to incorrect syntax for referencing column names with spaces and special characters. In SQL, column names that include spaces or special characters need to be enclosed in backticks (`` ` ``) or double quotes (depending on the SQL dialect) to ensure they are interpreted correctly. \n\n### Corrected SQL:\nThe corrected SQL successfully uses backticks around the column names to avoid syntax errors:\n\n```sql\nSELECT frpm.CDSCode \nFROM frpm \nWHERE (`Enrollment (K-12)` + `Enrollment (Ages 5-17)`) > 500;\n```\n\n### Tip to Avoid Future Mistakes:\nAlways use backticks (or appropriate delimiters for your SQL dialect) for column names with spaces or special characters. Additionally, consider using simpler naming conventions for columns when possible to improve code readability and reduce syntax issues.",
        "ground_truth_sql": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "difficulty": "simple"
    },
    {
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "hint": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT MAX(`Percent (%) Eligible Free (Ages 5-17)`)\nFROM (\n    SELECT fr.CDSCode, \n           (CAST(ss.NumGE1500 AS REAL) / ss.NumTstTakr) AS ExcellenceRate,\n           (fr.`Free Meal Count (Ages 5-17)` / fr.`Enrollment (Ages 5-17)`) AS EligibleFreeRate\n    FROM satscores ss\n    JOIN frpm fr ON ss.cds = fr.CDSCode\n    WHERE (CAST(ss.NumGE1500 AS REAL) / ss.NumTstTakr) > 0.3\n) AS SubQuery;",
        "compiler_hint": "no such column: s.cds",
        "reflective_cot": "### Reflection on the Error\n\nThe original SQL query encountered an error because it referenced the alias `s` for the `satscores` table, which was not defined in the `FROM` clause. Instead, the right alias was `ss`. This caused the SQL engine to fail in locating the `cds` column.\n\n### Corrected SQL Explanation\n\nIn the corrected SQL, the alias `fr` for `frpm` and `ss` for `satscores` were used properly, and the necessary fields were explicitly selected from the appropriate aliases. \n\n### Tip to Avoid Future Mistakes\n\nAlways ensure that you use the correct table aliases defined in the `FROM` clause when referencing columns in your queries. Keeping consistent naming and being mindful of scope will help prevent such errors.",
        "ground_truth_sql": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "difficulty": "moderate"
    },
    {
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "hint": "Valid charter number means the number is not null",
        "error_sql": "SELECT s.CharterNum, AVG(sa.AvgScrWrite) AS AvgWritingScore\nFROM satscores sa\nJOIN schools s ON sa.cds = s.CDSCode\nWHERE sa.AvgScrWrite > 499 AND s.CharterNum IS NOT NULL\nGROUP BY s.CharterNum\nORDER BY AvgWritingScore DESC;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "difficulty": "simple"
    },
    {
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "hint": "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT s.School, s.Street, s.City, s.Zip\nFROM frpm f\nJOIN schools s ON f.CDSCode = s.CDSCode\nWHERE ABS(f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > 30;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "difficulty": "moderate"
    },
    {
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "hint": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
        "error_sql": "SELECT s.\"School Name\" \nFROM frpm AS f \nJOIN satscores AS s ON f.CDSCode = s.cds \nWHERE (f.\"Free Meal Count (K-12)\" / f.\"Enrollment (K-12)\") > 0.1 \nAND s.NumTstTakr > 0 \nAND (s.AvgScrRead + s.AvgScrMath + s.AvgScrWrite) >= 1500;",
        "compiler_hint": "near \"Meal\": syntax error",
        "reflective_cot": "The error in the original SQL query was due to the use of spaces in the column names (e.g., `School Name`, `Free Meal Count (K-12)`). In SQL, when column names contain spaces or special characters, they must be enclosed in quotes, such as double quotes (`\"`) or backticks (`` ` ``), depending on the SQL dialect. \n\nThe corrected SQL query properly enclosed the column names with spaces in double quotes, resolving the syntax error. \n\n**Tip to Avoid Future Mistakes:** Always check if your column names contain spaces or special characters and enclose them accordingly in quotes to prevent syntax errors in SQL queries. Consider adopting a consistent naming convention that avoids spaces, such as using underscores (e.g., `school_name`, `free_meal_count_k12`) to simplify query writing.",
        "ground_truth_sql": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "difficulty": "moderate"
    },
    {
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "hint": "Average of average math = sum(average math scores) / count(schools).",
        "error_sql": "SELECT s.School, s.FundingType\nFROM schools s\nJOIN satscores sat ON s.CDSCode = sat.cds\nWHERE s.County = 'Riverside'\nGROUP BY s.CDSCode\nHAVING AVG(sat.AvgScrMath) > 400;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "difficulty": "moderate"
    },
    {
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "hint": "Full communication address should include Street, City, State and zip code if any.",
        "error_sql": "SELECT s.School, s.Street, s.City, s.State, s.Zip \nFROM frpm f \nJOIN schools s ON f.CDSCode = s.CDSCode \nWHERE f.`County Name` = 'Monterey' \nAND f.`Free Meal Count (Ages 5-17)` > 800 \nAND s.StatusType = 'High School';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "hint": "Communication number refers to phone number.",
        "error_sql": "SELECT s.School, AVG(sa.AvgScrWrite) AS Average_Writing_Score, s.Phone\nFROM schools s\nJOIN satscores sa ON s.CDSCode = sa.cds\nWHERE (s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01')\nGROUP BY s.School, s.Phone;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "difficulty": "moderate"
    },
    {
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "hint": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT s.School AS SchoolName, s.DOCType \nFROM schools s \nJOIN frpm f ON s.CDSCode = f.CDSCode \nWHERE f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)` > \n    (SELECT AVG(f1.`Enrollment (K-12)` - f1.`Enrollment (Ages 5-17)`) \n     FROM frpm f1 \n     WHERE f1.`NSLP Provision Status` = 'Locally Funded');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "difficulty": "challenging"
    },
    {
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "hint": "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT \n    `School Name`, \n    (`Free Meal Count (K-12)` / `Enrollment (K-12)`) AS EligibleFreeRate \nFROM \n    frpm \nWHERE \n    `Enrollment (K-12)` > 0 \nORDER BY \n    `Enrollment (K-12)` DESC \nLIMIT 2 OFFSET 9;",
        "compiler_hint": "no such column: SchoolName",
        "reflective_cot": "The initial error in the SQL query was due to referencing the column as `SchoolName`, which does not exist in the `frpm` table. The corrected query properly uses the correct column name `School Name`. \n\nTo avoid such mistakes in the future, always verify the column names as defined in the database schema before writing your queries. Double-checking the schema for exact naming can prevent typographical errors. Additionally, using an IDE or SQL client that supports auto-completion can help in selecting the correct column names easily.",
        "ground_truth_sql": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "difficulty": "moderate"
    },
    {
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "hint": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT \n    f.`School Name`, \n    (f.`FRPM Count (K-12)` / f.`Enrollment (K-12)`) AS Eligible_Rate \nFROM \n    frpm f \nJOIN \n    schools s ON f.CDSCode = s.CDSCode \nWHERE \n    s.Charter = 66 \n    AND f.`Enrollment (K-12)` > 0 \nORDER BY \n    f.`FRPM Count (K-12)` DESC \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "hint": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
        "error_sql": "SELECT s.Street, s.City, s.Zip, s.State \nFROM satscores sa \nJOIN schools s ON sa.cds = s.CDSCode \nWHERE sa.NumTstTakr > 0 \nORDER BY (sa.NumGE1500 * 1.0 / sa.NumTstTakr) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "hint": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
        "error_sql": "SELECT s.AdmFName1 || ' ' || s.AdmLName1 AS FullName\nFROM satscores ss\nJOIN schools s ON ss.cds = s.CDSCode\nWHERE ss.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores)\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "hint": "Fresno Unified is a name of district;",
        "error_sql": "SELECT s.Phone \nFROM satscores sa \nJOIN schools s ON sa.cds = s.CDSCode \nWHERE s.District = 'Fresno Unified' \nORDER BY sa.AvgScrRead ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "hint": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
        "error_sql": "SELECT s.School, s.County \nFROM schools s\nJOIN satscores sa ON s.CDSCode = sa.cds\nWHERE s.Virtual = 'F' \nGROUP BY s.County \nORDER BY AVG(sa.AvgScrRead) DESC \nLIMIT 5;",
        "compiler_hint": "near \"GROUP\": syntax error",
        "reflective_cot": "The original SQL query had an incorrect order of clauses, attempting to use `LIMIT` before `GROUP BY`, which caused a syntax error. The corrected query properly groups the results by county before ordering and limiting the results. \n\nKey points to note for avoiding similar mistakes:\n1. **Understanding SQL Clause Order**: Remember the proper order of SQL clauses: `SELECT`, `FROM`, `JOIN`, `WHERE`, `GROUP BY`, `ORDER BY`, and then `LIMIT`.\n2. **Use of Aggregate Functions**: When using `GROUP BY`, ensure to apply aggregate functions like `AVG()` to make sense of the grouped data before filtering with `ORDER BY`.\n\nTip: Always check the sequence of clause execution in SQL, and revise the syntax as necessary to ensure logical flow and adherence to SQL standards.",
        "ground_truth_sql": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "difficulty": "simple"
    },
    {
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "hint": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
        "error_sql": "SELECT s.School, SUM(f.`Enrollment (K-12)`) AS TotalEnrollees\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.DOC = 31\nGROUP BY s.School\nORDER BY TotalEnrollees DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "hint": "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12",
        "error_sql": "SELECT COUNT(*) / 12 AS MonthlyAverageOpenedSchools \nFROM schools \nWHERE County = 'Alameda' \n  AND DOC = '52' \n  AND strftime('%Y', OpenDate) = '1980';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "hint": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
        "error_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE County = 'Orange' AND DOC = '54') * 1.0 / \n    (SELECT COUNT(*) FROM schools WHERE County = 'Orange' AND DOC = '52') AS Ratio;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "difficulty": "moderate"
    },
    {
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "hint": "State Special School means EdOpsCode = 'SSS'",
        "error_sql": "SELECT `Enrollment (Ages 5-17)` \nFROM frpm \nJOIN schools ON frpm.CDSCode = schools.CDSCode \nWHERE schools.EdOpsCode = 'SSS' \nAND frpm.`Academic Year` = '2014-2015' \nAND frpm.`County Name` = 'Fremont';",
        "compiler_hint": "near \"Name\": syntax error",
        "reflective_cot": "The error in the original SQL query was due to the use of the column name `County Name` without proper escaping, resulting in a syntax error. The space in the column name requires it to be enclosed in backticks, which was correctly done in the corrected SQL query.\n\n### Tip:\nWhen working with column names that contain spaces or special characters, always enclose them in backticks (`) or double quotes (\") to avoid syntax errors. This practice will help prevent similar issues in future queries.",
        "ground_truth_sql": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "difficulty": "moderate"
    },
    {
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "hint": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
        "error_sql": "SELECT s.School AS SchoolName, (f.`FRPM Count (Ages 5-17)` / f.`Enrollment (Ages 5-17)` * 100) AS `Percent Eligible FRPM (Ages 5-17)` \nFROM frpm f \nJOIN schools s ON f.CDSCode = s.CDSCode \nWHERE f.`Low Grade` = 'K' AND f.`High Grade` = '9' AND s.County = 'Los Angeles';",
        "compiler_hint": "no such column: s.SchoolName",
        "reflective_cot": "The error in the original SQL query occurred because the column name `SchoolName` was incorrectly referenced from the `schools` table, which does not contain that exact column name. Instead, the correct column name is `School`. \n\nIn the corrected SQL query, I replaced `s.SchoolName` with `s.School`, accurately reflecting the database schema. This highlights the importance of careful attention to column names and their exact spelling as defined in the database schema when writing SQL queries.\n\n**Tip:** Always refer to the database schema when specific columns are needed, and double-check for typos or mismatches between the query and the schema. This practice can help prevent such errors in the future.",
        "ground_truth_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the grade span offered in the school with the highest longitude?",
        "hint": "the highest longitude refers to the school with the maximum absolute longitude value.",
        "error_sql": "SELECT `Low Grade`, `High Grade` \nFROM schools \nORDER BY ABS(Longitude) DESC \nLIMIT 1;",
        "compiler_hint": "no such column: Low Grade",
        "reflective_cot": "The error encountered was due to referencing the columns `Low Grade` and `High Grade` in the `schools` table, while these columns actually exist in the `frpm` table. As a result, the correct query should join the `schools` and `frpm` tables to access the grade span information.\n\nTo correct the SQL, you need to first select the school with the highest absolute longitude from the `schools` table and then retrieve the corresponding grade span from the `frpm` table using a join.\n\n### Correct SQL Query:\n```sql\nSELECT frpm.`Low Grade`, frpm.`High Grade`\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nORDER BY ABS(schools.Longitude) DESC\nLIMIT 1;\n```\n\n### Tip to Avoid Future Mistakes:\nAlways ensure you are referencing the correct table when querying columns. Familiarize yourself with the schema, and consider using explicit table aliases or prefixes to avoid ambiguity.",
        "ground_truth_sql": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "hint": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
        "error_sql": "SELECT COUNT(*) AS MultipleProvisionMagnetSchools\nFROM frpm \nJOIN schools ON frpm.CDSCode = schools.CDSCode \nWHERE frpm.`Low Grade` = 'K' \nAND frpm.`High Grade` = '8' \nAND frpm.`NSLP Provision Status` = 'Multiple Provision Types' \nAND schools.Magnet = 1;\n\nSELECT City, COUNT(*) AS SchoolsCount\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE frpm.`Low Grade` = 'K' \nAND frpm.`High Grade` = '8'\nGROUP BY City;",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "### Reflection on the Error\n\nThe original error occurred because SQL typically allows only one statement to be executed at a time unless wrapped in a transaction or combined using a Common Table Expression (CTE). In this case, two separate `SELECT` statements were attempted, leading to the error.\n\n### Corrected SQL\n\nTo improve the corrected SQL, it can be beneficial to combine the two queries into one using a CTE or a subquery, which will simplify execution by consolidating the logic.\n\n```sql\nWITH MultipleProvisionMagnetSchools AS (\n    SELECT COUNT(*) AS Count\n    FROM frpm \n    JOIN schools ON frpm.CDSCode = schools.CDSCode \n    WHERE frpm.`Low Grade` = 'K' \n    AND frpm.`High Grade` = '8' \n    AND frpm.`NSLP Provision Status` = 'Multiple Provision Types' \n    AND schools.Magnet = 1\n),\nCitySchools AS (\n    SELECT City, COUNT(*) AS SchoolsCount\n    FROM schools\n    JOIN frpm ON schools.CDSCode = frpm.CDSCode\n    WHERE frpm.`Low Grade` = 'K' \n    AND frpm.`High Grade` = '8'\n    GROUP BY City\n)\nSELECT \n    (SELECT Count FROM MultipleProvisionMagnetSchools) AS MultipleProvisionMagnetSchools,\n    City,\n    SchoolsCount\nFROM CitySchools;\n```\n\n### Tip\n\nTo avoid such errors in the future, always check whether your SQL dialect allows multiple `SELECT` statements at once. If in doubt, combine queries using CTEs, subqueries, or UNION operators, which can streamline execution and reduce errors.",
        "ground_truth_sql": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "difficulty": "challenging"
    },
    {
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "hint": "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
        "error_sql": "SELECT `District Code`, (`Free Meal Count (K-12)` / `Enrollment (K-12)` * 100) AS `Percent (%) Eligible Free (K-12)`\nFROM frpm\nJOIN schools ON frpm.CDSCode = schools.CDSCode\nWHERE AdmFName1 = 'Alusine';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "difficulty": "moderate"
    },
    {
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "hint": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
        "error_sql": "SELECT AdmEmail1, AdmEmail2, AdmEmail3 \nFROM schools \nWHERE County = 'San Bernardino' \n  AND District = 'San Bernardino City Unified' \n  AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' \n  AND (SOC = '62' OR DOC = '54');",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "difficulty": "challenging"
    },
    {
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "hint": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
        "error_sql": "SELECT COUNT(DISTINCT a.account_id) \nFROM account a \nJOIN disp d ON a.account_id = d.account_id \nJOIN district ds ON a.district_id = ds.district_id \nWHERE ds.A3 = 'East Bohemia' AND d.type = 'POPLATEK PO OBRATU';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "difficulty": "moderate"
    },
    {
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "hint": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
        "error_sql": "SELECT COUNT(*) \nFROM client \nJOIN district ON client.district_id = district.district_id \nWHERE client.gender = 'M' \nAND district.A3 = 'North Bohemia' \nAND district.A11 > 8000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "difficulty": "moderate"
    },
    {
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "hint": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
        "error_sql": "SELECT \n    a.account_id,\n    MAX(d.A11) - MIN(d.A11) AS salary_gap\nFROM \n    client c\nJOIN \n    district d ON c.district_id = d.district_id\nJOIN \n    disp disp ON c.client_id = disp.client_id\nJOIN \n    account a ON disp.account_id = a.account_id\nWHERE \n    c.gender = 'F'\nGROUP BY \n    a.account_id\nHAVING \n    c.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F')\nORDER BY \n    d.A11 ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "hint": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
        "error_sql": "SELECT a.account_id\nFROM account a\nJOIN client c ON a.district_id = c.district_id\nJOIN district d ON c.district_id = d.district_id\nWHERE c.birth_date = (\n    SELECT MIN(birth_date)\n    FROM client\n)\nAND d.A11 = (\n    SELECT MAX(A11)\n    FROM district\n);",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "difficulty": "moderate"
    },
    {
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "hint": "'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT a.account_id, l.amount \nFROM loan l \nJOIN account a ON l.account_id = a.account_id \nWHERE l.date BETWEEN '1997-01-01' AND '1997-12-31' \nAND a.frequency = 'POPLATEK TYDNE' \nORDER BY l.amount ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "hint": "Loan validity more than 12 months refers to duration > 12",
        "error_sql": "SELECT a.account_id, l.amount\nFROM account a\nJOIN loan l ON a.account_id = l.account_id\nWHERE l.duration > 12 AND a.date LIKE '1993%'\nORDER BY l.amount DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "hint": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(c.client_id)) AS male_percentage\nFROM \n    client c\nJOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A3 = 'South Bohemia'\nGROUP BY \n    d.A4\nORDER BY \n    SUM(d.A4) DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "hint": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
        "error_sql": "SELECT \n    (end_balance.balance - start_balance.balance) * 100.0 / start_balance.balance AS increase_rate \nFROM \n    (SELECT \n         acc.account_id, t.balance \n     FROM \n         account acc \n     JOIN \n         loan l ON acc.account_id = l.account_id \n     JOIN \n         disp d ON l.account_id = d.account_id \n     JOIN \n         trans t ON acc.account_id = t.account_id \n     WHERE \n         l.date = (SELECT MIN(date) FROM loan WHERE date >= '1993-07-05') \n         AND l.status = 'approved' \n         AND t.date = '1993-03-22') AS start_balance,\n    (SELECT \n         t.balance \n     FROM \n         trans t \n     WHERE \n         t.account_id = (SELECT acc.account_id \n                         FROM loan l \n                         JOIN account acc ON l.account_id = acc.account_id \n                         WHERE l.date = (SELECT MIN(date) FROM loan WHERE date >= '1993-07-05')) \n         AND t.date = '1998-12-27') AS end_balance;",
        "compiler_hint": "no such column: a.balance",
        "reflective_cot": "### Reflection on Error:\nIn the initial query, the error \"no such column: a.balance\" occurred because of a reference to a nonexistent column alias \"a\" in the subquery, rather than correctly referencing columns from the selected tables. In the corrected SQL, I ensured that I properly selected and referenced the `balance` column from the `trans` table.\n\n### Tip to Avoid Such Mistakes:\nAlways double-check the aliases and the tables from which you're selecting data. Clearly organize your queries and keep the naming consistent. When using subqueries, ensure that you're accessing the right columns with the correct aliases.",
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "hint": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
        "error_sql": "SELECT \n    (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) / SUM(amount)) * 100 AS percentage_of_fully_paid_loans\nFROM loan;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "difficulty": "moderate"
    },
    {
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "hint": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
        "error_sql": "SELECT d.district_id, ( (d.A13 - d.A12) / d.A12 ) * 100 AS unemployment_increment_rate\nFROM loan l\nJOIN account a ON l.account_id = a.account_id\nJOIN client c ON a.district_id = c.district_id\nJOIN district d ON c.district_id = d.district_id\nWHERE l.status = 'D';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "difficulty": "challenging"
    },
    {
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "hint": "Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
        "error_sql": "SELECT COUNT(DISTINCT l.account_id) \nFROM loan l \nJOIN account a ON l.account_id = a.account_id \nWHERE l.date BETWEEN '1995-01-01' AND '1997-12-31' \nAND l.amount >= 250000 \nAND a.frequency = 'POPLATEK MESICNE' \nAND l.status = 'approved';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "difficulty": "moderate"
    },
    {
        "question": "How many accounts have running contracts in Branch location 1?",
        "hint": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "error_sql": "SELECT COUNT(DISTINCT a.account_id) \nFROM account a \nJOIN loan l ON a.account_id = l.account_id \nJOIN disp d ON a.account_id = d.account_id \nWHERE l.status IN ('C', 'D') \nAND d.type = '1';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "difficulty": "moderate"
    },
    {
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "hint": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
        "error_sql": "SELECT d.A2 AS district_name, SUM(t.amount) AS total_withdrawals\nFROM trans t\nJOIN account a ON t.account_id = a.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'VYDAJ' AND t.date LIKE '1996-01%'\nGROUP BY d.A2\nORDER BY total_withdrawals DESC\nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "hint": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
        "error_sql": "SELECT DISTINCT c.client_id\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nJOIN client c ON d.client_id = c.client_id\nWHERE t.operation = 'VYBER KARTOU'\n  AND t.amount < (SELECT AVG(amount)\n                  FROM trans\n                  WHERE operation = 'VYBER KARTOU' AND date BETWEEN '1998-01-01' AND '1998-12-31')\n  AND t.date BETWEEN '1998-01-01' AND '1998-12-31';",
        "compiler_hint": "no such column: ca.account_id",
        "reflective_cot": "The error encountered in the initial SQL query was due to the incorrect assumption that the `card` table had a direct relationship with the `trans` table via an `account_id` field, which does not exist in the `card` table. The corrected SQL removed the `card` table from the join and instead linked `trans` directly to the `disp` table, which connects to the `client`.\n\n**Reasoning for Correction**: By focusing on the actual relationships defined in the database schema, including foreign keys, the corrected query was able to accurately access the necessary data. The `account_id` was correctly sourced from the `disp` table instead of incorrectly attempting to access it from the `card` table.\n\n**Tip to Avoid Similar Mistakes**: Always carefully review the database schema to understand the relationships between tables. Ensure that any joins you perform are based on valid foreign key constraints and that the columns you're accessing exist in the respective tables.",
        "ground_truth_sql": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "hint": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
        "error_sql": "SELECT DISTINCT a.frequency \nFROM account a \nJOIN district d ON a.district_id = d.district_id \nWHERE d.A11 > 8000 AND d.A11 <= 9000 AND a.frequency != 'OWNER';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "difficulty": "challenging"
    },
    {
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "hint": "operation = 'VYBER' refers to withdrawal in cash",
        "error_sql": "SELECT t.*\nFROM trans t\nJOIN disp d ON t.account_id = d.account_id\nWHERE d.client_id = 3356 AND t.operation = 'VYBER';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "difficulty": "simple"
    },
    {
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "hint": "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
        "error_sql": "SELECT (COUNT(CASE WHEN c.gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM client c \nJOIN district d ON c.district_id = d.district_id\nJOIN account a ON c.district_id = a.district_id\nWHERE d.A11 > 10000;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "difficulty": "moderate"
    },
    {
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "hint": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
        "error_sql": "SELECT \n    (SUM(CASE WHEN strftime('%Y', l.date) = '1997' THEN l.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END)) / NULLIF(SUM(CASE WHEN strftime('%Y', l.date) = '1996' THEN l.amount ELSE 0 END), 0) * 100 AS growth_rate\nFROM \n    loan l\nJOIN \n    account a ON l.account_id = a.account_id\nJOIN \n    disp d ON a.account_id = d.account_id\nJOIN \n    client c ON d.client_id = c.client_id\nWHERE \n    c.gender = 'M';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "difficulty": "challenging"
    },
    {
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "hint": "k_symbol refers to the purpose of payments",
        "error_sql": "SELECT frequency, \n       SUM(CASE WHEN k_symbol IS NOT NULL THEN amount ELSE 0 END) AS total_debited,\n       GROUP_CONCAT(DISTINCT k_symbol) AS k_symbols\nFROM account \nJOIN trans ON account.account_id = trans.account_id \nWHERE account.account_id = 3\nGROUP BY frequency;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "hint": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT \n    (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_weekly_statements\nFROM \n    client c\nJOIN \n    account a ON c.district_id = a.district_id\nWHERE \n    a.frequency = 'POPLATEK TYDNE';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "hint": "Female refers to 'F' in the gender; A11 contains information about average salary",
        "error_sql": "SELECT a.account_id \nFROM account a \nJOIN client c ON a.district_id = c.district_id \nJOIN district d ON c.district_id = d.district_id \nWHERE c.gender = 'F' \nORDER BY c.birth_date ASC, d.A11 ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "hint": "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "error_sql": "SELECT AVG(l.amount) AS average_loan_amount\nFROM loan l\nJOIN trans t ON l.account_id = t.account_id\nWHERE l.status IN ('C', 'D') \nAND t.operation = 'POPLATEK PO OBRATU';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "hint": "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
        "error_sql": "SELECT c.client_id, (strftime('%Y', 'now') - strftime('%Y', c.birth_date)) AS age\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN card ca ON d.account_id = ca.card_id\nWHERE ca.type = 'gold' AND d.type = 'OWNER';",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "difficulty": "moderate"
    }
]