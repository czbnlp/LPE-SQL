[
    {
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT T1.Date FROM yearmonth AS T1 WHERE T1.Date LIKE (SELECT SUBSTR(T2.Date, 1, 4) FROM yearmonth AS T2 GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1) GROUP BY SUBSTR(T1.Date, 1, 4) ORDER BY SUM(T1.Consumption) DESC LIMIT 1",
        "compiler_hint": "no such column: Currency",
        "reflective_cot": "The error in the original SQL query was caused by referencing a non-existent column (Currency) in the table yearmonth. The column Currency is in the customers table, not in the yearmonth table. To avoid such mistakes in the future, always double-check the schema of the database and ensure that the columns you are referencing in your SQL queries actually exist in the tables you are querying. A concise tip is to review the schema documentation or use the database's metadata functions (like PRAGMA table_info in SQLite) to list the columns of a table before writing your SQL query. This can help prevent referencing non-existent columns and reduce errors in your SQL statements.",
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "hint": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT T2.Date FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' GROUP BY SUBSTR(T2.Date, 6, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "hint": "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) - ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) AS SME_LAM_DIFF , ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) - ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) AS LAM_KAM_DIFF , ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) - ( SELECT SUM(T2.Consumption) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' AND T1.Currency = 'CZK' ) ) AS KAM_SME_DIFF",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "difficulty": "challenging"
    },
    {
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "hint": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
        "error_sql": "SELECT T1.Segment , CAST(SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%', T2.Consumption, 0)) AS REAL) * 100 / SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY CAST(SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%', T2.Consumption, 0)) AS REAL) * 100 / SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) DESC LIMIT 1 UNION ALL SELECT T1.Segment , CAST(SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%', T2.Consumption, 0)) AS REAL) * 100 / SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY CAST(SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%', T2.Consumption, 0)) AS REAL) * 100 / SUM(IIF(T2.Date LIKE '2013%', T2.Consumption, 0)) ASC LIMIT 1",
        "compiler_hint": "ORDER BY clause should come after UNION not before",
        "reflective_cot": "The error in the original SQL query was placing the ORDER BY clause before the UNION operator, which is incorrect. The ORDER BY clause should always come after the UNION operator when sorting the results of combined SELECT statements. To avoid this mistake in the future, remember that the ORDER BY clause should be the last clause in your SQL query, after all other operations like JOINs, WHERE conditions, and UNIONs. This ensures that all data manipulations are completed before sorting the final result. A concise tip is to always write the ORDER BY clause last in your query to prevent such errors.",
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "difficulty": "challenging"
    },
    {
        "question": "What is the highest monthly consumption in the year 2012?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT MAX(T1.Consumption) FROM yearmonth AS T1 WHERE SUBSTR(T1.Date, 1, 4) = '2012'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "hint": "Pays in euro = Currency = 'EUR'.",
        "error_sql": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' AND T2.Consumption > 1000 GROUP BY T1.CustomerID",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "difficulty": "simple"
    },
    {
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "hint": "",
        "error_sql": "SELECT DISTINCT T1.Date FROM yearmonth AS T1 JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID JOIN gasstations AS T3 ON T2.GasStationID = T3.GasStationID WHERE T3.ChainID = 11",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
        "difficulty": "simple"
    },
    {
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'",
        "error_sql": "SELECT T1.Currency FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '2012-08-24' AND T2.Consumption = 548.4",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price  = 548.4",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "hint": "'2012/8/25' can be represented by '2012-08-25'",
        "error_sql": "SELECT CAST(SUM(IIF(T2.Date = '2012-08-25', 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "difficulty": "simple"
    },
    {
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
        "error_sql": "SELECT CAST((T1.Consumption - T2.Consumption) AS REAL) / T1.Consumption FROM (SELECT Consumption FROM yearmonth WHERE Date = '2012-08-25' AND CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Price * Amount = 634.8)) AS T1, (SELECT Consumption FROM yearmonth WHERE Date = '2013-08-25' AND CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Price * Amount = 634.8)) AS T2",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price  = 1513.12 )",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "hint": "",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.Segment='premium' THEN 1 ELSE 0 END) AS REAL)*100 / COUNT(T2.Segment) FROM `transactions_1k` AS T2 INNER JOIN gasstations AS T1 ON T1.GasStationID=T2.GasStationID WHERE T1.Country='SVK'",
        "compiler_hint": "no such column: T2.Segment",
        "reflective_cot": "The error in the original SQL query was due to referencing the 'Segment' column with the prefix 'T2', which does not exist in the 'transactions_1k' table. The 'Segment' column is actually in the 'gasstations' table, so it should be referenced with 'T1' instead of 'T2'. To avoid such mistakes in the future, always double-check the table structure and ensure that the column names you are referencing in your query actually exist in the respective tables. A good practice is to list out the table and column names before writing the query to ensure accuracy.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "difficulty": "simple"
    },
    {
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "hint": "January 2012 refers to the Date value = '201201'",
        "error_sql": "SELECT SUM(Amount) FROM transactions_1k WHERE CustomerID = 38508 AND Date LIKE '201201%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(T1.Price ) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "difficulty": "moderate"
    },
    {
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "hint": "average price per single item = Total(price) / Total(amount)",
        "error_sql": "SELECT T1.CustomerID, T1.Currency, SUM(T2.Price * T2.Amount) / SUM(T2.Amount) AS AveragePricePerItem FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.CustomerID ORDER BY SUM(T2.Price * T2.Amount) DESC LIMIT 1",
        "compiler_hint": "no such column: T1.Price",
        "reflective_cot": "The error in the initial SQL query was due to referencing a non-existent column T1.Price. The correct SQL query should reference the Price column from the transactions_1k table (T2) instead. The corrected SQL calculates the total price by multiplying the price and amount columns from T2, sums these values, and then divides by the total amount to find the average price per item. To avoid similar errors in the future, always ensure that column references in your SQL queries match the correct table aliases.",
        "ground_truth_sql": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "difficulty": "moderate"
    },
    {
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "hint": "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
        "error_sql": "SELECT COUNT(*) FROM event WHERE event_id IN (SELECT link_to_event FROM attendance GROUP BY link_to_event HAVING COUNT(link_to_event) > 10) AND type = 'Meeting'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "hint": "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved",
        "error_sql": "SELECT T1.approved FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "hint": "The first 4 strings of the event_date values in the event table can represent year; The difference of the total amount spent = SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)",
        "error_sql": "SELECT ABS(SUM(CASE WHEN SUBSTR(T1.event_date,1,4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date,1,4) = '2020' THEN T2.spent ELSE 0 END)) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.status = 'Student_Club' AND T2.event_status = 'Student_Club'",
        "compiler_hint": "no such column: T1.event_status",
        "reflective_cot": "The error in the SQL query was due to the incorrect column reference 'T1.event_status'. The correct column to filter the events by status is 'T1.status'. To avoid such mistakes in the future, always double-check the column names in the table schema before writing the SQL query. Ensure that the column names used in the query match the ones in the schema. A concise tip is to refer to the schema documentation or use the 'DESCRIBE' statement to list the columns of a table before writing the query. This will help in verifying the correct column names and their data types.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "difficulty": "moderate"
    },
    {
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "hint": "budget in Advertisement refer to category = 'Advertisement' in the budget table; DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))",
        "error_sql": "SELECT SUM(CASE WHEN T1.category = 'Advertisement' AND T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) / SUM(CASE WHEN T1.category = 'Advertisement' AND T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "difficulty": "challenging"
    },
    {
        "question": "How many members attended the \"Women's Soccer\" event?",
        "hint": "'Women's Soccer' is the event name;",
        "error_sql": "SELECT COUNT(T2.link_to_member) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'Women's Soccer'",
        "compiler_hint": "near \"s\": syntax error",
        "reflective_cot": "The error in the original SQL query was caused by a misplaced alias in the FROM clause. The correct order should be the table name followed by the alias, not the alias followed by the table name. To avoid this mistake in the future, always ensure that when you define a table alias, it follows the table name, not the other way around. This helps maintain clarity and prevents syntax errors.",
        "ground_truth_sql": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "difficulty": "simple"
    },
    {
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "hint": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
        "error_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN budget AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Yearly Kickoff'",
        "compiler_hint": "no such column: T2.link_to_member",
        "reflective_cot": "The error occurred because the column 'link_to_member' does not exist in the 'budget' table, which was incorrectly referenced as 'T2.link_to_member'. The correct reference should be 'T2.link_to_member' when 'T2' is the alias for the 'budget' table. To avoid such errors in the future, always ensure that the table aliases match with the table names in the JOIN conditions and the WHERE clause. Double-check the column names and their correct references in the SQL query.",
        "ground_truth_sql": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "difficulty": "moderate"
    },
    {
        "question": "Which event has the lowest cost?",
        "hint": "event refers to event_name; lowest cost means MIN(cost)",
        "error_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'event' AND T2.spent IS NOT NULL ORDER BY T2.spent ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "hint": "percentage = DIVIDE(SUM(cost where event_name = 'Yearly Kickoff'), SUM(cost)) * 100",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost) FROM event AS T1 INNER JOIN expense AS T2 ON T1.event_id = T2.link_to_event WHERE T2.link_to_event IN (SELECT event_id FROM event WHERE event_name = 'Yearly Kickoff')",
        "compiler_hint": "no such column: T2.link_to_event",
        "reflective_cot": "The error occurred because the column 'link_to_event' was not included in the WHERE clause, causing the query to fail when attempting to filter by 'Yearly Kickoff'. To fix this, the WHERE clause should include 'T2.link_to_event IN (SELECT event_id FROM event WHERE event_name = 'Yearly Kickoff')'. This ensures that only expenses related to the 'Yearly Kickoff' event are considered. To avoid similar mistakes in the future, always ensure that all necessary conditions are included in the WHERE clause, especially when joining tables and filtering based on specific criteria. This helps prevent errors and ensures accurate query results.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "difficulty": "moderate"
    },
    {
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "hint": "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
        "error_sql": "SELECT T1.member_id FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'",
        "compiler_hint": "near \"s\": syntax error",
        "reflective_cot": "The error in the original SQL query was due to the incorrect handling of the single quote in the event name 'Women's Soccer'. The single quote caused a syntax error. To fix this, the event name should be written as 'Women''s Soccer', using two single quotes in a row to escape the single quote within the string. To avoid this mistake in the future, always remember to properly escape single quotes within strings in SQL queries. This can be done by doubling the single quote, as shown in the corrected SQL query.",
        "ground_truth_sql": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "difficulty": "moderate"
    },
    {
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "hint": "'Posters' is the expense description; 'September Speaker' is an event name",
        "error_sql": "SELECT T2.cost FROM event AS T1 INNER JOIN expense AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Speaker' AND T2.expense_description = 'Posters'",
        "compiler_hint": "no such column: T2.link_to_event",
        "reflective_cot": "The error encountered in the SQL query was due to the incorrect reference to a column that does not exist. The column \"T2.link_to_event\" was used in the join condition, but it should have been \"T2.link_to_event\". This is a common mistake when using table aliases in SQL queries. To avoid making the same mistake in the future, always double-check the column names and aliases used in your queries, especially when joining tables. Ensure that the column names and aliases match those defined in the schema of the database.",
        "ground_truth_sql": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "hint": "total value refers to SUM(cost); 'October Meeting' is an event name;",
        "error_sql": "SELECT SUM(T2.cost) FROM event AS T1 INNER JOIN expense AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Meeting' AND T2.approved = 'Yes'",
        "compiler_hint": "no such column: T2.link_to_event",
        "reflective_cot": "The error occurred because the column \"link_to_event\" was referenced as \"T2.link_to_event\" in the SQL query, but it should be referenced as just \"link_to_event\" since table aliases are not needed when referencing columns in the join condition. To avoid this mistake in the future, always double-check the join conditions and ensure that table aliases are used consistently throughout the query. In this case, the corrected SQL query should not include the table alias when referencing the \"link_to_event\" column in the join condition.",
        "ground_truth_sql": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "State the category of events were held at MU 215.",
        "hint": "'MU 215' is the location of event; ",
        "error_sql": "SELECT T1.type FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' GROUP BY T1.type",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "difficulty": "simple"
    },
    {
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "hint": "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
        "error_sql": "SELECT T1.category FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.location = 'MU 215' AND T2.type = 'Guest Speaker' AND T1.spent = 0",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "difficulty": "moderate"
    },
    {
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "hint": "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
        "error_sql": "SELECT T1.first_name, T1.last_name, T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.date_received = '9/9/2019' AND T2.amount IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "difficulty": "challenging"
    },
    {
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "hint": "male refers to SEX = 'M'; in-patient refers to Admission = '+'; outpatient refers to Admission = '-'; percentage = DIVIDE(COUNT(ID) where SEX = 'M' and Admission = '+', COUNT(ID) where SEX\u00a0 = 'M' and Admission = '-')",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'M' AND T1.Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.SEX = 'M' AND T1.Admission = '-' THEN 1 ELSE 0 END) - 100 FROM Patient AS T1 WHERE T1.Admission IN ('+', '-') AND T1.SEX = 'M'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of female patient were born after 1930?",
        "hint": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND strftime('%Y', T1.Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T1.SEX = 'F' THEN 1 ELSE NULL END) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "hint": "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SLE'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "difficulty": "moderate"
    },
    {
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "hint": "female refers to sex = 'F'; came at the hospital in 1997 refers to year(Description) = '1997'; immediately followed at the outpatient clinic refers to Admission = '-'",
        "error_sql": "SELECT COUNT(T1.SEX) FROM Patient AS T1 WHERE T1.SEX = 'F' AND T1.Birthday IN (SELECT STRFTIME('%Y', T1.Birthday)) = '1997' AND T1.Admission = '-'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
        "difficulty": "moderate"
    },
    {
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
        "error_sql": "SELECT T1.Symptoms, T1.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Birthday = (SELECT MAX(Birthday) FROM Patient WHERE T1.Symptoms IS NOT NULL) AND T1.Symptoms IS NOT NULL",
        "compiler_hint": "no such column: Examination.Symptoms",
        "reflective_cot": "The error in the SQL query was due to referencing the 'Examination' table directly in the subquery instead of using the 'T1' alias. This mistake can be avoided by consistently using table aliases throughout the query, especially when referencing columns in subqueries or join conditions. By doing so, the query becomes more readable and less prone to errors. Here's the corrected SQL query:\n\n```sql\nSELECT T1.Symptoms, T1.Diagnosis \nFROM Examination AS T1 \nINNER JOIN Patient AS T2 ON T1.ID = T2.ID \nWHERE T2.Birthday = (SELECT MIN(Birthday) FROM Patient WHERE T1.Symptoms IS NOT NULL) \nAND T1.Symptoms IS NOT NULL;\n```\n\nTip: Always use table aliases in your queries and reference columns using these aliases to avoid confusion and errors.",
        "ground_truth_sql": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)",
        "error_sql": "SELECT T2.Date, (strftime('%Y', T1.`First Date`) - strftime('%Y', T1.Birthday)) AS age\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SJS'\nORDER BY T1.Birthday ASC\nLIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "hint": "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE strftime('%Y', T1.Birthday) < strftime('%Y', datetime('now')) - 18 AND T2.`Examination Date` BETWEEN '1990-01-01' AND '1993-12-31'",
        "compiler_hint": "no such column: T2.Examination_Date",
        "reflective_cot": "The error in the original SQL query was due to a mismatch in column names. The column name in the Examination table is `Examination Date` instead of Examination_Date, and SQL is case-sensitive. To avoid such mistakes in the future, always ensure to use the exact column names as they appear in the database schema and pay attention to case sensitivity. Double-check the schema and column names before finalizing your SQL query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "difficulty": "challenging"
    },
    {
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "hint": "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
        "error_sql": "SELECT T1.Birthday, T3.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN (SELECT ID, MAX(HGB) AS max_hgb FROM Laboratory GROUP BY ID) AS T3 ON T1.ID = T3.ID WHERE T3.max_hgb = (SELECT MAX(HGB) FROM Laboratory)",
        "compiler_hint": "no such column: T3.Diagnosis",
        "reflective_cot": "The error in the initial SQL query was due to the incorrect reference of the Diagnosis column. The Diagnosis column does not exist in the Laboratory table, but in the Patient table. To avoid such mistakes in the future, always double-check the schema of the database and ensure that the column you are referencing exists in the table you are querying. A good practice is to write down the schema or have it visible while writing your queries to avoid confusion about table and column names.",
        "ground_truth_sql": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "hint": "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
        "error_sql": "SELECT T2.aCL_IgM FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T1.Description = '1994-02-19' AND T2.Examination_Date = '1993/11/12' AND T1.ID IN (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19') AND T2.Examination_Date = '1993/11/12'",
        "compiler_hint": "no such column: T2.aCL_IgM",
        "reflective_cot": "The error in the initial SQL query was due to incorrect table aliasing for the column 'aCL_IgM'. The correct table alias should be 'T2' as specified in the JOIN clause. To avoid such mistakes in the future, always ensure that column names are correctly referenced with their respective table aliases, especially when dealing with JOINed tables. This helps in avoiding ambiguity and ensures that the correct data is retrieved from the database.",
        "ground_truth_sql": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "difficulty": "moderate"
    },
    {
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "hint": "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)",
        "error_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.ANA = 'S' AND T2.`aCL IgM` > ( SELECT AVG(`aCL IgM`) FROM Examination ) * 1.2 AND T2.Thrombosis = 2",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of patients who were born in 1980 and were diagnosed with RA are women?",
        "hint": "born in 1980 refers to YEAR(BIRTHDAY) = '1980'; 'RA' refers to Diagnosis='RA' ; women refers to SEX = 'F'; calculation = DIVIDE(SUM(SEX = 'F'), COUNT(SEX)) * 100",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.SEX) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Birthday LIKE '1980%' AND T2.Diagnosis = 'RA'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Diagnosis = 'RA' AND STRFTIME('%Y', Birthday) = '1980'",
        "difficulty": "moderate"
    },
    {
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "hint": "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'",
        "error_sql": "SELECT CASE WHEN T1.TP <= 8.0 AND T2.SEX = 'M' THEN 'Yes' WHEN T1.TP <= 6.5 AND T2.SEX = 'F' THEN 'Yes' ELSE 'No' END AS `Was uric acid within a normal range?` FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.ID = 57266",
        "compiler_hint": "no such column: T1.SEX",
        "reflective_cot": "The error in the original SQL query was due to attempting to access the 'SEX' column from the 'Laboratory' table (T1), which does not exist in that table. The 'SEX' column is actually part of the 'Patient' table (T2). To avoid such errors in the future, always check the schema and ensure that the columns you are referencing exist in the tables you are querying. A concise tip is to always consult the database schema before writing queries and to join tables properly to access the correct columns.",
        "ground_truth_sql": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "difficulty": "moderate"
    },
    {
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "hint": "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
        "error_sql": "SELECT GROUP_CONCAT(DISTINCT T1.SEX) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "difficulty": "moderate"
    },
    {
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "hint": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); ",
        "error_sql": "SELECT T1.ID, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5 AND T1.Birthday IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "difficulty": "moderate"
    },
    {
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "hint": "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;",
        "error_sql": "SELECT T1.ID, strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday) AS age FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT >= 52 GROUP BY T1.ID HAVING COUNT(T1.ID) > 2",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "difficulty": "challenging"
    },
    {
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "hint": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;",
        "error_sql": "SELECT SUM(CASE WHEN T1.PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.PLT > 400 THEN 1 ELSE 0 END) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE (T1.PLT < 100 OR T1.PLT > 400)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "difficulty": "challenging"
    },
    {
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "hint": "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; ",
        "error_sql": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND T2.Date LIKE '1984%' AND strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday) < 50",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "difficulty": "challenging"
    },
    {
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "hint": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT >= 14 AND (strftime('%Y', 'now') - strftime('%Y', T1.Birthday)) > 55",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "difficulty": "challenging"
    },
    {
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "hint": "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones.",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND (T2.FG <= 150 OR T2.FG >= 450)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients with an Ig G higher than normal?",
        "hint": "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG >= 2000",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "difficulty": "simple"
    },
    {
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "hint": "normal Ig G level refers to IGG > 900 and IGG < 2000; have symptoms refers to Symptoms IS NOT NULL;",
        "error_sql": "SELECT COUNT(*) FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE IGG > 900 AND IGG < 2000) AND ID IN (SELECT ID FROM Examination WHERE Symptoms IS NOT NULL)",
        "compiler_hint": "no such column: Symptoms",
        "reflective_cot": "The error occurred because the \"Symptoms\" column does not exist in the \"Patient\" table. It is actually in the \"Examination\" table. To avoid such errors in the future, always check the schema of the database to ensure you are querying the correct table for the column you need. A concise tip is to always consult the database schema before writing queries to ensure you are referencing the correct tables and columns.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "hint": "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(`First Date`) > = 1990;",
        "error_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA > 80 AND T2.IGA < 500 AND strftime('%Y', T1.`First Date`) >= '1990'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "hint": "abnormal C-reactive protein refers to CRP ='+'; don't have data recorded refers to Description IS NULL;",
        "error_sql": "SELECT COUNT(*) FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE CRP = '+' AND Description IS NULL)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "hint": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = '-' AND T1.Admission = '+' OR T2.RNP = '+-' AND T1.Admission = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "hint": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
        "error_sql": "SELECT COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('-', '+-') AND T1.Thrombosis = 0",
        "compiler_hint": "no such column: T1.Thrombosis",
        "reflective_cot": "The error in the SQL query is due to referencing the Thrombosis column from the Patient table as T1.Thrombosis, which does not exist in the joined tables. To fix this, we should directly use the Thrombosis column from the Patient table without the table alias, as it is already included in the join condition. To avoid making the same mistake in the future, always double-check the column names and aliases when writing JOIN conditions and WHERE clauses to ensure they match the table structure and aliases used in the query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "hint": "normal anti-scl70 refers to SC170 IN('negative', '0'); female refers to Sex = 'F'; does not have any symptom refers to symptoms IS NULL; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SCR70 IN('negative', '0') AND T1.SEX = 'F' AND T2.Symptoms IS NULL",
        "compiler_hint": "no such column: T2.SC170",
        "reflective_cot": "The error occurred because the column 'SC170' was referenced as 'T2.SC170', but 'SC170' is in the 'Examination' table, not in the 'Laboratory' table. The correct column to check for 'anti-scl70' in the 'Laboratory' table is 'SCR70'. To avoid such mistakes in the future, always double-check the table and column names in your SQL queries, especially when joining multiple tables. Make sure you are referencing the correct table for each column. A good practice is to fully qualify column names with table names whenever possible to avoid ambiguity.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "difficulty": "challenging"
    },
    {
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "hint": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-') AND T1.SEX = 'M'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "hint": "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;",
        "error_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE (T2.KCT = '+' OR T2.RVVT = '+' OR T2.LAC = '+') AND EXISTS (SELECT 1 FROM Laboratory AS T3 WHERE T3.ID = T1.ID AND T3.CPK < 250)",
        "compiler_hint": "no such column: T2.CPK",
        "reflective_cot": "The error in the initial SQL query was caused by referencing a column (CPK) that does not exist in the Examination table. To correct this, we should have joined the Laboratory table, where the CPK column is located, instead of the Examination table. To avoid such mistakes in the future, always verify the schema of the database and ensure that the columns you are referencing in your query actually exist in the specified tables. A good practice is to write down or visualize the schema while planning your query to prevent such errors.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "difficulty": "challenging"
    },
    {
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "hint": "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));",
        "error_sql": "SELECT T2.team_long_name FROM (SELECT away_team_api_id, COUNT(*) AS win_count FROM Match WHERE season = '2009/2010' AND away_team_goal > home_team_goal AND league_id IN (SELECT id FROM League WHERE name = 'Scotland Premier League') GROUP BY away_team_api_id) AS T1 JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id ORDER BY T1.win_count DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "hint": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
        "error_sql": "SELECT buildUpPlaySpeed FROM Team_Attributes WHERE buildUpPlaySpeed IN (SELECT MAX(buildUpPlaySpeed) FROM Team_Attributes GROUP BY team_api_id ORDER BY buildUpPlaySpeed DESC LIMIT 4)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "difficulty": "moderate"
    },
    {
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "hint": "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';",
        "error_sql": "SELECT T2.name FROM (SELECT league_id FROM `Match` WHERE season = '2015/2016' AND home_team_goal = away_team_goal GROUP BY league_id) AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id GROUP BY T1.league_id ORDER BY COUNT(*) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "hint": "players age at present = SUBTRACT((DATETIME(), birthday)); sprint speed of no less than 97 refers to sprint_speed > = 97; between 2013 to 2015 refers to YEAR(date) > = '2013' AND YEAR(date) < = '2015'; ",
        "error_sql": "SELECT strftime('%Y', 'now') - strftime('%Y', T1.birthday) - (strftime('%m-%d', 'now') < strftime('%m-%d', T1.birthday)) AS age FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.sprint_speed >= 97 AND strftime('%Y', T2.date) BETWEEN '2013' AND '2015'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "difficulty": "challenging"
    },
    {
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "hint": " league with highest matches of all time refers to MAX(COUNT(league_id));",
        "error_sql": "SELECT T2.name ,  COUNT(*) AS num FROM Match AS T1 JOIN League AS T2 ON T1.league_id  =  T2.id GROUP BY T1.league_id ORDER BY num DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "hint": "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.player_fifa_api_id) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id WHERE strftime('%Y', T2.birthday) BETWEEN '1987' AND '1992'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "difficulty": "challenging"
    },
    {
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "hint": "heights are above 180 refers to Player.height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));",
        "error_sql": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 180 GROUP BY T1.player_name ORDER BY AVG(T2.heading_accuracy) DESC LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "hint": "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal); AVG(xx_goal) = SUM(xx_goal) / COUNT(DISTINCT Match.id); 2009/2010 season refers to season = '2009/2010'",
        "error_sql": "SELECT T2.name FROM Match AS T1 JOIN League AS T2 ON T1.league_id = T2.id WHERE T1.season = '2009/2010' GROUP BY T1.league_id HAVING SUM(T1.home_team_goal) / COUNT(DISTINCT T1.id) > SUM(T1.away_team_goal) / COUNT(DISTINCT T1.id)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "difficulty": "challenging"
    },
    {
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "hint": "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);",
        "error_sql": "SELECT AVG(T1.finishing) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id WHERE T2.height = ( SELECT MAX(height) FROM Player UNION SELECT MIN(height) FROM Player ) GROUP BY T1.player_fifa_api_id ORDER BY AVG(T1.finishing) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "hint": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
        "error_sql": "SELECT AVG(T2.overall_rating) FROM Player_Attributes AS T2 JOIN Player AS T1 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 170 AND strftime('%Y', T2.date) BETWEEN '2010' AND '2015'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "hint": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)",
        "error_sql": "SELECT SUM(CASE WHEN T2.player_name = 'Abdou Diallo' THEN T1.ball_control ELSE 0 END) / COUNT(CASE WHEN T2.player_name = 'Abdou Diallo' THEN T1.id ELSE NULL END) - SUM(CASE WHEN T2.player_name = 'Aaron Appindangoye' THEN T1.ball_control ELSE 0 END) / COUNT(CASE WHEN T2.player_name = 'Aaron Appindangoye' THEN T1.id ELSE NULL END) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "hint": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
        "error_sql": "SELECT T2.name FROM Match AS T1 JOIN League AS T2 ON T1.league_id = T2.id WHERE T1.season = '2008/2009' GROUP BY T2.name ORDER BY COUNT(T1.id) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "difficulty": "simple"
    },
    {
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "hint": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
        "error_sql": "SELECT CAST((SUM(CASE WHEN T1.player_name = 'Ariel Borysiuk' THEN T2.overall_rating ELSE 0 END) - SUM(CASE WHEN T1.player_name = 'Paulin Puel' THEN T2.overall_rating ELSE 0 END)) * 100.0 / SUM(CASE WHEN T1.player_name = 'Paulin Puel' THEN T2.overall_rating ELSE 0 END)) AS REAL FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name IN ('Ariel Borysiuk', 'Paulin Puel')",
        "compiler_hint": "near \")\": syntax error",
        "reflective_cot": "The error in the initial SQL query was due to incorrect syntax in the division operation. The division operator should be used between the parentheses, not outside them. To fix this, I moved the division operation inside the parentheses and ensured that the division was performed as a floating-point division by using 100.0 instead of 100. To avoid similar mistakes in the future, always double-check the syntax of arithmetic operations and ensure that the division is performed correctly, especially when dealing with numeric data types. Using explicit casting or ensuring the divisor is a floating-point number can help prevent integer division errors.",
        "ground_truth_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "hint": "77 points overall rating refers to overall_rating = 77; on 2016/6/23 refers to date LIKE '2016-06-23%'; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating = 77 AND T2.date = '2016-06-23' ORDER BY T1.birthday ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "hint": "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)",
        "error_sql": "SELECT T1.date FROM Player_Attributes AS T1 JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Kevin Constant' ORDER BY T1.crossing DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "hint": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery'; percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Landon Donovan' overall_rating)*100",
        "error_sql": "SELECT CAST((SUM(IIF(T1.player_name = 'Landon Donovan', T2.overall_rating, 0)) - SUM(IIF(T1.player_name = 'Jordan Bowery', T2.overall_rating, 0))) AS REAL) * 100 / SUM(IIF(T1.player_name = 'Landon Donovan', T2.overall_rating, 0)) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.date = '2013-07-12'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "difficulty": "challenging"
    },
    {
        "question": "State the name of the most strongest player.",
        "hint": "strongest players refers to player has MAX(overall_rating)",
        "error_sql": "SELECT T2.player_name FROM Player_Attributes AS T1 JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.strength = ( SELECT MAX(strength) FROM Player_Attributes )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
        "difficulty": "simple"
    },
    {
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "hint": "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';",
        "error_sql": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high' LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "difficulty": "moderate"
    },
    {
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "hint": "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'",
        "error_sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND strftime('%Y', birthday) > '1990'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "difficulty": "simple"
    },
    {
        "question": "Please provide top four football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "hint": "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
        "error_sql": "SELECT T1.player_api_id FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.preferred_foot = 'right' ORDER BY T1.potential ASC LIMIT 4",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 4",
        "difficulty": "moderate"
    },
    {
        "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
        "hint": "KSV Cercle Brugge refers to team_long_name = 'KSV Cercle Brugge'; speed class refers to buildUpPlaySpeedClass",
        "error_sql": "SELECT buildUpPlaySpeedClass FROM Team_Attributes WHERE team_api_id IN (SELECT id FROM Team WHERE team_long_name = 'KSV Cercle Brugge')",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
        "difficulty": "moderate"
    },
    {
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "hint": "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
        "error_sql": "SELECT T1.finishing, T1.curve FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id WHERE T2.weight = ( SELECT MAX(weight) FROM Player )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "hint": "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;",
        "error_sql": "SELECT T1.driverRef FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 20 AND T2.q1 = ( SELECT MAX(q1) FROM qualifying WHERE raceId = 20 GROUP BY driverId LIMIT 5 ) ORDER BY T2.q1 DESC LIMIT 5",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "hint": "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);",
        "error_sql": "SELECT T1.surname FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 19 AND T2.q2 = (SELECT MIN(q2) FROM qualifying WHERE raceId = 19 AND q2 IS NOT NULL)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "hint": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'",
        "error_sql": "SELECT T1.number FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 903 AND T2.q3 LIKE 'M:SS%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "difficulty": "simple"
    },
    {
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "hint": "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT T1.forename, T1.surname, T1.dob FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "hint": "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
        "error_sql": "SELECT T1.url FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.raceId = 161 AND T2.time LIKE '01:27%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "difficulty": "moderate"
    },
    {
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "hint": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
        "error_sql": "SELECT CAST((T1.fastestLapSpeed - T2.fastestLapSpeed) * 100.0 / T1.fastestLapSpeed AS REAL) FROM (SELECT MAX(fastestLapSpeed) AS fastestLapSpeed FROM results WHERE raceId = 853) AS T1, (SELECT MAX(fastestLapSpeed) AS fastestLapSpeed FROM results WHERE raceId = 854) AS T2",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "difficulty": "challenging"
    },
    {
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "hint": "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT T1.forename, T1.surname, MAX(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId GROUP BY T1.driverId, T1.forename, T1.surname ORDER BY T2.points DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "hint": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name",
        "error_sql": "SELECT T3.forename, T3.surname, T2.name FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T1.milliseconds = ( SELECT MIN(milliseconds) FROM lapTimes )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.",
        "hint": "percentage = DIVIDE(COUNT(raceId) where surname = 'Hamilton' and position>1), (COUNT(raceId) where surname = 'Hamilton'); since 2010 refers to year >= 2010",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.position > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.position) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.surname = 'Hamilton' AND T2.year >= 2010",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.surname = 'Hamilton' AND T1.year >= 2010",
        "difficulty": "challenging"
    },
    {
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);",
        "error_sql": "SELECT T3.forename, T3.surname, T3.nationality, MAX(T1.points) FROM driverStandings AS T1 INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId GROUP BY T3.driverRef ORDER BY SUM(T1.points) DESC LIMIT 1",
        "compiler_hint": "no such column: T2.points",
        "reflective_cot": "The error in the original SQL query was due to a misunderstanding of the schema and the relationships between the tables. The points column is in the driverStandings table, not the constructors table, hence the error \"no such column: T2.points\". The corrected SQL query correctly joins the driverStandings and drivers tables and aggregates the points to find the driver with the most points. To avoid similar errors in the future, always double-check the schema and the relationships between the tables before writing the SQL query. It's also helpful to write down the logic of the query step by step to ensure you are joining the correct tables and selecting the correct columns.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "hint": "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
        "error_sql": "SELECT T1.raceId FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "difficulty": "simple"
    },
    {
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "hint": "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' AND T2.fastestLap = ( SELECT MIN(milliseconds) FROM results WHERE driverId = ( SELECT driverId FROM drivers WHERE forename = 'Michael' AND surname = 'Schumacher' ) )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "hint": "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT T2.year, T4.points FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId INNER JOIN driverStandings AS T4 ON T2.raceId = T4.raceId AND T2.driverId = T4.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' ORDER BY T3.year ASC LIMIT 1",
        "compiler_hint": "no such column: T2.year",
        "reflective_cot": "The error in the initial SQL query was caused by attempting to select the 'year' column from the 'results' table, which does not exist. The 'year' information is stored in the 'races' table. To avoid such mistakes in the future, always double-check the table schema and ensure that the columns you are referencing in your query actually exist in the specified tables. A good practice is to join the necessary tables first and then select the required columns from the correct tables. In this case, joining the 'results' table with the 'races' table on the 'raceId' column allowed us to access the 'year' information correctly.",
        "ground_truth_sql": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "hint": "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';",
        "error_sql": "SELECT T2.driverRef FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T3.name = 'Canadian Grand Prix' AND T3.year = 2007 AND T1.position = 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "difficulty": "moderate"
    },
    {
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "hint": "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT T1.raceId FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T2.rank ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "difficulty": "simple"
    },
    {
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "hint": "Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname; final rank refers to positionOrder; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "error_sql": "SELECT T3.position FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "compiler_hint": "no such column: T3.positionOrder",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of \"T3.positionOrder\". In the schema provided, the column for final rank in the results table is \"position\", not \"positionOrder\". The corrected SQL query uses \"T3.position\" instead. To avoid making the same mistake in the future, always refer back to the schema and sample data provided to ensure the correct column names are being used in the SQL query. Keeping the schema and sample data visible while writing the query can help prevent such errors.",
        "ground_truth_sql": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "difficulty": "moderate"
    },
    {
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "hint": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "error_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = 'Australian Grand Prix' AND T1.position = 2",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "difficulty": "simple"
    },
    {
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "hint": "how much faster in percentage = divide(subtract(incremental time, champion time), last_driver time) * 100; last driver finished time = incremental time + champion time; only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null",
        "error_sql": "SELECT CAST((T1.champion_time - T2.last_driver_time) AS REAL) * 100 / T2.last_driver_time FROM (SELECT T3.champion_time, T3.last_driver_time FROM results AS T1 JOIN (SELECT raceId, MIN(lastDriverTime) AS last_driver_time, MIN(championTime) AS champion_time FROM (SELECT T1.raceId, T1.driverId, T1.statusId, T1.fastestLap, T1.rank, T1.fastestLapTime, T1.fastestLapSpeed, T1.grid, T1.laps, T1.milliseconds, T1.points, T1.position, T1.positionOrder, T1.positionText, T1.number, T1.time, T1.constructorId, T1.statusId, T1.driverId, T1.raceId, T2.lastDriverTime, T2.championTime FROM results AS T1 JOIN (SELECT raceId, MAX(incremental_time) AS lastDriverTime, MIN(incremental_time) AS championTime FROM (SELECT T1.raceId, T1.driverId, T1.statusId, T1.fastestLap, T1.rank, T1.fastestLapTime, T1.fastestLapSpeed, T1.grid, T1.laps, T1.milliseconds, T1.points, T1.position, T1.positionOrder, T1.positionText, T1.number, T1.time, T1.constructorId, T1.statusId, T1.driverId, T1.raceId, T2.incremental_time AS lastDriverTime, T2.incremental_time AS championTime FROM results AS T1 JOIN (SELECT raceId, driverId, incremental_time FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') ORDER BY incremental_time DESC LIMIT 1) AS T2 ON T1.raceId = T2.raceId WHERE T1.raceId = T2.raceId AND T1.driverId = (SELECT driverId FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND position = 1) ) GROUP BY raceId ) AS T2 ON T1.raceId = T2.raceId WHERE T1.raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') ) AS T3) AS T1 JOIN (SELECT T3.last_driver_time FROM results AS T1 JOIN (SELECT raceId, MAX(incremental_time) AS lastDriverTime FROM (SELECT T1.raceId, T1.driverId, T1.statusId, T1.fastestLap, T1.rank, T1.fastestLapTime, T1.fastestLapSpeed, T1.grid, T1.laps, T1.milliseconds, T1.points, T1.position, T1.positionOrder, T1.positionText, T1.number, T1.time, T1.constructorId, T1.statusId, T1.driverId, T1.raceId, T2.incremental_time AS lastDriverTime FROM results AS T1 JOIN (SELECT raceId, driverId, incremental_time FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') ORDER BY incremental_time DESC LIMIT 1) AS T2 ON T1.raceId = T2.raceId WHERE T1.raceId = T2.raceId AND T1.driverId = (SELECT driverId FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND position = LAST) ) GROUP BY raceId ) AS T2 ON T1.raceId = T2.raceId WHERE T1.raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') ) AS T2 ON T1.raceId = T2.raceId WHERE T1.raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND T1.driverId = (SELECT driverId FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND position = 1)",
        "compiler_hint": "parser stack overflow",
        "reflective_cot": "The error in the initial SQL query was due to an attempt to perform arithmetic operations and nested subqueries in a way that exceeded the parser's stack limit. The correct approach is to first identify the champion's time and the last driver's time for the specific race, then calculate the percentage difference. To avoid similar mistakes in the future, it's crucial to simplify complex queries by breaking them down into smaller, manageable parts and using temporary tables or subqueries to store intermediate results. This not only helps in avoiding parser stack overflow errors but also makes the query more readable and easier to debug.",
        "ground_truth_sql": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "difficulty": "challenging"
    },
    {
        "question": "Please list the constructor names with 0 points at race 291.",
        "hint": "race at 291 refers to raceID = 291;",
        "error_sql": "SELECT T1.name FROM constructors AS T1 INNER JOIN constructorResults AS T2 ON T1.constructorId = T2.constructorId WHERE T2.raceId = 291 AND T2.points = 0",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "difficulty": "simple"
    },
    {
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "hint": "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';",
        "error_sql": "SELECT COUNT(*) FROM (SELECT constructorId FROM constructorResults WHERE points = 0 GROUP BY constructorId HAVING COUNT(raceId) = 2) AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T2.nationality = 'Japanese'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "difficulty": "simple"
    },
    {
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "hint": "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to time is not null; percentage = Divide(COUNT(DriverID where time is not null and year between 2007 and 2009),Count (DriverID where year between 2007 and 2009))*100; ",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.time) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year BETWEEN 2007 AND 2009 AND T3.nationality = 'Japanese'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "difficulty": "challenging"
    },
    {
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "hint": "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
        "error_sql": "SELECT AVG(strftime('%s', T1.time)) FROM results AS T1 JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year < 1975 AND T1.time IS NOT NULL AND T1.position = 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "difficulty": "challenging"
    },
    {
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "hint": "lap time less than 02:00.00 refers to seconds < 120;",
        "error_sql": "SELECT COUNT(*) FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND T2.time < '02:00.00'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "difficulty": "moderate"
    },
    {
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);",
        "error_sql": "SELECT T1.date, T1.time, T2.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.dob = (SELECT MIN(dob) FROM drivers) ORDER BY T1.date ASC LIMIT 1",
        "compiler_hint": "no such column: T3.name",
        "reflective_cot": "The error in the original SQL query was due to an incorrect table alias used in the SELECT statement. The table alias 'T3' was used to access the driver's name, but the name is actually stored in the 'T2' table alias in the corrected SQL query. This mistake was made because the original query attempted to join the 'drivers' table with the 'qualifying' table, which does not have a direct relationship with the 'drivers' table. The corrected query joins the 'results' table with the 'drivers' table, which is the correct relationship. To avoid such mistakes in the future, always double-check the relationships between tables and ensure that the correct table aliases are used in the SELECT statement. A concise tip would be to sketch out the schema of the database and the relationships between tables before writing the SQL query to ensure that you are using the correct table aliases and relationships.",
        "ground_truth_sql": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980<= year(dob) <=1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
        "error_sql": "SELECT T1.forename, T1.surname, T3.driverId FROM drivers AS T1 INNER JOIN ( SELECT T2.driverId, AVG(T2.duration) AS avg_duration FROM drivers AS T1 INNER JOIN pitStops AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'German' AND strftime('%Y', T1.dob) BETWEEN '1980' AND '1985' GROUP BY T2.driverId ) AS T3 ON T1.driverId = T3.driverId ORDER BY T3.avg_duration ASC LIMIT 3",
        "compiler_hint": "ambiguous column name: driverId",
        "reflective_cot": "The error in the original SQL query was due to ambiguous column name 'driverId'. This happened because 'driverId' exists in both the drivers and pitStops tables and was not properly qualified in the subquery. The corrected SQL query properly references the 'driverId' from the appropriate table (T2) in the subquery.\n\nTip to avoid this mistake: Always qualify column names with the table alias when joining tables, especially when the column name exists in multiple tables. This prevents ambiguity and ensures the correct column is referenced.\n\nShort and concise tip: Qualify column names with table alias when joining tables.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "difficulty": "challenging"
    },
    {
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "hint": "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";",
        "error_sql": "SELECT T1.driverId, T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.position = 1 AND T1.time LIKE '%:%:%.%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "hint": "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url",
        "error_sql": "SELECT T2.constructorRef, T2.url FROM results AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T1.raceId = ( SELECT raceId FROM races WHERE name = '2009 Singapore Grand Prix' ) AND T1.position = 1 ORDER BY T1.time DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "challenging"
    },
    {
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "hint": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
        "error_sql": "SELECT T3.points, T2.name, T2.nationality FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN constructors AS T3 ON T2.constructorId = T3.constructorId WHERE T1.name = 'Monaco Grand Prix' AND T1.year BETWEEN 1980 AND 2010 GROUP BY T3.constructorId ORDER BY SUM(T2.points) DESC LIMIT 1",
        "compiler_hint": "no such column: T3.points",
        "reflective_cot": "The error in the original SQL query was due to a misreference of the points column. The correct reference should be T2.points since the points column is in the results table, not the constructors table. To avoid making the same mistake in the future, always double-check the table aliases and column names when referencing them in your SELECT and GROUP BY clauses. A good practice is to list out the tables and their aliases at the beginning of your query and refer back to them as needed. This helps ensure that you are using the correct table and column names throughout your query.",
        "ground_truth_sql": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "hint": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
        "error_sql": "SELECT T3.forename, T3.surname FROM qualifying AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.name = 'Marina Bay Street Circuit' AND T2.year = 2008 AND T1.position = 1 AND T1.q3 = ( SELECT MIN(q3) FROM qualifying WHERE raceId IN ( SELECT raceId FROM races WHERE name = 'Marina Bay Street Circuit' AND year = 2008 ) )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "hint": "full name refers to forename+surname; Youngest racer = MAX(dob)",
        "error_sql": "SELECT T1.forename || ' ' || T1.surname AS full_name, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T1.dob = (SELECT MAX(dob) FROM drivers) ORDER BY T3.year ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?",
        "hint": "number of accidents refers to the number where statusid = 3; Canadian Grand Prix refers to the race of name\n",
        "error_sql": "SELECT COUNT(*) FROM results WHERE statusId = 3 AND raceId = (SELECT raceId FROM races WHERE name = 'Canadian Grand Prix') GROUP BY driverId ORDER BY COUNT(*) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN status AS T3 on T1.statusId = T3.statusId WHERE T3.statusId = 3 AND T2.name = 'Canadian Grand Prix' GROUP BY T1.driverId ORDER BY COUNT(T1.driverId) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "hint": "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
        "error_sql": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.time = ( SELECT MIN(T1.time) FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId GROUP BY T2.driverId LIMIT 20 ) GROUP BY T2.driverId LIMIT 20",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "difficulty": "challenging"
    },
    {
        "question": "Please list the lap records for the circuits in Italy.",
        "hint": "lap record means the fastest time recorded which refers to time",
        "error_sql": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ORDER BY T1.time LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "hint": "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
        "error_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "difficulty": "moderate"
    },
    {
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "hint": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
        "error_sql": "SELECT T1.superhero_name, T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics') GROUP BY T2.colour ORDER BY COUNT(T1.id) DESC",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "hint": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T3.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "compiler_hint": "no such column: T2.alignment",
        "reflective_cot": "The error in the initial SQL query was due to referencing the alignment column under the wrong table alias. The alignment column is under the alignment table, not the publisher table. The corrected SQL query properly references the alignment column under the alignment table alias.\n\nA concise tip to avoid making this mistake in the future is to always double check the table aliases and column references when writing JOIN conditions and WHERE clauses. Make sure the column being referenced belongs to the correct table alias that was specified in the JOIN condition. This will help prevent referencing columns under the wrong table aliases, which was the cause of the error in this case.",
        "ground_truth_sql": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "difficulty": "challenging"
    },
    {
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "hint": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
        "error_sql": "SELECT T3.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T1.height_cm = 185 AND T3.race = 'human'",
        "compiler_hint": "no such column: T3.colour",
        "reflective_cot": "The error occurred because we tried to access a column (T3.colour) that doesn't exist in the joined table. The correct column to access is T2.colour since hair_colour_id is linked to the colour table through T2. To avoid such mistakes in the future, always double-check the column names and their origins when writing SELECT statements, especially when dealing with multiple table joins. Ensure that the column you're selecting is from the correct table in the join.",
        "ground_truth_sql": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the hero's full name with the highest attribute in strength?",
        "hint": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "error_sql": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "hint": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "error_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'durability' AND T1.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics') ORDER BY T2.attribute_value DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "hint": "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.gender = 'Female' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.publisher_name) FROM publisher AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.publisher_id WHERE T1.publisher_name = 'Marvel Comics' AND T2.gender_id IN (SELECT id FROM gender WHERE gender = 'Female')",
        "compiler_hint": "no such column: T2.gender",
        "reflective_cot": "The error in the original SQL query was due to referencing the non-existent column 'gender' in table T2. The correct column to reference for gender information is 'gender_id', which is a foreign key to the gender table. To avoid such mistakes in the future, always double-check the schema and ensure that you are using the correct column names, especially when dealing with foreign keys and relationships between tables. A good practice is to explicitly join the related tables, like the gender table in this case, to avoid ambiguity and ensure accurate data retrieval.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) * 100 FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average height for all superhero.",
        "hint": "average = DIVIDE(SUM(height_cm), COUNT(all heros));",
        "error_sql": "SELECT CAST(SUM(T1.height_cm) AS REAL) / COUNT(T1.height_cm) FROM superhero AS T1 WHERE T1.height_cm IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "difficulty": "simple"
    },
    {
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "hint": "ability of Phoenix Force refers to power_name = 'Phoenix Force';",
        "error_sql": "SELECT T2.gender FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN superpower AS T3 ON T1.power_id = T3.id WHERE T3.power_name = 'Phoenix Force' AND T2.gender_id = (SELECT id FROM gender WHERE gender = 'Male')",
        "compiler_hint": "no such column: T2.gender",
        "reflective_cot": "The error in the initial SQL query was due to the fact that the superhero table's gender is referenced by an ID, not directly by the gender text. To fix this, we need to join the gender table and use the correct gender ID in the WHERE clause. To avoid making the same mistake in the future, always check the schema of the database to understand how the data is structured and related. In this case, understanding that the gender is stored as an ID in the superhero table and that it references the gender table would have prevented the error.",
        "ground_truth_sql": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "difficulty": "moderate"
    },
    {
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "hint": "\"Harlan\" and \"Jarrod Dixon\" are both DisplayName; highest reputation refers to Max(Reputation)",
        "error_sql": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 WHERE T1.DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY T1.Reputation DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "difficulty": "simple"
    },
    {
        "question": "How many users last accessed the website after 2014/9/1?",
        "hint": "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
        "error_sql": "SELECT COUNT(*) FROM users WHERE LastAccessDate > '2014-09-01'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "difficulty": "simple"
    },
    {
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "hint": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
        "error_sql": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.UserId = 3025 AND T2.CreationDate = '2014-04-23 20:29:39'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "difficulty": "moderate"
    },
    {
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "hint": "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa",
        "error_sql": "SELECT CASE WHEN (SELECT ClosedDate FROM posts WHERE Id = (SELECT PostId FROM postLinks WHERE RelatedPostId = (SELECT PostId FROM comments WHERE UserId = 23853 AND CreationDate = '2013-07-12 09:08:18.0'))) IS NULL THEN 'Not Well-finished' ELSE 'Well-finished' END",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "difficulty": "moderate"
    },
    {
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "hint": "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
        "error_sql": "SELECT CAST(COUNT(T1.Id) AS REAL) * 100 / COUNT(T2.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.OwnerUserId = 24 AND T2.UserId = 24",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "difficulty": "moderate"
    },
    {
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "hint": "\"Understanding what Dassault iSight is doing?\" is the Title of post; user refers to DisplayName;",
        "error_sql": "SELECT T1.DisplayName, T2.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "compiler_hint": "no such column: T2.Reputation",
        "reflective_cot": "The error in the original SQL query was due to referencing the Reputation column with the alias T2, which was not correct. The correct reference should be T1.Reputation since the Reputation column is in the users table, not the posts table. To avoid such mistakes in the future, always double-check the table aliases and column references in your SQL queries. Make sure you are referencing columns from the correct table alias to prevent errors.",
        "ground_truth_sql": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "difficulty": "moderate"
    },
    {
        "question": "Who is the owner of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "hint": "'Open source tools for visualizing multi-dimensional data' is the Title of Post; owner refers to DisplayName;",
        "error_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Open source tools for visualizing multi-dimensional data'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "difficulty": "moderate"
    },
    {
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "hint": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
        "error_sql": "SELECT T1.Text FROM comments AS T1 INNER JOIN postHistory AS T2 ON T1.PostId = T2.PostId WHERE T2.Comment = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "difficulty": "moderate"
    },
    {
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "hint": "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'",
        "error_sql": "SELECT T2.DisplayName FROM votes AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id INNER JOIN posts AS T3 ON T1.PostId = T3.Id WHERE T1.BountyAmount = 50 AND T3.Title LIKE '%variance%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "hint": "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)",
        "error_sql": "SELECT T1.Title, T3.Text, AVG(T1.ViewCount) FROM posts AS T1 INNER JOIN postTags AS T2 ON T1.Id = T2.PostId INNER JOIN comments AS T3 ON T1.Id = T3.PostId WHERE T2.TagName = 'humor' GROUP BY T1.Id",
        "compiler_hint": "no such table: postTags",
        "reflective_cot": "The error in the initial SQL query was due to a missing table in the database schema. The 'postTags' table was referenced but not defined in the schema. To correct this, ensure that all tables mentioned in the SQL query actually exist in the database schema. In this case, the 'postTags' table was missing, so it needed to be added to the schema. A tip to avoid such errors in the future is to always verify the existence of all tables and columns in the database schema before writing the SQL query. This can be done by reviewing the schema or using database tools that provide schema information.",
        "ground_truth_sql": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "difficulty": "moderate"
    },
    {
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "hint": "having at least 1000 view refers to Views > = 1000; user refers to UserId",
        "error_sql": "SELECT T1.Id, T1.ViewCount FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id INNER JOIN postHistory AS T3 ON T1.Id = T3.PostId WHERE T1.ViewCount >= 1000 AND (SELECT COUNT(*) FROM postHistory WHERE PostId = T1.Id) = 1 GROUP BY T1.Id HAVING COUNT(T3.PostId) = 1",
        "compiler_hint": "no such column: T1.Views",
        "reflective_cot": "The error in the original SQL query was due to a typo in the column name. The correct column name for the number of views on a post is \"ViewCount\" instead of \"Views\". This error could have been avoided by double-checking the column names in the schema or by using an IDE with syntax highlighting and auto-completion features. A good practice is to always refer to the schema while writing queries and to use tools that can help catch such errors early on.",
        "ground_truth_sql": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "hint": "student badges refers to badge's name = 'Student'; during 2010 refers to Year(Date) = 2010; during 2011 refers to Year(Date) = 2011; percentage difference = Subtract (Divide(Count(Name where Year(Date) = 2010), Count (Name)) *100, Divide(Count(Name where Year(Date) = 2011), Count(Name)) * 100)",
        "error_sql": "SELECT CAST((SUM(CASE WHEN strftime('%Y', T1.Date) = '2011' THEN 1 ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.Date) = '2010' THEN 1 ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN T1.Name = 'Student' THEN 1 ELSE 0 END) FROM badges AS T1 WHERE T1.Name = 'Student'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "hint": "creating more than 10 post refers to Count (UserId) > 10; average of the up votes = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))",
        "error_sql": "SELECT CAST(SUM(T1.UpVotes) AS REAL) / COUNT(T1.Id) AS AverageUpVotes, CAST(SUM(T2.Age) AS REAL) / COUNT(T2.Id) AS AverageAge FROM (SELECT UserId, SUM(UpVotes) AS UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes FROM (SELECT UserId, UpVotes",
        "compiler_hint": "no such column: UserId",
        "reflective_cot": "The error in the original SQL query was due to a misunderstanding of how to reference columns in a subquery. The corrected SQL query should reference the columns correctly from the appropriate tables. To avoid such mistakes in the future, always ensure that you reference columns correctly by specifying the table they belong to, especially in complex queries involving multiple joins and subqueries. A good practice is to alias tables for clarity and to prevent ambiguity. Also, review and test your queries on a small dataset to catch errors early. Here's a simplified and corrected version of the SQL query:\n\n```sql\nSELECT CAST(SUM(T1.UpVotes) AS REAL) / COUNT(T1.Id) AS AverageUpVotes, \n       CAST(SUM(T2.Age) AS REAL) / COUNT(T2.Id) AS AverageAge\nFROM users AS T1\nJOIN (SELECT UserId FROM posts GROUP BY UserId HAVING COUNT(*) > 10) AS T3 ON T1.Id = T3.UserId\nJOIN users AS T2 ON T2.Id = T3.UserId;\n```\n\nThis query calculates the average upvotes and average age of users who have created more than 10 posts.",
        "ground_truth_sql": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "difficulty": "moderate"
    },
    {
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "hint": "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
        "error_sql": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky' OR T2.DisplayName = 'Noah Snyder' ORDER BY T1.ViewCount DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "hint": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
        "error_sql": "SELECT T1.TagName FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id WHERE T2.OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes') AND T2.CommentCount = 0",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "hint": "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.TagName = 'r' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN tags AS T2 ON T1.Id = T2.ExcerptPostId WHERE T1.OwnerUserId = ( SELECT Id FROM users WHERE DisplayName = 'Community' )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "hint": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
        "error_sql": "SELECT SUM(CASE WHEN T1.DisplayName = 'Mornington' THEN T2.ViewCount ELSE 0 END) - SUM(CASE WHEN T1.DisplayName = 'Amos' THEN T2.ViewCount ELSE 0 END) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
        "hint": "calculation = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2010 and AnswerCount < = 2), 12)",
        "error_sql": "SELECT CAST(SUM(CASE WHEN strftime('%Y', T1.CreationDate) = '2010' AND T2.AnswerCount <= 2 THEN 1 ELSE 0 END) AS REAL) * 12 / COUNT(DISTINCT strftime('%m', T1.CreationDate)) FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "hint": "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';",
        "error_sql": "SELECT COUNT(DISTINCT T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "difficulty": "moderate"
    },
    {
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "hint": "the most valuable post in 2010 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
        "error_sql": "SELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE strftime('%Y', T1.CreationDate) = '2010' ORDER BY T1.FavoriteCount DESC LIMIT 1",
        "compiler_hint": "no such column: T1.CreationDate",
        "reflective_cot": "The error in the original SQL query was due to a typo in the column name 'T1.CreationDate'. The correct column name is 'T1.CreationDate'. To avoid such mistakes in the future, always double-check the column names and table names for accuracy when writing SQL queries. A good practice is to refer to the database schema or use an IDE with auto-completion features to ensure the correct names are used. Tip: After writing a query, review it against the database schema to confirm all table and column names are spelled correctly and exist in the schema.",
        "ground_truth_sql": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "hint": "percentage = DIVIDE(COUNT(Id where YEAR(CreationDate) = 2011 and Reputation > 1000), COUNT(Id) ) * 100;",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.CreationDate BETWEEN '2011-01-01' AND '2011-12-31'",
        "compiler_hint": "no such column: T2.CreationDate",
        "reflective_cot": "The error in the original SQL query was due to the incorrect reference to the CreationDate column in the posts table. The error message \"no such column: T2.CreationDate\" indicates that the column was not found in the table. This happened because the column name was misspelled as \"CreationDate\" instead of the correct \"CreationDate\". To fix this, the correct column name should be used in the SQL query.\n\nTo avoid making the same mistake in the future, always double-check the column names and table names in your SQL queries to ensure they match the schema of the database you are querying. In this case, the correct column name is \"CreationDate\" with the correct case, which should be used in the SQL query.\n\nAdditionally, it's a good practice to use the BETWEEN operator to specify a range of dates instead of hard-coding the year in the query. This makes the query more flexible and easier to modify in the future if needed. In this case, the corrected SQL query uses the BETWEEN operator to filter the posts created in 2011.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "hint": "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';",
        "error_sql": "SELECT T1.ViewCount, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Computer Game Datasets' ORDER BY T1.LasActivityDate DESC LIMIT 1",
        "compiler_hint": "no such column: T1.CreationDate",
        "reflective_cot": "The error in the original SQL query was due to a typo in the column name. The correct column name for ordering by the post's last activity date is `LasActivityDate` instead of `CreationDate`. To avoid such mistakes in the future, always double-check the column names in the schema and ensure they match the ones used in the query. Using an IDE with SQL syntax highlighting and auto-completion can also help catch such errors early.",
        "ground_truth_sql": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "hint": "the latest comment refers to MAX(CreationDate);",
        "error_sql": "SELECT T1.Text, T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id INNER JOIN posts AS T3 ON T1.PostId = T3.Id WHERE T3.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "hint": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.Reputation = ( SELECT MAX(Reputation) FROM users )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "difficulty": "challenging"
    },
    {
        "question": "What is the excerpt post ID and wiki post ID of the tag named sample?",
        "hint": "tag named sample refers to TagName = 'sample';",
        "error_sql": "SELECT T1.Id FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id WHERE T1.TagName = 'sample' UNION SELECT T1.Id FROM tags AS T1 INNER JOIN posts AS T2 ON T1.WikiPostId = T2.Id WHERE T1.TagName = 'sample'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'",
        "difficulty": "simple"
    },
    {
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "hint": "in posts with 1 comment refers to CommentCount = 1;",
        "error_sql": "SELECT COUNT(*) FROM (SELECT PostId FROM comments WHERE Score = 0 GROUP BY PostId HAVING COUNT(*) = 1)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "difficulty": "simple"
    },
    {
        "question": "Which are the cards that have incredibly powerful foils.",
        "hint": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "error_sql": "SELECT uuid FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What are the borderless cards available without powerful foils?",
        "hint": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
        "error_sql": "SELECT * FROM cards WHERE borderColor = 'borderless' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL AND cardKingdomFoilId = cardKingdomId",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "difficulty": "simple"
    },
    {
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "hint": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "error_sql": "SELECT T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T2.status = 'Banned' AND T2.format = 'gladiator'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "difficulty": "moderate"
    },
    {
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "hint": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
        "error_sql": "SELECT T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniel'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "hint": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
        "error_sql": "SELECT T1.name, T1.artist, T3.isPromo FROM cards AS T1 INNER JOIN ( SELECT uuid, COUNT(uuid) AS cnt FROM rulings GROUP BY uuid ORDER BY cnt DESC LIMIT 1 ) AS T2 ON T1.uuid = T2.uuid INNER JOIN ( SELECT uuid, isPromo FROM cards ) AS T3 ON T1.uuid = T3.uuid WHERE T3.isPromo = 1",
        "compiler_hint": "no such column: T2.isPromo",
        "reflective_cot": "The error in the initial SQL query was due to attempting to access the 'isPromo' column from the 'T2' alias, which was not part of the 'rulings' table. The 'isPromo' column is part of the 'cards' table, so it should be accessed from an alias that references the 'cards' table. To avoid this mistake in the future, always ensure that any column you reference in a SQL query is either part of a table that is included in the query or is part of a subquery or derived table that is properly aliased and referenced.",
        "ground_truth_sql": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "hint": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "compiler_hint": "no such column: T2.language",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of table names and columns. The query was trying to access the 'language' column from the 'sets' table, which does not exist. The correct table to reference for the 'language' column is 'foreign_data'. To avoid such mistakes in the future, always double-check the table names and column names in your SQL queries against the database schema. Make sure you are referencing the correct tables and columns for the data you are trying to retrieve or manipulate. In this case, using 'foreign_data' instead of 'sets' for the 'language' column would have prevented the error. A quick review of the schema before writing the query would have helped catch this mistake.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "difficulty": "moderate"
    },
    {
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "hint": "Benalish Knight' is the name of card; rule of playing card refers to format;",
        "error_sql": "SELECT T2.text FROM cards AS T1 JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "difficulty": "simple"
    },
    {
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "hint": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
        "error_sql": "SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType LIKE '%Artifact%' AND T1.colors = 'B' AND T2.language != ''",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "hint": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
        "error_sql": "SELECT CAST(SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards WHERE isStorySpotlight = 1 AND isTextless = 0 UNION SELECT id FROM cards WHERE isStorySpotlight = 1 AND isTextless = 0 ORDER BY id",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isTextless = 0 AND  isStorySpotlight = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "difficulty": "moderate"
    },
    {
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "hint": "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'",
        "error_sql": "SELECT COUNT(T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Commander' AND T2.language = 'Portuguese (Brasil)'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "difficulty": "moderate"
    },
    {
        "question": "How many unknown power cards contain info about the triggered ability",
        "hint": "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'",
        "error_sql": "SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND text LIKE '%triggered ability%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT Count(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "difficulty": "moderate"
    },
    {
        "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
        "hint": "pre-modern format refers to format = 'premodern' ;do not have multiple faces refers to side IS NULL",
        "error_sql": "SELECT COUNT(*) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'premodern' AND T1.side IS NULL AND EXISTS(SELECT * FROM rulings AS T3 WHERE T3.uuid = T1.uuid AND T3.text = 'This is a triggered mana ability.')",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
        "difficulty": "moderate"
    },
    {
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "hint": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
        "error_sql": "SELECT T2.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.layout = 'normal' AND T1.borderColor = 'black' AND T1.artist = 'Matthew D. Wilson' AND T1.type = 'Creature' AND T2.language = 'French'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "difficulty": "moderate"
    },
    {
        "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
        "hint": "set of 180 cards refers to baseSetSize = 180",
        "error_sql": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 180 AND T1.block = 'Ravnica'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
        "difficulty": "simple"
    },
    {
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "hint": "do not have a content warning refers to hasContentWarning = 0; percentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where format = 'commander' AND Status = 'legal';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.hasContentWarning) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'legal'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "difficulty": "challenging"
    },
    {
        "question": "Which foreign language used by \"A Pedra Fellwar\"?",
        "hint": "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
        "error_sql": "SELECT T2.language FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'A Pedra Fellwar'",
        "compiler_hint": "no such column: T2.language",
        "reflective_cot": "The error in the original SQL query was due to a misunderstanding of the table schema. The column 'language' is actually in the 'foreign_data' table, not the 'cards' table. Therefore, the correct SQL query should reference 'T1.language' instead of 'T2.language'. To avoid similar mistakes in the future, always double-check the schema and ensure you understand which table contains the column you're referencing in your query.",
        "ground_truth_sql": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
        "difficulty": "simple"
    },
    {
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "hint": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
        "error_sql": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Korean'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "difficulty": "moderate"
    },
    {
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "hint": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
        "error_sql": "SELECT T1.mtgoCode IS NOT NULL FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Angel of Mercy'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "difficulty": "moderate"
    },
    {
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "hint": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
        "error_sql": "SELECT T1.isForeignOnly FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Adarkar Valkyrie'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null",
        "error_sql": "SELECT COUNT(*) FROM cards AS T1 WHERE T1.convertedManaCost > 5 AND (T1.power = '*' OR T1.power IS NULL) AND T1.setCode IN (SELECT T2.setCode FROM sets AS T2 WHERE T2.name = 'Coldsnap')",
        "compiler_hint": "no such column: T2.setCode",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of \"T2.setCode\" instead of \"T2.code\" in the subquery. The corrected SQL query uses \"T2.code\" which is the correct column name in the \"sets\" table. To avoid making the same mistake in the future, always double-check the column names in your database schema and ensure that you are using the correct column names in your SQL queries. A good practice is to refer to the schema documentation or use the \"DESCRIBE\" statement to list the columns of a table before writing the query.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.power = '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
        "error_sql": "SELECT T2.text FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.setCode = 'Coldsnap' AND T2.language = 'Italian'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
        "error_sql": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T1.language = 'Italian' AND T2.setCode = 'Coldsnap' ORDER BY T2.convertedManaCost DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "difficulty": "moderate"
    },
    {
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "hint": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
        "error_sql": "SELECT T1.format, T2.name FROM (SELECT format, COUNT(*) AS BannedCount FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY BannedCount DESC LIMIT 1) AS T1 JOIN legalities AS T2 ON T1.format = T2.format JOIN cards AS T3 ON T2.uuid = T3.uuid WHERE T2.status = 'Banned'",
        "compiler_hint": "no such column: T2.name",
        "reflective_cot": "The error in the initial SQL query was due to the incorrect reference of the column \"name\" in table T2. The column \"name\" is not present in the \"legalities\" table, but in the \"cards\" table. This mistake was corrected by joining the \"cards\" table (alias T3) and referencing the correct column \"name\" from T3.\n\nTo avoid such errors in the future, always check the schema of your database to ensure you are referencing the correct table and column names. A good practice is to write down the tables and columns you plan to use before writing the SQL query, which can help you catch such mistakes early on.\n\nTip: Always consult the database schema when writing SQL queries, especially when joining multiple tables, to ensure you are using the correct table and column names.",
        "ground_truth_sql": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "difficulty": "moderate"
    },
    {
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "hint": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format",
        "error_sql": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.set = (SELECT code FROM sets WHERE name = 'Hour of Devastation') AND T2.status = 'Legal' GROUP BY T2.format",
        "compiler_hint": "near \"set\": syntax error",
        "reflective_cot": "The error in the original SQL query was caused by using the \"IN\" keyword instead of \"=\" when comparing a single value. The corrected SQL query uses the \"=\" operator to correctly compare the set code with the desired set name. To avoid similar mistakes in the future, always ensure that you use the correct comparison operator based on the number of values being compared. If comparing to a single value, use \"=\", and if comparing to a list of values, use \"IN\".",
        "ground_truth_sql": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "difficulty": "challenging"
    },
    {
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "hint": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
        "error_sql": "SELECT T1.name FROM sets AS T1 LEFT JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Korean' AND NOT EXISTS(SELECT * FROM set_translations WHERE setCode = T1.code AND language = 'Japanese') GROUP BY T1.name HAVING COUNT(T2.id) > 0",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "difficulty": "moderate"
    },
    {
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "hint": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
        "error_sql": "SELECT DISTINCT T1.frameVersion, T1.artist, T2.status FROM cards AS T1 JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams' AND T2.status = 'Banned'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "hint": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
        "error_sql": "SELECT AVG(CASE WHEN T1.element = 'o' THEN 1 ELSE 0 END) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T3.bond_type = '-'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "difficulty": "moderate"
    },
    {
        "question": "On average how many carcinogenic molecules are single bonded?",
        "hint": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T3.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id INNER JOIN molecule AS T4 ON T1.molecule_id = T4.molecule_id WHERE T4.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "difficulty": "challenging"
    },
    {
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "hint": "triple-bonded molecules refers to bond_type = '#'; carcinogenic refers to label = '+'",
        "error_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of carbon in double-bond molecules?",
        "hint": "carbon refers to element = 'c'; double-bond molecules refers to bond_type = '='; percentage = DIVIDE(SUM(element = 'c'), COUNT(atom_id))",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.element = 'c' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T3.bond_type = '='",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
        "difficulty": "moderate"
    },
    {
        "question": "What elements are in a double type bond?",
        "hint": "double type bond refers to bond_type = '=';",
        "error_sql": "SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '='",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "difficulty": "challenging"
    },
    {
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "hint": "with hydrogen refers to element = 'h'; label most numerous in atoms refers to MAX(COUNT(label)); ",
        "error_sql": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'H' GROUP BY T2.label ORDER BY COUNT(T1.atom_id) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "difficulty": "moderate"
    },
    {
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "hint": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE (T1.element = 'i' OR T1.element = 's') AND T3.bond_type = '-'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "hint": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.element = 'f' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "hint": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.bond_type = '#' THEN 1 ELSE 0 END) * 100 / COUNT(T2.bond_id) AS REAL) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "difficulty": "challenging"
    },
    {
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "hint": "TR000 is the molecule id;",
        "error_sql": "SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "hint": "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.bond_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR008'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "hint": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id) FROM molecule AS T1 WHERE T1.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "difficulty": "simple"
    },
    {
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "hint": "hydrogen refers to element = 'h'; TR206 is the molecule id; percentage = DIVIDE(SUM(element = 'h'), COUNT(atom_id)) as percent where molecule_id = 'TR206'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.element = 'H' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 WHERE T1.molecule_id = 'TR206'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
        "difficulty": "moderate"
    },
    {
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "hint": "label = '-' means molecules are not carcinogenic; single type bond refers to bond_type = '-'; list top three molecules refers to return molecule_id and order by molecule_id;",
        "error_sql": "SELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id IN (SELECT T2.molecule_id FROM bond AS T2 WHERE T2.bond_type = '-' GROUP BY T2.molecule_id HAVING COUNT(T2.bond_id) = 1) AND T1.label = '-' ORDER BY T1.label LIMIT 3",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
        "difficulty": "moderate"
    },
    {
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "hint": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
        "error_sql": "SELECT COUNT(*) FROM connected WHERE (atom_id = 'TR009_12' OR atom_id2 = 'TR009_12') AND EXISTS (SELECT 1 FROM atom WHERE atom_id = connected.atom_id AND molecule_id = 'TR009' OR atom_id2 = connected.atom_id2 AND molecule_id = 'TR009')",
        "compiler_hint": "no such column: molecule_id",
        "reflective_cot": "The error in the initial SQL query was due to the incorrect use of the 'molecule_id' column in the 'connected' table. The 'molecule_id' is not a column in the 'connected' table but is referenced through foreign keys in the 'atom' and 'bond' tables. To correct this, the query should include a subquery that checks for the existence of the 'molecule_id' in the 'atom' table related to the 'connected' table.\n\nTo avoid making the same mistake in the future, always check the schema of the database and ensure that the columns you are referencing in your query actually exist in the tables you are querying. In this case, understanding the relationships between the 'connected', 'atom', and 'molecule' tables would have prevented the error. When joining tables, always verify the foreign key relationships and join conditions to ensure they are correct and based on existing columns.",
        "ground_truth_sql": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' OR T2.atom_id2 = T1.molecule_id || '_2'",
        "difficulty": "moderate"
    },
    {
        "question": "How many connections does the atom 19 have?",
        "hint": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
        "error_sql": "SELECT COUNT(*) FROM connected WHERE atom_id = 'TR%_19' OR atom_id2 = 'TR%_19'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "difficulty": "simple"
    },
    {
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "hint": "atoms from 21 to 25 refers to SUBSTR(atom_id, 7, 2) between '21' and '25'; label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT DISTINCT T1.label FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T2.atom_id, 7, 2) BETWEEN '21' AND '25' AND T1.label = '+'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "hint": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = ' = ' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_id) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "hint": "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'",
        "error_sql": "SELECT AVG(COUNT(T2.bond_id)) FROM (SELECT COUNT(T2.bond_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T1.element = 'I' GROUP BY T1.atom_id) AS subquery",
        "compiler_hint": "no such column: bond_id",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of the COUNT function inside the SELECT statement. The COUNT function should not be used directly in the SELECT statement when calculating averages. Instead, the subquery should first calculate the count of bond_ids for each atom_id, and then the outer SELECT statement should calculate the average of these counts. To avoid this mistake in the future, remember that when calculating averages, you should first perform the necessary aggregations at the subquery level and then use the outer SELECT statement to calculate the average. Always double-check the use of functions like COUNT, AVG, SUM, etc., to ensure they are applied correctly in the context of your query.",
        "ground_truth_sql": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "difficulty": "moderate"
    },
    {
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "hint": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
        "error_sql": "SELECT atom_id FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected) AND atom_id NOT IN (SELECT atom_id2 FROM connected)",
        "compiler_hint": "no such column: atom_id2",
        "reflective_cot": "The error in the original SQL query was due to referencing \"atom_id2\" in the WHERE clause, which is not a valid column in the \"atom\" table. The corrected SQL query uses a single SELECT statement with a logical AND to ensure that the atom_id is not present in either atom_id or atom_id2 columns of the connected table. To avoid such errors in the future, always double-check the column names and ensure they exist in the referenced table before using them in the query.",
        "ground_truth_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "difficulty": "challenging"
    },
    {
        "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
        "hint": "TR041 is the molecule id; triple bond refers to bond_type = '#';",
        "error_sql": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T1.molecule_id = 'TR041'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
        "difficulty": "simple"
    },
    {
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "hint": "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T2.bond_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "hint": "triple bond refers to bond_type = '#'; phosphorus refers to element = 'p'; bromine refers to element = 'br'",
        "error_sql": "SELECT COUNT(*) FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id JOIN connected AS T3 ON T1.atom_id = T3.atom_id JOIN connected AS T4 ON T3.bond_id = T4.bond_id AND T3.atom_id2 = T4.atom_id2 WHERE (T1.element = 'p' OR T1.element = 'br') AND T2.bond_type = '#'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "difficulty": "moderate"
    },
    {
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "hint": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.element = 'cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T3.bond_type = '-'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "difficulty": "challenging"
    },
    {
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "hint": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
        "error_sql": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, 7, 1) = '4'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "difficulty": "challenging"
    },
    {
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "hint": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "error_sql": "SELECT T1.label, CAST(SUM(CASE WHEN T2.element = 'h' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.element) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR006'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "difficulty": "challenging"
    },
    {
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "hint": "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
        "error_sql": "SELECT T1.label FROM molecule AS T1 JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "difficulty": "moderate"
    },
    {
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "hint": "Valid charter number means the number is not null",
        "error_sql": "SELECT T2.CharterNum FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrWrite > 499 AND T2.Charter IS NOT NULL ORDER BY T1.AvgScrWrite DESC",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "difficulty": "simple"
    },
    {
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "hint": "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT T1.School, T1.Street, T1.City, T1.Zip, T1.State FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "difficulty": "moderate"
    },
    {
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "hint": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
        "error_sql": "SELECT T3.School FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds INNER JOIN schools AS T3 ON T1.CDSCode = T3.CDSCode WHERE T1.`Percent (%) Eligible Free (K-12)` > 0.1 AND T2.NumGE1500 >= 1500",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "difficulty": "moderate"
    },
    {
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "hint": "Average of average math = sum(average math scores) / count(schools).",
        "error_sql": "SELECT T1.FundingType FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.County = 'Riverside' AND T2.AvgScrMath > 400 GROUP BY T1.FundingType",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "difficulty": "moderate"
    },
    {
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "hint": "Full communication address should include Street, City, State and zip code if any.",
        "error_sql": "SELECT T1.School, T1.Street, T1.City, T1.State, T1.Zip FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`County Name` = 'Monterey' AND T2.`FRPM Count (Ages 15-17)` > 800 AND T1.School LIKE '%High%'",
        "compiler_hint": "no such column: T2.Percent (%) Eligible FRPM (Ages 15-17)",
        "reflective_cot": "The error in the original SQL query was due to a misunderstanding of the column name in the database schema. The column name in the schema is `FRPM Count (Ages 5-17)` and not `Percent (%) Eligible FRPM (Ages 15-17)`. This mistake can be avoided by carefully reading and understanding the schema of the database before writing the SQL query. A concise tip to avoid making the same mistake in the future is to always refer to the schema of the database while writing SQL queries and to double-check the column names before using them in the query.",
        "ground_truth_sql": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "hint": "Communication number refers to phone number.",
        "error_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.OpenDate > '1991-01-01' OR T2.ClosedDate < '2000-01-01' AND T1.AvgScrWrite IS NOT NULL",
        "compiler_hint": "no such column: T1.School",
        "reflective_cot": "The error occurred because the column 'School' was referenced from the wrong table. In the original query, 'T1.School' was used, but 'School' is a column in the 'schools' table, which is 'T2' in the query. The corrected query uses 'T2.School', which is correct. To avoid such errors in the future, always check the table aliases and column names carefully when writing JOIN queries. Make sure to reference columns from the correct table alias.",
        "ground_truth_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "difficulty": "moderate"
    },
    {
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "hint": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT T1.School, T1.DOCType FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.FundingType = 'Local' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(`Enrollment (K-12)` - `Enrollment (Ages 5-17)`) FROM frpm WHERE FundingType = 'Local')",
        "compiler_hint": "no such column: T1.School",
        "reflective_cot": "The error in the original SQL query was due to referencing the school name directly from table T1 (frpm), which does not contain the school name. The school name is stored in table T2 (schools), and it should have been accessed through the join condition. To avoid such mistakes in the future, always check the schema and ensure that the column you are referencing exists in the table you are querying. In this case, using T2.School instead of T1.School would have resolved the issue.",
        "ground_truth_sql": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "difficulty": "challenging"
    },
    {
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "hint": "K-12 refers to students in grades 1 through 12; Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT T1.`Percent (%) Eligible Free (K-12)` FROM frpm AS T1 INNER JOIN (SELECT CDSCode FROM schools ORDER BY `Enrollment (K-12)` DESC LIMIT 10, 2) AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Enrollment (K-12)` IS NOT NULL",
        "compiler_hint": "no such column: Enrollment (K-12)",
        "reflective_cot": "The error encountered in the SQL query was due to referencing a column that does not exist in the joined table. The column `Enrollment (K-12)` is in the `frpm` table, not the `schools` table. To avoid this mistake in the future, always ensure that the columns you reference in your JOIN conditions and SELECT statements exist in the tables you are querying. A good practice is to alias tables and use the table alias when referencing columns to make it clear which table the column belongs to. This helps prevent errors and makes your queries more readable.",
        "ground_truth_sql": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "difficulty": "moderate"
    },
    {
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "hint": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT T2.`Percent (%) Eligible FRPM (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.ownership_code = '66' ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "compiler_hint": "no such column: T2.Percent (%) Eligible FRPM (K-12)",
        "reflective_cot": "The error in the original SQL query was due to referencing a column that does not exist in the table. The column `Percent (%) Eligible FRPM (K-12)` was used directly in the SELECT statement, but it is not a column in the database. Instead, it's a calculation that needs to be performed using the `FRPM Count (K-12)` and `Enrollment (K-12)` columns.\n\nTo avoid this mistake in the future, always refer to the schema of the database to ensure that the column names you are using in your SQL queries actually exist. When a calculation is required, perform the calculation using the appropriate columns rather than referencing a non-existent column.\n\nCorrected SQL:\n```\nSELECT T1.`FRPM Count (K-12)` / T1.`Enrollment (K-12)` AS `Eligible FRPM Rate` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.ownership_code = '66' ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5\n```",
        "ground_truth_sql": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "hint": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
        "error_sql": "SELECT T2.Street, T2.City, T2.Zip, T2.State FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr != 0 AND T1.NumGE1500 / T1.NumTstTakr = (SELECT MIN(NumGE1500 / NumTstTakr) FROM satscores WHERE NumTstTakr != 0)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "hint": "between 1/1/1980 and 12/31/1980 means the year = 1980",
        "error_sql": "SELECT AVG(T2.NumTstTakr) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.OpenDate BETWEEN '1980-01-01' AND '1980-12-31' AND T1.City = 'Fresno'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T2.County = 'Fresno'",
        "difficulty": "simple"
    },
    {
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "hint": "Fresno Unified is a name of district;",
        "error_sql": "SELECT T3.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode INNER JOIN frpm AS T3 ON T2.CDSCode = T3.CDSCode WHERE T2.District = 'Fresno Unified' ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "compiler_hint": "no such column: T3.Phone",
        "reflective_cot": "The error occurred because the column 'Phone' was referenced as 'T3.Phone', which is incorrect since 'Phone' is a column in the 'schools' table (T2), not in the 'frpm' table (T3). The correct reference should be 'T2.Phone'. To avoid such mistakes in the future, always ensure that you reference the correct table when accessing a column in a SQL query, especially when dealing with multiple table joins. This can be done by double-checking the table structure and column names before finalizing the query.",
        "ground_truth_sql": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "hint": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
        "error_sql": "SELECT T1.School FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.Virtual = 'F' AND T2.AvgScrRead IN (SELECT AVG(AvgScrRead) FROM satscores GROUP BY County ORDER BY AVG(AvgScrRead) DESC LIMIT 5) GROUP BY T1.County, T1.School ORDER BY AVG(T2.AvgScrRead) DESC LIMIT 5",
        "compiler_hint": "near \"BY\": syntax error",
        "reflective_cot": "The error in the SQL query was caused by the incorrect use of the PARTITION BY clause. The correct clause to use in this context is GROUP BY. The PARTITION BY clause is used in window functions, not in subqueries for calculating aggregated values. To avoid making the same mistake in the future, remember that PARTITION BY is used for window functions, while GROUP BY is used for aggregations. Always double-check the context in which you are using these clauses to ensure they are appropriate for the operation you are performing.",
        "ground_truth_sql": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "difficulty": "simple"
    },
    {
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "hint": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
        "error_sql": "SELECT T1.State FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.DOC = '31' AND T2.`Enrollment (K-12)` IS NOT NULL ORDER BY T2.`Enrollment (K-12)` DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "hint": "Elementary School District refers to DOC = 52; Monthly average number of schools that opened in 1980 = count(schools that opened in 1980) / 12",
        "error_sql": "SELECT CAST(COUNT(T1.CDSCode) AS REAL) / 12 FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE strftime('%Y', T2.OpenDate) = '1980' AND T1.County = 'Alameda' AND T2.DOC = '52'",
        "compiler_hint": "no such column: T2.OpenDate",
        "reflective_cot": "The error in the initial SQL query was due to the incorrect reference to the 'OpenDate' column in table 'frpm'. The 'OpenDate' is a date type column, and the 'LIKE' operator was used incorrectly to filter the year '1980'. The correct approach is to use the 'strftime' function to extract the year from the 'OpenDate' column and compare it with '1980'. To avoid such errors in the future, always check the data types of the columns you are working with and use appropriate functions or operators based on the data type. For date columns, use date functions like 'strftime' to extract specific parts of the date for filtering.",
        "ground_truth_sql": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "hint": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.DOC = 52 THEN 1 ELSE 0 END) FROM schools AS T1 WHERE T1.County = 'Orange' AND (T1.DOC = 52 OR T1.DOC = 54)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
        "hint": "Postal street and mailing street are synonyms.",
        "error_sql": "SELECT T1.Street FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrMath IN (SELECT AVG(AvgScrMath) FROM satscores ORDER BY AvgScrMath DESC LIMIT 6, 1)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "hint": "non-chartered schools refer to schools whose Charter = 0; K-12 means grades 1 through 12; percent of eligible free rate for K-12 = `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)`",
        "error_sql": "SELECT COUNT(*) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Charter School (Y/N)` = 0 AND `Percent (%) Eligible Free (K-12)` < 0.18",
        "compiler_hint": "no such column: Charter",
        "reflective_cot": "The error in the original SQL query was due to a mismatch in column names. The query was looking for a column named 'Charter', but the correct column name in the database is 'Charter School (Y/N)'. To avoid such mistakes in the future, always refer to the database schema or use the information_schema.columns view to confirm column names before writing queries. This ensures that the column names used in the SQL match those in the database, preventing syntax errors.",
        "ground_truth_sql": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "difficulty": "challenging"
    },
    {
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "hint": "State Special School means EdOpsCode = 'SSS'",
        "error_sql": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.School = 'State Special School' AND T1.`Academic Year` = '2014-2015' AND T2.City = 'Fremont' AND T2.EILCode = 'SSS'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "difficulty": "moderate"
    },
    {
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "hint": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
        "error_sql": "SELECT T2.School, T1.`Percent (%) Eligible FRPM (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`County Name` = 'Los Angeles' AND T1.`Low Grade` = 'Kindergarten' AND T1.`High Grade` = '9'",
        "compiler_hint": "no such column: T1.School",
        "reflective_cot": "The error in the original SQL query was due to attempting to select the 'School' column from the 'frpm' table, which doesn't exist in that table. The 'School' column is in the 'schools' table, hence it should be referenced as 'T2.School'. The corrected SQL query properly references the 'School' column from the 'schools' table.\n\nTip: Always check the table structure and column names before writing your SQL query. Make sure you are selecting columns from the correct tables. This can be done by referring to the database schema or using the 'DESCRIBE' command in SQL to view the table structure. This will help prevent errors due to incorrect table or column references. Additionally, when joining tables, always ensure that the columns you are referencing are present in the correct tables.",
        "ground_truth_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "difficulty": "moderate"
    },
    {
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "hint": "'Does not offer physical building' means Virtual = F in the database.",
        "error_sql": "SELECT T1.County, COUNT(T1.County) FROM schools AS T1 INNER JOIN ( SELECT County FROM schools WHERE Virtual = 'F' GROUP BY County ) AS T2 ON T1.County = T2.County WHERE T1.County IN ('San Diego', 'Santa Barbara') GROUP BY T1.County ORDER BY COUNT(T1.County) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the grade span offered in the school with the highest longitude?",
        "hint": "the highest longitude refers to the school with the maximum absolute longitude value.",
        "error_sql": "SELECT GSoffered FROM schools WHERE ABS(Longitude) = (SELECT MAX(ABS(Longitude)) FROM schools)",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "hint": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
        "error_sql": "SELECT COUNT(*) AS School_Count, City, COUNT(*) AS School_Number FROM schools WHERE GSserved = 'K-8' AND Magnet = 1 AND `NSLP Provision Status` = 'Multiple Provision Types' GROUP BY City ORDER BY School_Number DESC LIMIT 10",
        "compiler_hint": "SELECTs to the left and right of UNION do not have the same number of result columns",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of UNION to combine queries with different numbers of columns. To avoid this mistake in the future, remember that UNION can only be used to combine queries that have the same number of columns and compatible data types. Instead of UNION, use subqueries or join the tables if necessary to ensure the queries are compatible. In this case, the corrected SQL query uses a single SELECT statement with grouping and aggregation to provide the required information without the need for UNION.",
        "ground_truth_sql": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "difficulty": "challenging"
    },
    {
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "hint": "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
        "error_sql": "SELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "difficulty": "moderate"
    },
    {
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "hint": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
        "error_sql": "SELECT AdmEmail1, AdmEmail2, AdmEmail3 FROM schools WHERE County = 'San Bernardino' AND City = 'San Bernardino' AND School LIKE '%City Unified%' AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND (SOC = '62' OR DOC = '54') AND AdmEmail1 IS NOT NULL OR AdmEmail2 IS NOT NULL OR AdmEmail3 IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "difficulty": "challenging"
    },
    {
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "hint": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
        "error_sql": "SELECT COUNT(*) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'East Bohemia' AND T1.frequency = 'POPLATEK PO OBRATU'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "difficulty": "moderate"
    },
    {
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "hint": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
        "error_sql": "SELECT COUNT(*) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'North Bohemia' AND T2.A11 > 8000",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "difficulty": "moderate"
    },
    {
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "hint": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
        "error_sql": "SELECT (SELECT AVG(T1.A11) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND T2.birth_date = (SELECT MIN(T3.birth_date) FROM client AS T3 WHERE T3.gender = 'F') ORDER BY AVG(T1.A11) ASC LIMIT 1) - (SELECT AVG(T1.A11) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND T2.birth_date = (SELECT MIN(T3.birth_date) FROM client AS T3 WHERE T3.gender = 'F') ORDER BY AVG(T1.A11) DESC LIMIT 1) AS gap",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "hint": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.birth_date = (SELECT MIN(T3.birth_date) FROM client AS T3 INNER JOIN disp AS T2 ON T3.client_id = T2.client_id INNER JOIN account AS T1 ON T2.account_id = T1.account_id) AND T1.A11 = (SELECT MAX(T1.A11) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id) GROUP BY T1.account_id ORDER BY AVG(T1.A11) DESC LIMIT 1",
        "compiler_hint": "no such column: T1.client_id",
        "reflective_cot": "The error in the initial SQL query was due to the incorrect reference of the client_id column in the account table, which doesn't exist. The corrected SQL query properly joins the account, disp, and client tables to reference the client_id correctly. To avoid such mistakes in the future, always check the schema of the database to ensure you are referencing the correct columns and tables. A good practice is to write down the tables and columns you need before writing the query to ensure you have a clear understanding of the database schema.",
        "ground_truth_sql": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "difficulty": "moderate"
    },
    {
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "hint": "'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1997-01-01' AND T2.amount = ( SELECT MIN(amount) FROM loan WHERE date = '1997-01-01' ) AND T1.frequency = 'POPLATEK TYDNE'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "hint": "Loan validity more than 12 months refers to duration > 12",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration > 12 AND T2.amount = (SELECT MAX(amount) FROM loan WHERE duration > 12) AND T1.date = '1993-01-01'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "hint": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'South Bohemia' AND T2.A4 = (SELECT MAX(A4) FROM district WHERE A3 = 'South Bohemia')",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "hint": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
        "error_sql": "SELECT CAST((T1.balance - T2.balance) AS REAL) * 100 / T2.balance FROM trans AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T1.date = '1998-12-27' AND T2.date = '1993-03-22' AND T1.account_id = ( SELECT account_id FROM loan WHERE date = '1993-07-05' AND status = 'approved' ORDER BY date ASC LIMIT 1 )",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "hint": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.status = 'A' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.status = 'A'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "difficulty": "moderate"
    },
    {
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "hint": "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100.",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.loan_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.amount < 100000",
        "compiler_hint": "no such column: T2.status",
        "reflective_cot": "The error in the SQL query was due to referencing the status column as \"T2.status,\" which does not exist in the account table. The status column is actually in the loan table. To avoid this mistake in the future, always double-check the column names and their respective tables when writing JOIN conditions and filtering criteria. Ensure that you reference the correct table aliases when using column names that are not unique across the joined tables.",
        "ground_truth_sql": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "difficulty": "moderate"
    },
    {
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "hint": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
        "error_sql": "SELECT T3.A2, ((T3.A13 - T3.A12) / T3.A12) * 100 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D' AND T2.client_id IN (SELECT client_id FROM client WHERE gender = 'M')",
        "compiler_hint": "no such column: T2.client_id",
        "reflective_cot": "The error \"no such column: T2.client_id\" occurred because the SQL query tried to access the client_id column directly from the T2 table, which is the account table and does not have a client_id column. The corrected SQL query uses a subquery to get the client_id from the client table, which is then used to filter the account table. To avoid this mistake in the future, always check the table schema and ensure you are referencing the correct columns from the correct tables. When joining tables, make sure to join them correctly based on the common columns, and use subqueries or additional joins if necessary to access columns from other tables.",
        "ground_truth_sql": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "difficulty": "challenging"
    },
    {
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "hint": "A2 refers to districts; Female refers to gender = 'F'",
        "error_sql": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' GROUP BY T1.A2 ORDER BY COUNT(T2.client_id) DESC LIMIT 9",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
        "difficulty": "moderate"
    },
    {
        "question": "How many accounts have running contracts in Branch location 1?",
        "hint": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "error_sql": "SELECT COUNT(*) FROM account WHERE district_id = 1 AND frequency = 'C'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "difficulty": "moderate"
    },
    {
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "hint": "Male refers to gender = 'M'; A15 stands for no. of commited crimes 1995",
        "error_sql": "SELECT COUNT(*) FROM client WHERE gender = 'M' AND district_id = (SELECT district_id FROM district WHERE A15 = (SELECT MAX(A15) FROM district ORDER BY A15 DESC LIMIT 1 OFFSET 1))",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "difficulty": "moderate"
    },
    {
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "hint": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
        "error_sql": "SELECT T2.A2 FROM trans AS T1 INNER JOIN district AS T2 ON T1.account_id = T2.district_id WHERE T1.type = 'VYDAJ' AND T1.date LIKE '1996-01%' ORDER BY T1.amount DESC LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "How many accounts have running contracts in Branch location 1?",
        "hint": "Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "error_sql": "SELECT COUNT(*) FROM account WHERE account_id IN (SELECT account_id FROM disp WHERE district_id = 1 AND type = 'C')",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "hint": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.operation = 'VYBER KARTOU' AND T2.amount < (SELECT AVG(amount) FROM trans WHERE operation = 'VYBER KARTOU') AND T2.date LIKE '1998%'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "hint": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
        "error_sql": "SELECT DISTINCT T1.type FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.type != 'OWNER' AND T2.A11 BETWEEN 8000 AND 9000",
        "compiler_hint": "no such column: T1.type",
        "reflective_cot": "The error in the original SQL query was due to the incorrect reference to the 'type' column in the account table. The error message \"no such column: T1.type\" indicates that the 'type' column does not exist in the account table. This is because the 'type' column is actually in the disp table, not the account table. To avoid this mistake in the future, always double-check the schema of the database and ensure that you are referencing the correct table and column names in your SQL queries. A good practice is to write down the schema of the database and the column names before writing the SQL query to avoid such errors.",
        "ground_truth_sql": "SELECT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "difficulty": "challenging"
    },
    {
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "hint": "operation = 'VYBER' refers to withdrawal in cash",
        "error_sql": "SELECT * FROM trans WHERE operation = 'VYBER' AND account_id = 3356",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "difficulty": "simple"
    },
    {
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "hint": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
        "error_sql": "SELECT CAST((SUM(CASE WHEN strftime('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN strftime('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M'",
        "compiler_hint": "no such column: T2.client_id",
        "reflective_cot": "The error in the original SQL query was due to a misunderstanding of the table relationships. The error message \"no such column: T2.client_id\" indicates that the query tried to access the client_id column from the account table (T2), but this column does not exist in that table. The client_id is actually in the client table (T3). To fix this, we need to join the client table correctly and reference the client_id from the correct table (T3) in the WHERE clause.\n\nThe corrected SQL query properly joins the loan, account, and client tables and uses the correct table alias (T3) to reference the client_id column in the WHERE clause.\n\nTo avoid making the same mistake in the future, always double-check the table relationships and column names when writing SQL queries. Make sure to use the correct table aliases and column names as they appear in the database schema. This can be done by referring to the database schema or using the information_schema tables to get a list of all tables and columns in the database.",
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "difficulty": "challenging"
    },
    {
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "hint": "k_symbol refers to the purpose of payments",
        "error_sql": "SELECT T1.frequency , SUM(T3.amount) FROM account AS T1 INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE T1.account_id = 3 AND T3.k_symbol = 'account_statement' AND T3.amount = 3539",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "hint": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE'",
        "compiler_hint": "no such column: T2.client_id",
        "reflective_cot": "The error in the original SQL query was due to the incorrect use of the client_id to join the account table directly. The client and account tables are not directly related; they are connected through the disp table. By joining the disp table first and then the account table, the correct relationship between the tables is established. To avoid similar mistakes in the future, always verify the relationships between tables in the schema and join them accordingly. Use the foreign key relationships provided in the schema to guide your joins.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "hint": "Female refers to 'F' in the gender; A11 contains information about average salary",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id WHERE T2.gender = 'F' GROUP BY T1.account_id ORDER BY AVG(T2.A11) ASC LIMIT 1",
        "compiler_hint": "no such column: T1.client_id",
        "reflective_cot": "The error in the SQL query was due to referencing a non-existent column, T1.client_id. The correct way to join the account and client tables is by using the account_id and client_id columns directly without prefixing them with the table alias. To avoid this mistake in the future, always double-check the column names and aliases when writing JOIN conditions and ensure that you are referencing the correct columns.",
        "ground_truth_sql": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average amount of loan which are still on running contract with statement issuance after each transaction?",
        "hint": "status = 'C' stands for running contract, OK so far; status = 'D' stands for running contract, client in debt. 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "error_sql": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T1.status = 'C' AND T2.type = 'POPLATEK PO OBRATU' UNION SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T1.status = 'D' AND T2.type = 'POPLATEK PO OBRATU'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT AVG(T2.amount) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.status IN ('C', 'D') AND T1.frequency = 'POPLATEK PO OBRATU'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "hint": "the credit card is high-level refers to card.type = 'gold'; eligible for loans refers to disp.type = 'OWNER'",
        "error_sql": "SELECT T1.client_id, T1.birth_date FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.type = 'gold' AND T2.type = 'OWNER'",
        "compiler_hint": null,
        "reflective_cot": null,
        "ground_truth_sql": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "difficulty": "moderate"
    }
]