[
    {
        "question": "List out student names that enrolled in two schools and two organizations?",
        "hint": "enrolled in two schools refers to COUNT(school) = 2; two organizations refers to COUNT(organ) = 2;",
        "error_sql": "SELECT T1.name FROM (SELECT name, COUNT(school) FROM enrolled GROUP BY name HAVING COUNT(school) = 2) T1 INNER JOIN (SELECT name, COUNT(organ) FROM enlist GROUP BY name HAVING COUNT(organ) = 2) T2 ON T1.name = T2.name",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining two tables, ensure that the join condition is correct and that the columns being joined are the correct ones. In this case, the error was due to the fact that the join was done on the count of schools and organizations, rather than the actual names of the schools and organizations. Additionally, the subqueries were not necessary, and a simple inner join with a group by and having clause would have sufficed. To avoid this mistake in the future, take the time to carefully review the join conditions and ensure that they are correct, and consider whether subqueries are truly necessary or if a simpler approach can be used.",
        "ground_truth_sql": "SELECT T.name FROM ( SELECT T1.name, COUNT(T1.organ) AS num FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name ) T WHERE T.num = 2",
        "difficulty": ""
    },
    {
        "question": "How many distinct movies in English stars a male actor who acts the best?",
        "hint": "Male actors mean that a_gender = 'M'; isEnglish = 'T' means movies in English",
        "error_sql": "SELECT COUNT(DISTINCT T1.movieid) FROM movies2actors AS T1 INNER JOIN actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T1.movieid = T3.movieid WHERE T2.a_gender = 'M' AND T3.isEnglish = 'T' AND T2.a_quality = ( SELECT MAX(a_quality) FROM actors )",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables and selecting distinct values, ensure that the column you are selecting is from the correct table and is the one you intend to count. In this case, the error was in selecting `T1.movieid` and `T3.movieid` instead of `T1.actorid` which is the correct column to count distinct male actors who act the best in English movies. Also, note that the subquery `( SELECT MAX(a_quality) FROM actors )` should be replaced with the actual maximum value `5` to get the correct result.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T3.isEnglish = 'T' AND T1.a_gender = 'M' AND T1.a_quality = 5",
        "difficulty": ""
    },
    {
        "question": "What percentage of authors of the paper about Charged particle multiplicity are affiliated with INFN?",
        "hint": "about Charged particle multiplicity refers to Title which contains 'Charged particle multiplicity'; affiliated with INFN refers to Affiliation LIKE '%INFN%' ; percentage refers to DIVIDE(COUNT(Affiliation LIKE '%INFN%' ), COUNT(AuthorId)) * 100%",
        "error_sql": "SELECT CAST(SUM(CASE WHEN Affiliation LIKE '%INFN%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Affiliation) FROM Author WHERE Id IN ( SELECT AuthorId FROM PaperAuthor WHERE PaperId IN ( SELECT Id FROM Paper WHERE Title LIKE '%Charged particle multiplicity%' ))",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join is performed on the correct tables and that the columns used for joining are the correct ones. In this case, the error was due to joining the `Author` table directly, whereas the correct approach was to join the `PaperAuthor` table with the `Paper` table, and then use the `PaperAuthor` table to count the affiliations. Additionally, when counting the total number of authors, make sure to count the `Id` column from the correct table, which in this case is the `PaperAuthor` table.",
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN T1.Affiliation LIKE '%INFN%' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T2.Id) FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T2.Title LIKE '%Charged particle multiplicity%'",
        "difficulty": ""
    },
    {
        "question": "How many cities have businesses with active life category? Find the percentage of the city where the review count that is low in total review count.",
        "hint": "category refers to category_name; percentage = MULTIPLY(DIVIDE(SUM(category_name = 'Active Life'), SUM(review_count = 'LOW')), 1.0);",
        "error_sql": "SELECT CAST(SUM(IIF(T2.category_name = 'Active Life' AND T3.review_count = 'Low', 1, 0)) AS REAL) * 100 / COUNT(T3.review_count) \nFROM Business_Categories AS T1 \nINNER JOIN Categories AS T2 \nON T1.category_id = T2.category_id\nINNER JOIN Business AS T3 \nON T1.business_id = T3.business_id",
        "compiler_hint": "no such column: T1.category_name",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that you are referencing the correct table and column names. In the initial error, the column 'category_name' was referenced from the wrong table 'T1' which is actually 'Business_Categories'. It should be referenced from 'T2' which is 'Categories'. Additionally, the subquery in the Ground Truth SQL is used to calculate the total count of 'Low' review counts, which is not present in the initial error or the SQL after reflection. To avoid making the same mistake in the future, carefully review the table and column names, and ensure that the logic of the query is correct.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.category_name LIKE 'Active Life' THEN 1 ELSE 0 END) AS \"num\" , CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) * 100 / ( SELECT COUNT(T3.review_count) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE T3.review_count LIKE 'Low' ) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id",
        "difficulty": ""
    },
    {
        "question": "Which two countries share the second highest mountain? Give the country code.",
        "hint": "",
        "error_sql": "SELECT T1.Code, T2.Code FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country INNER JOIN mountain AS T3 ON T2.Mountain = T3.Name ORDER BY T3.Height DESC LIMIT 1 OFFSET 1",
        "compiler_hint": "no such column: T2.Code",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct column is being referenced. In the Error SQL Query, the join condition was incorrect, and in the SQL after Reflection, the query was still incorrect because it was trying to return two country codes, but the question was asking for the country codes of the two countries that share the second highest mountain, which requires a different approach. The correct approach is to first find the name of the second highest mountain and then find the country codes of the countries that have this mountain.",
        "ground_truth_sql": "SELECT T1.Code FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE T2.Mountain = ( SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1, 1 )",
        "difficulty": ""
    },
    {
        "question": "Among the classic movies, how many movies have a rental rate of less than 1?",
        "hint": "classic movie refers to name = 'Classics'; rental rate of less than 1 refers to rental_rate < 1; movie refers to film_id",
        "error_sql": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN category AS T2 ON T1.film_id = T2.category_id WHERE T2.name = 'Classics' AND T1.rental_rate < 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and that the tables are joined in the correct order. In this case, the error was due to joining the `film` table directly with the `category` table, instead of joining it with the `film_category` table first, which is the correct intermediate table. Additionally, the join order was incorrect, leading to incorrect results. To avoid this mistake, carefully examine the database schema and ensure that the join conditions are correct and that the tables are joined in the correct order.",
        "ground_truth_sql": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.rental_rate < 1 AND T2.name = 'Classics'",
        "difficulty": ""
    },
    {
        "question": "Which payment method is most comonly used by the schools in the state of Georgia for the payment of donations?",
        "hint": "Georgia refer to school_state = 'GA'\n",
        "error_sql": "SELECT payment_method FROM donations WHERE projectid IN ( SELECT projectid FROM projects WHERE school_state = 'GA' ) GROUP BY payment_method ORDER BY COUNT(payment_method) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and grouping by a column, ensure that the column used in the GROUP BY clause is the one that makes sense for the query. In this case, grouping by T1.payment_method would give the count of each payment method, but it would not guarantee that the count is specific to the schools in Georgia. Grouping by T2.school_state ensures that the count of payment methods is specific to the schools in Georgia, and then the ORDER BY and LIMIT clauses can be used to find the most common payment method.",
        "ground_truth_sql": "SELECT T1.payment_method FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_state = 'GA' GROUP BY T2.school_state ORDER BY COUNT(T1.payment_method) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What ingredients does the longest cooking time recipe have?",
        "hint": "the longest cooking time refers to MAX(cook_min)",
        "error_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T2.ingredient_id = T3.ingredient_id WHERE T1.cook_min = ( SELECT MAX(cook_min) FROM Recipe )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column and then using that value to filter the results, consider whether there might be multiple rows with the same maximum or minimum value. In this case, the Error SQL Query and SQL after Reflection would return all recipes with the longest cooking time, not just one. However, the Ground Truth SQL uses ORDER BY and LIMIT to ensure that only one recipe is returned, even if there are multiple recipes with the same longest cooking time. To avoid making the same mistake in the future, always consider the possibility of multiple rows with the same value and use techniques like ORDER BY and LIMIT to ensure that the correct number of rows is returned.",
        "ground_truth_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id ORDER BY T1.cook_min DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which supplier can provide the most number of \"hot spring dodger dim light\"? Please give the supplier's phone number.",
        "hint": "the most number refers to max(ps_availqty); \"hot spring dodger dim light\" refers to p_name = 'hot spring dodger dim light'; phone number refers to s_phone",
        "error_sql": "SELECT T1.s_phone FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey INNER JOIN part AS T3 ON T2.ps_partkey = T3.p_partkey WHERE T3.p_name = 'hot spring dodger dim light' GROUP BY T1.s_phone ORDER BY COUNT(T3.p_partkey) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the columns being joined are from the correct tables. In this case, the join condition was incorrect in the Error SQL Query. The correct join condition should be based on the relationship between the tables, which is that a supplier provides a part. Therefore, the correct join condition is that the supplier's suppkey is equal to the partsupp's suppkey, and the partsupp's partkey is equal to the part's partkey. Additionally, when filtering for a specific part, ensure that the filter condition is applied to the correct table, which is the part table in this case.",
        "ground_truth_sql": "SELECT T3.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T2.ps_availqty DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which address type does \"Fun Toys and Bikes\" fall under?",
        "hint": "Fun Toys and Bikes is name of a store",
        "error_sql": "SELECT Name FROM StateProvince",
        "compiler_hint": "no such column: T2.Name",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names in the SELECT statement match the table aliases used in the JOIN clause. In this case, the error occurred because the column 'Name' was referenced with the wrong table alias 'T2', which was actually 'AddressType', not 'Store'. To avoid this mistake, double-check the table aliases and column names in the SELECT statement to ensure they match the correct tables.",
        "ground_truth_sql": "SELECT T2.Name FROM BusinessEntityAddress AS T1 INNER JOIN AddressType AS T2 ON T1.AddressTypeID = T2.AddressTypeID INNER JOIN Store AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T3.Name = 'Fun Toys and Bikes'",
        "difficulty": ""
    },
    {
        "question": "What is the average score for the movie Versailles Rive-Gauche?",
        "hint": "Versailles Rive-Gauche' is movie_title; average score refers to Avg(rating_score);",
        "error_sql": "SELECT AVG(T2.rating_score) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T1.movie_title = 'Versailles Rive-Gauche'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and selecting an aggregate value, ensure that the table alias used in the aggregate function matches the table alias used in the JOIN clause. In this case, the correct table alias for the ratings table is T1, not T2. Additionally, using LIKE instead of = for string comparison can help to avoid issues with exact matching, especially when dealing with titles that may have varying punctuation or capitalization.",
        "ground_truth_sql": "SELECT AVG(T1.rating_score) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title LIKE 'Versailles Rive-Gauche'",
        "difficulty": ""
    },
    {
        "question": "Calculate the average number of disabled female students enrolled in UCI.",
        "hint": "average = DIVIDE(SUM(disabled.name who are not in male.name WHERE school = 'uci'), COUNT(enrolled.name)); female students refers to disabled.name who are NOT in male.name; UCI refers to school = 'uci';",
        "error_sql": "SELECT AVG(T1.num) FROM ( SELECT COUNT(T2.name) AS num FROM disabled AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name INNER JOIN male AS T3 ON T1.name = T3.name WHERE T2.school = 'uci' AND T3.name IS NULL GROUP BY T1.name ) T1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating averages or performing aggregations, ensure that the subquery or join conditions accurately reflect the problem requirements. In this case, the error was due to incorrectly joining the 'male' table, which should have been a LEFT JOIN to identify females (those not in the 'male' table). Additionally, the use of IIF and CAST is necessary to accurately calculate the average, as the COUNT function returns an integer, and dividing by it would result in integer division. Always carefully review the query logic and consider the data types involved in the calculation.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.school = 'uci' AND T4.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN person AS T3 ON T1.name = T3.name LEFT JOIN male AS T4 ON T3.name = T4.name",
        "difficulty": ""
    },
    {
        "question": "List down the author ID of authors with a name of \"Peter\".",
        "hint": "\"Peter\" is the name of author",
        "error_sql": "SELECT Id FROM Author WHERE Name = \"Peter\"",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, it's essential to consider the relationships between tables and the specific columns you're interested in. In this case, the error was assuming that the `Author` table directly contains the author's name, when in fact, the `PaperAuthor` table contains the author's name and ID. To avoid this mistake, always review the database schema and consider the relationships between tables before writing a query. Additionally, be cautious when using quotes, as SQL uses single quotes for string literals, not double quotes.",
        "ground_truth_sql": "SELECT AuthorId FROM PaperAuthor WHERE Name = 'Peter'",
        "difficulty": ""
    },
    {
        "question": "Among the patients with viral sinusitis condition, which patient's gender is most affected? Provide the number for each respectively.",
        "hint": "viral sinusitis condition refers to conditions.DESCRIPTION = 'Viral sinusitis (disorder)'; gender that is most affected refers to MAX(COUNT(gender WHERE conditions.DESCRIPTION = 'Viral sinusitis (disorder)'));",
        "error_sql": "SELECT T.gender, COUNT(T.gender) FROM ( SELECT T1.gender FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)' ) T GROUP BY T.gender ORDER BY COUNT(T.gender) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating data based on specific conditions, consider using conditional aggregation (e.g., `SUM(CASE WHEN ... THEN 1 ELSE 0 END)`) instead of grouping and counting, especially when you need to count occurrences of specific values within a group. This approach allows for more flexibility and can help avoid incorrect results due to grouping or counting issues.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END), SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "List out full name and email of employees who are working in Paris?",
        "hint": "full name = firstName+LastName; Paris is a city;",
        "error_sql": "SELECT T1.firstName || ' ' || T1.lastName, T1.email FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T2.city = 'Paris'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that the SELECT clause accurately reflects the desired output. In this case, the full name was requested, but the correct approach is to return the first name and last name as separate columns, rather than concatenating them. This allows for greater flexibility in handling the output data.",
        "ground_truth_sql": "SELECT T1.firstName, T1.lastName, T1.email FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T2.city = 'Paris'",
        "difficulty": ""
    },
    {
        "question": "Which flight carrier operator flies from Atlantic City to Fort Lauderdale?",
        "hint": "flight carrier operator refers to OP_CARRIER_AIRLINE_ID; from Atlantic City refers to ORIGIN = 'ACY'; to Fort Lauderdale refers to DEST = 'FLL';",
        "error_sql": "SELECT OP_CARRIER_AIRLINE_ID FROM Airlines WHERE ORIGIN = 'ACY' AND DEST = 'FLL'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and filtering data, consider the potential for multiple results and whether aggregation or grouping is necessary to accurately represent the data. In this case, the initial query and the revised query after reflection both returned multiple potential carriers, but the ground truth query correctly accounted for this by grouping the results by carrier description. To avoid similar mistakes in the future, always consider the potential for multiple results and whether aggregation or grouping is necessary to accurately represent the data.",
        "ground_truth_sql": "SELECT T2.Description FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T1.ORIGIN = 'ACY' AND T1.DEST = 'FLL' GROUP BY T2.Description",
        "difficulty": ""
    },
    {
        "question": "What is the first name of the driver who transported shipment id 1028?",
        "hint": "shipment id 1028 refers to ship_id = 1028",
        "error_sql": "SELECT T1.first_name FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id WHERE T2.ship_id = 1028",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the alias used in the SELECT statement matches the alias used in the JOIN clause. In the Error SQL Query, the alias 'T1' was used for the 'driver' table in the SELECT statement, but 'T1' was actually used for the 'shipment' table in the JOIN clause. Similarly, in the SQL after Reflection, the alias 'T2' was used for the 'driver' table in the SELECT statement, but 'T2' was actually used for the 'driver' table in the JOIN clause, however, the query was still incorrect because it only returned the 'first_name' instead of both 'first_name' and 'last_name'. To avoid this mistake, double-check the aliases used in the SELECT statement and the JOIN clause to ensure they match.",
        "ground_truth_sql": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = 1028",
        "difficulty": ""
    },
    {
        "question": "How many trips which subscription types were Subscriber and ended in San Jose city?",
        "hint": "ended in refers to end_station_name;",
        "error_sql": "SELECT COUNT(T1.id) FROM trip AS T1 INNER JOIN station AS T2 ON T1.end_station_id = T2.id WHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is based on the correct columns. In this case, the error occurred because the join was done on `end_station_id` instead of `end_station_name`. To avoid this mistake, carefully examine the schema of the tables involved and verify that the join condition is correct. Additionally, consider using the `ON` clause with the correct column names, and also consider using the `USING` clause if the column names are the same in both tables.",
        "ground_truth_sql": "SELECT COUNT(T1.subscription_type) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'",
        "difficulty": ""
    },
    {
        "question": "For each donation not from a teacher, state the donor account id and calculate the percentage of donation given for optional support.",
        "hint": "not from a teacher refers to is_teacher_acct = 'f'; donor account id refers to donor_acctid; percentage of donation = divide(donation_optional_support, donation_total)*100%",
        "error_sql": "SELECT donor_acctid, CAST(donation_optional_support AS REAL) * 100 / donation_total FROM donations WHERE is_teacher_acct = 'f'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating percentages, ensure that the division is performed correctly and that the result is not multiplied by 100 unnecessarily. In SQLite, the division of two integers results in an integer, so it's essential to cast at least one of the operands to a REAL type to get a decimal result. However, in this case, the percentage calculation is not required as the problem only asks for the percentage of donation given for optional support, which can be represented as a decimal value. Therefore, simply dividing donation_optional_support by donation_total is sufficient.",
        "ground_truth_sql": "SELECT donor_acctid, donation_optional_support / donation_total FROM donations WHERE is_teacher_acct = 'f'",
        "difficulty": ""
    },
    {
        "question": "What is the average rating of inactive businesses?",
        "hint": "rating refers to stars; inactive refers to active = 'False'; average rating of inactive businesses = DIVIDE(SUM(stars), COUNT(business_id));",
        "error_sql": "SELECT CAST(SUM(stars) AS REAL) / COUNT(business_id) FROM Business WHERE active = 'False'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen comparing string values in SQL, it's generally safer to use the LIKE operator instead of the equals operator (=) to account for potential case differences or leading/trailing whitespace. In this case, the 'active' column might contain 'FALSE' (uppercase) instead of 'False' (mixed case), so using LIKE 'FALSE' ensures the query works correctly regardless of the case.",
        "ground_truth_sql": "SELECT CAST(SUM(stars) AS REAL) / COUNT(business_id) AS \"average\" FROM Business WHERE active LIKE 'FALSE'",
        "difficulty": ""
    },
    {
        "question": "Has the product Chainring Bolts been on any of the sales?",
        "hint": "a product that's been on sale refers to SellStartDate NOT null and vice versa;",
        "error_sql": "SELECT Name FROM Product WHERE SellStartDate IS NOT NULL AND Name = 'Chainring Bolts'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen checking if a product has been on sale, consider the relationship between the product and the sales data. In this case, the error SQL query only checks if the product's SellStartDate is not null, which is not sufficient to determine if the product has been on sale. The correct approach is to check if the product is associated with any special offers, which is done by joining the Product table with the SpecialOfferProduct table and then with the SpecialOffer table. This ensures that we are checking if the product has been part of any sales promotions, rather than just relying on the SellStartDate field.",
        "ground_truth_sql": "SELECT CASE WHEN COUNT(T1.Description) >= 1 THEN 'Yes' ELSE 'No' END FROM SpecialOffer AS T1 INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE T3.Name = 'Chainring Bolts'",
        "difficulty": ""
    },
    {
        "question": "Compare the total number of orders between customer \"Apollo Ltd\" and \"Pacific Ltd\".",
        "hint": "\"Apollo Ltd\" and \"Pacific Ltd\" are both Customer Names; total number of orders refers to COUNT(OrderNumber)",
        "error_sql": "SELECT COUNT(CASE WHEN T2.`Customer Names` = 'Apollo Ltd' THEN T1.OrderNumber END) - COUNT(CASE WHEN T2.`Customer Names` = 'Pacific Ltd' THEN T1.OrderNumber END) \nFROM `Sales Orders` AS T1 \nINNER JOIN Customers AS T2 \nON T1._CustomerID = T2.CustomerID",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using conditional aggregation with `CASE` statements, it's essential to use `SUM` instead of `COUNT` when comparing values. `COUNT` counts the number of non-NULL values, whereas `SUM` adds up the values. In this case, using `COUNT` would count the number of rows where the condition is true, but it would not provide the correct total count. Additionally, when using `CASE` statements with `SUM`, it's crucial to include an `ELSE` clause to handle cases where the condition is false, to avoid counting those rows.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.`Customer Names` = 'Apollo Ltd' THEN 1 ELSE 0 END), SUM(CASE WHEN T2.`Customer Names` = 'Pacific Ltd' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "difficulty": ""
    },
    {
        "question": "Name the neighborhood of the community area in crime with report number 23843?",
        "hint": "neighborhood refers to neighborhood_name; '23778' is the report_no",
        "error_sql": "SELECT T4.neighborhood_name FROM Crime AS T1 INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T4 ON T2.community_area_no = T4.community_area_no WHERE T1.report_no = 23843",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order makes logical sense and that the correct table is being joined first. In this case, the Crime table should be joined first with the Community_Area table, and then the result should be joined with the Neighborhood table. Additionally, double-check the values used in the WHERE clause to ensure they match the problem description. In this case, the report number in the WHERE clause was incorrect, it should be '23778' instead of '23843'.",
        "ground_truth_sql": "SELECT T3.neighborhood_name FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T3 ON T2.community_area_no = T3.community_area_no WHERE T2.report_no = 23778",
        "difficulty": ""
    },
    {
        "question": "Identify the user who has been yelping since 2004. Is he or she an Yelp Elite member?",
        "hint": "has been yelping since 2004 refers to user_yelping_since_year = 2004",
        "error_sql": "SELECT user_id FROM Users WHERE user_yelping_since_year = 2004",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, always consider the possibility of duplicate rows in the result set. In this case, the `Elite` table has multiple rows for the same `user_id` (one for each year they were an Elite member), so joining it with the `Users` table without using `DISTINCT` would result in duplicate `user_id` values. To avoid this, use `SELECT DISTINCT` to ensure that each `user_id` is only returned once.",
        "ground_truth_sql": "SELECT DISTINCT T2.user_id FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2004",
        "difficulty": ""
    },
    {
        "question": "How many inspection points with serious point level that have no fine?",
        "hint": "serious point level refers to point_level = 'Serious '; have no fine refers to fine = 0",
        "error_sql": "SELECT COUNT(point_id) FROM inspection_point WHERE point_level = 'Serious' AND fine = 0",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being referenced. In this case, the error SQL query was incorrect because it did not join the inspection_point table with the violation table, which is necessary to filter inspection points with no fine. The SQL after reflection was also incorrect because it did not account for the space in the 'Serious ' string. To avoid making the same mistake in the future, always carefully review the schema of the database and ensure that the join conditions and column references are correct. Additionally, pay close attention to details such as spaces in string values.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.point_id) FROM inspection_point AS T1 INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE T1.point_level = 'Serious ' AND T2.fine = 0",
        "difficulty": ""
    },
    {
        "question": "List the names of authors affiliated with the University of Oxford in alphabetical order.",
        "hint": "affiliated with the University of Oxford refers to Affiliation = 'University of Oxford'",
        "error_sql": "SELECT Name FROM PaperAuthor WHERE Affiliation = 'University of Oxford' ORDER BY Name",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, it's essential to carefully consider the table structure and relationships. In this case, the error occurred because the query was executed on the `PaperAuthor` table, which contains duplicate author information (since an author can be affiliated with multiple papers). The correct table to query is the `Author` table, which stores unique author information. To avoid similar mistakes in the future, always verify that the query is being executed on the correct table and consider the potential for duplicate data in joined tables.",
        "ground_truth_sql": "SELECT Name FROM Author WHERE Affiliation = 'University of Oxford' ORDER BY Name ASC",
        "difficulty": ""
    },
    {
        "question": "Among students registered for the most difficult course, list the students' full names who got grade A.",
        "hint": "difficulty refers to diff; most difficult course refers to MAX(diff); student's full names = f_name, l_name;",
        "error_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.diff = ( SELECT MAX(diff) FROM course ) AND T2.grade = 'A'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with queries that involve finding the maximum or minimum value of a column and then using that value to filter results, consider whether the query should return multiple rows or just one row. In this case, the original query was trying to find students who got grade A in the most difficult course, but it was using a subquery to find the maximum difficulty and then filtering the results based on that value. However, this approach would return all students who got grade A in any course with the maximum difficulty, not just the students in the single most difficult course. To avoid this mistake, use the ORDER BY and LIMIT clauses to ensure that only one row (or a limited number of rows) is returned, as shown in the Ground Truth SQL.",
        "ground_truth_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T2.grade = 'A' ORDER BY T3.diff DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "In the state with the highest number of schools, how many institutions have a percentage of no less than 90 of undergraduates who attend full-time? List all of the institutions' names.",
        "hint": "highest number of schools refers to MAX(schools_count); percentage of no less than 90 of undergraduates who attend full-time refers to ft_pct > 90; institutions' names refers to chronname;",
        "error_sql": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON T1.state = T2.state WHERE T2.schools_count = ( SELECT MAX(schools_count) FROM state_sector_details ) AND T1.ft_pct > 90",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, it's essential to carefully analyze the question and identify the correct order of operations. In this case, the question asks for institutions in the state with the highest number of schools, where the percentage of full-time undergraduates is at least 90%. The correct approach is to first find the state with the highest number of schools (using ORDER BY and LIMIT 1) and then filter the institutions in that state based on the full-time undergraduate percentage. The incorrect queries attempted to find the maximum number of schools using a subquery and then joined the tables, which is not the correct order of operations. To avoid making the same mistake in the future, always carefully read the question and identify the correct order of operations, and consider using ORDER BY and LIMIT when finding the maximum or minimum value of a column.",
        "ground_truth_sql": "SELECT COUNT(t1.unitid), t1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON t1.state = t2.state WHERE t1.ft_pct > 90 ORDER BY t2.schools_count DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Provide the zip code, city, and congress representative's full names of the area which has highest population in 2020.",
        "hint": "representative's full names refer to first_name, last_name; area which has highest population in 2020 refers to MAX(population_2020);",
        "error_sql": "SELECT T1.zip_code, T1.city, T2.first_name, T2.last_name \nFROM zip_data AS T1 \nINNER JOIN zip_congress AS T3 \nON T1.zip_code = T3.zip_code \nINNER JOIN congress AS T2 \nON T3.district = T2.cognress_rep_id \nWHERE T1.population_2020 = ( SELECT MAX(population_2020) FROM zip_data )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, be careful with the use of aggregate functions and the WHERE clause. In this case, the WHERE clause was used to filter the results based on the maximum population in 2020, but this approach is incorrect because it will return all rows that have the maximum population, not necessarily the single area with the highest population. To get the single area with the highest population, use the ORDER BY clause with the LIMIT clause, as in the Ground Truth SQL query. This will ensure that only one row is returned, which is the area with the highest population in 2020.",
        "ground_truth_sql": "SELECT T1.zip_code, T1.city, T3.first_name, T3.last_name FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id GROUP BY T2.district ORDER BY T1.population_2020 DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the average value of the sales order?",
        "hint": "calculation = DIVIDE(SUM(UnitPrice * Quantity * SUBTRACT(1, Discount)), COUNT(OrderID))",
        "error_sql": "SELECT CAST(SUM(T1.UnitPrice * T1.Quantity * (1 - T1.Discount)) AS REAL) / COUNT(T1.OrderID) FROM OrderDetails AS T1",
        "compiler_hint": "no such column: T1.UnitPrice",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names used in the query match the actual column names in the database tables. In this case, the error occurred because the column name 'UnitPrice' was not present in the 'OrderDetails' table. Also, the 'Discount' column was not present in the 'OrderDetails' table. The correct query should use the actual column names present in the 'OrderDetails' table. Additionally, the 'OrderDetails' table name should be enclosed in backticks or square brackets to avoid any syntax errors due to the space in the table name.",
        "ground_truth_sql": "SELECT SUM(UnitPrice * Quantity * (1 - Discount)) / COUNT(OrderID) FROM `Order Details`",
        "difficulty": ""
    },
    {
        "question": "To which user group do most of the users who uses a vivo device belong?",
        "hint": "user group where most of the users belong refers to MAX(COUNT(group)); vivo device refers to phone_brand = 'vivo';",
        "error_sql": "SELECT T1.`group` FROM ( SELECT T1.`group`, COUNT(T1.`group`) AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo' GROUP BY T1.`group` ) T ORDER BY T.num DESC LIMIT 1",
        "compiler_hint": "near \"group\": syntax error",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names are correctly referenced from the correct table. In the Error SQL Query, the column 'group' was referenced from 'T1' which is 'phone_brand_device_model2' table, but 'group' column actually exists in 'gender_age' table. In the SQL after Reflection, the subquery was removed, but the correct way to reference the column 'group' is by using a subquery as shown in the Ground Truth SQL. To avoid making the same mistake in the future, always double-check the table and column names when joining tables.",
        "ground_truth_sql": "SELECT T.`group` FROM ( SELECT T2.`group`, COUNT(`group`) AS num FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'vivo' GROUP BY T2.`group` ) AS T ORDER BY T.num DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many games were published by Activision?",
        "hint": "Activision refers to publisher_name = 'Activision';",
        "error_sql": "SELECT COUNT(T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Activision'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen counting the number of games published by a specific publisher, it's essential to join the game table to ensure that each game is only counted once. The initial error SQL query only joined the game_publisher and publisher tables, which could lead to counting the same game multiple times if it has multiple publishers. The SQL after reflection corrected this by joining the game table and using COUNT(DISTINCT T3.id) to ensure each game is only counted once. However, the initial error SQL query and the SQL after reflection both missed the fact that the game_publisher table is a many-to-many relationship table and does not directly relate to the game table. The correct approach is to join the game_publisher table with the game table through the game_id, and then join the publisher table through the publisher_id. The Ground Truth SQL query correctly implements this approach.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T3.id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN game AS T3 ON T1.game_id = T3.id WHERE T2.publisher_name = 'Activision'",
        "difficulty": ""
    },
    {
        "question": "What is the Asian population in the city with the alias Leeds?",
        "hint": "",
        "error_sql": "SELECT T1.asian_population FROM zip_data AS T1 INNER JOIN alias AS T2 ON T1.zip_code = T2.zip_code WHERE T2.alias = 'Leeds'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join order and alias assignments are correct. In this case, the initial error was due to the incorrect assignment of aliases (T1 and T2) in the SELECT and WHERE clauses. The corrected query assigns the alias 'T1' to the 'alias' table and 'T2' to the 'zip_data' table, allowing for the correct retrieval of the Asian population. Additionally, using SUM() is necessary to account for the possibility of multiple zip codes with the alias 'Leeds'.",
        "ground_truth_sql": "SELECT SUM(T2.asian_population) FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.alias = 'Leeds'",
        "difficulty": ""
    },
    {
        "question": "Among the seafoods, how many of them have an order quantity of more than 50?",
        "hint": "\"Seafood\" is the CategoryName; order quantity of more than 50 refers to Quantity > 50",
        "error_sql": "SELECT COUNT(T1.OrderDetailID) FROM OrderDetails AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Categories AS T3 ON T2.CategoryID = T3.CategoryID WHERE T3.CategoryName = 'Seafood' AND T1.Quantity > 50",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and the column references are accurate. In this case, the error was in the COUNT() function, where it should count the ProductID from the Products table, not the OrderDetailID from the OrderDetails table. Additionally, verify that the table and column names match the actual schema, including any backticks or quotes required for table names with spaces, such as `Order Details`.",
        "ground_truth_sql": "SELECT COUNT(T1.ProductID) FROM Products AS T1 INNER JOIN `Order Details` AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Categories AS T3 ON T1.CategoryID = T3.CategoryID WHERE T3.CategoryName = 'Seafood' AND T2.Quantity > 50",
        "difficulty": ""
    },
    {
        "question": "How many horror movies were made by the worst directors?",
        "hint": "d_quality = 5 refers to direct the best, d_quality = 0 refers to direct the worst",
        "error_sql": "SELECT COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN directors AS T2 ON T1.directorid = T2.directorid WHERE T2.d_quality = 0 AND T1.genre = 'Horror'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and that all necessary tables are included. In this case, the `movies` table was missing in the initial query, and the join order was incorrect in the second query. To avoid this mistake, carefully review the schema and the relationships between tables, and make sure to include all necessary tables in the query. Additionally, use table aliases consistently and ensure that the join conditions are correct to avoid errors.",
        "ground_truth_sql": "SELECT COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T1.directorid = T3.directorid WHERE T1.genre = 'horror' AND T3.d_quality = 0",
        "difficulty": ""
    },
    {
        "question": "Does the length of the tip influence the number of likes for hotel and travel business category?",
        "hint": "the longer the tip_length, the lesser the likes OR the longer the tip length the higher the likes; hotel and travel business category refers to category_name = 'Hotels & Travel';",
        "error_sql": "SELECT T1.tip_length, T1.likes FROM Tips AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T4.category_name = 'Hotels & Travel'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the columns used for joining are correct. In this case, the error SQL query was missing the join with the Categories table and the correct join order. Additionally, the query was not grouping the results by tip_length and was not summing the likes. To avoid making the same mistake in the future, carefully review the schema of the database, ensure that the join order is correct, and verify that the query is grouping and aggregating the results as intended.",
        "ground_truth_sql": "SELECT T3.tip_length, SUM(T3.likes) AS likes FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name = 'Hotels & Travel' GROUP BY T3.tip_length",
        "difficulty": ""
    },
    {
        "question": "What is the total ordered quantity for products under the 'Touring' line?",
        "hint": "The Touring line refers to the product line, therefore ProductLine = 'T'",
        "error_sql": "SELECT SUM(OrderQty) FROM SalesOrderDetail AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.ProductLine = 'T'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined based on the query's requirements. In this case, the error was due to joining `SalesOrderDetail` instead of `PurchaseOrderDetail` with the `Product` table. To avoid this mistake, carefully evaluate the query's requirements and verify that the correct tables are being joined. Additionally, ensure that the correct columns are being referenced in the join condition and the WHERE clause.",
        "ground_truth_sql": "SELECT SUM(T2.OrderQty) FROM Product AS T1 INNER JOIN PurchaseOrderDetail AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductLine = 'T'",
        "difficulty": ""
    },
    {
        "question": "List all the customer company names and cities located in Canada.",
        "hint": "located in Canada refers to Country = 'Canada'",
        "error_sql": "SELECT CustomerName, City FROM Customers WHERE Country = 'Canada'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that the column names in the SELECT clause match the actual column names in the table. In this case, the correct column name is 'CustomerName', not 'CompanyName'. Always double-check the table schema to avoid such mistakes.",
        "ground_truth_sql": "SELECT CompanyName, City FROM Customers WHERE Country = 'Canada'",
        "difficulty": ""
    },
    {
        "question": "Please provide the full name of the conference where one of the papers of Jean-luc Hainaut were published.",
        "hint": "papers of Jean-luc Hainaut refers to Name = 'Jean-luc Hainaut'",
        "error_sql": "SELECT T3.FullName FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id INNER JOIN Conference AS T3 ON T2.ConferenceId = T3.Id WHERE T1.Name = 'Jean-luc Hainaut'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and the tables are joined in the correct order. In this case, the initial error was due to joining PaperAuthor with Paper on PaperId, but then joining Paper with Conference on ConferenceId, which is correct. However, the join order was incorrect. The correct order is to join Paper with PaperAuthor on PaperId, and then join Paper with Conference on ConferenceId. Additionally, using DISTINCT is necessary to avoid duplicate results, and LIMIT 1 is necessary to return only one result as per the question's requirement.",
        "ground_truth_sql": "SELECT DISTINCT T3.FullName FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE T2.Name = 'Jean-luc Hainaut' LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which nations have a 100% Spanish-speaking population?",
        "hint": "",
        "error_sql": "SELECT T1.Name FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Spanish' AND T2.Percentage = 100",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns being joined are of the same data type. In this case, the join condition was incorrect as it was joining the 'Code' column from the 'country' table with the 'Country' column from the 'language' table. However, the 'Country' column in the 'language' table actually refers to the 'Code' column in the 'country' table. But in this case, the join was not necessary because the 'language' table already contains the 'Country' column which can be used directly to get the desired result.",
        "ground_truth_sql": "SELECT Country FROM language WHERE Name = 'Spanish' AND Percentage = 100",
        "difficulty": ""
    },
    {
        "question": "How old was Mr. Stacy Morar at the time of his first emergency room admission due to a drug overdose?",
        "hint": "how old = SUBTRACT(MIN(encounters.DATE), patients.birthdate); his first emergency room admission refers to MIN(encounters.DATE); drug overdose refers to encounters.REASONDESCRIPTION = 'Drug overdose' ;",
        "error_sql": "SELECT (strftime('%J', T1.DATE) - strftime('%J', T2.birthdate)) / 365.25 AS age \nFROM encounters AS T1 \nINNER JOIN patients AS T2 \nON T1.PATIENT = T2.patient \nWHERE T2.first = 'Stacy' AND T2.last = 'Morar' AND T1.REASONDESCRIPTION = 'Drug overdose' \nORDER BY T1.DATE \nLIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the age of a person, it's essential to consider the correct date format and the context of the calculation. In this case, the error SQL query and the SQL after reflection both attempted to calculate the age by subtracting the birthdate from the encounter date. However, the correct approach is to simply subtract the birthdate from the encounter date without converting the dates to Julian dates or dividing by 365.25. This is because the question asks for the age at the time of the first emergency room admission, which can be calculated by simply subtracting the birthdate from the encounter date. Additionally, the SQL after reflection incorrectly used the strftime function to convert the dates, which is not necessary in this case. To avoid making the same mistake in the future, it's crucial to carefully consider the context of the calculation and the correct date format to use.",
        "ground_truth_sql": "SELECT T2.DATE - T1.birthdate AS age FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Stacy' AND T1.last = 'Morar' AND T2.DESCRIPTION = 'Emergency Room Admission' AND T2.REASONDESCRIPTION = 'Drug overdose' ORDER BY T2.DATE LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Please list the bowling skills of all the players from Australia.",
        "hint": "Australia refers to Country_Name = 'Australia'",
        "error_sql": "SELECT T1.Bowling_skill FROM Bowling_Style AS T1 INNER JOIN Player AS T2 ON T1.Bowling_Id = T2.Bowling_skill WHERE T2.Country_Name = 'Australia'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and conditions are correct. In this case, the error was due to incorrect join order and missing join with the Country table. To avoid this mistake, carefully analyze the relationships between the tables and ensure that the join conditions are correct. Additionally, when filtering data based on a specific condition, consider using the correct table and column names to avoid ambiguity. In this case, the correct join order is Player -> Country -> Bowling_Style, and the filter condition should be applied to the Country table.",
        "ground_truth_sql": "SELECT T2.Bowling_Skill FROM Player AS T1 INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id INNER JOIN Country AS T3 ON T1.Country_Name = T3.Country_Id WHERE T3.Country_Name = 'Australia' GROUP BY T2.Bowling_Skill",
        "difficulty": ""
    },
    {
        "question": "What kind of expression correlation occurs in physical type interacting gene pairs and what percentage of these are negatively correlated?",
        "hint": "If the Expression_Corr value is negative then it's negatively correlated. Percentage of Negative Correlation = count(negative Expression_Corr physical type) / count(Expression_Corr physical type) * 100%",
        "error_sql": "SELECT Type, CAST(SUM(CASE WHEN Expression_Corr < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Expression_Corr) FROM Interactions WHERE Type = 'physical'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, it's essential to carefully read and understand the question. In this case, the question asked for two different results: the type of expression correlation and the percentage of negatively correlated interactions. However, the initial attempts tried to combine these two results into a single query, which led to incorrect results. To avoid this mistake, break down the problem into smaller parts and create separate queries for each part. In this case, the correct solution uses a UNION ALL operator to combine two separate queries: one for retrieving the expression correlation values and another for calculating the percentage of negatively correlated interactions.",
        "ground_truth_sql": "SELECT Expression_Corr FROM Interactions WHERE Type = 'Physical' UNION ALL SELECT CAST(SUM(Expression_Corr < 0) AS REAL) * 100 / COUNT(*) FROM Interactions WHERE Type = 'Physical'",
        "difficulty": ""
    },
    {
        "question": "Among the orders placed by Ei, how many orders have quantity greater than 4?",
        "hint": "Ei is the name of the customer; orders have quantity greater than 4 refer to OrderNumber WHERE Order Quantity > 4;",
        "error_sql": "SELECT COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T1._CustomerID = T2.CustomerID WHERE T2.`Customer Names` = 'Ei' AND T1.`Order Quantity` > 4",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the ON clause match the table aliases used in the query. In the Error SQL Query, the join condition was `T1._CustomerID = T2.CustomerID`, but it should be `T2.CustomerID = T1._CustomerID` to match the table aliases. Additionally, when using aggregate functions like COUNT, consider using SUM with a CASE statement to handle conditional counting, as seen in the Ground Truth SQL.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.`Order Quantity` > 4 AND T2.`Customer Names` = 'Ei ' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "difficulty": ""
    },
    {
        "question": "Which employee is in charge of the sales in Hollis? Please give the employee's full name.",
        "hint": "Hollis refers to TerritoryDescription = 'Hollis'; full name = FirstName, LastName;",
        "error_sql": "SELECT T1.FirstName, T1.LastName \nFROM Employees AS T1 \nINNER JOIN Orders AS T2 \nON T1.EmployeeID = T2.EmployeeID \nINNER JOIN Customers AS T3 \nON T2.CustomerID = T3.CustomerID \nWHERE T3.City = 'Hollis'",
        "compiler_hint": "no such table: Territories",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that all referenced tables actually exist in the provided schema. In this case, the initial error occurred because the 'Territories' table was not present in the schema. However, upon re-examining the schema, it's clear that the 'Territories' table is missing, but 'EmployeeTerritories' is present, which is a many-to-many relationship table between 'Employees' and 'Territories'. To avoid this mistake, always verify the existence of tables and their relationships in the schema before generating SQL queries.",
        "ground_truth_sql": "SELECT T1.FirstName, T1.LastName FROM Employees AS T1 INNER JOIN EmployeeTerritories AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Territories AS T3 ON T2.TerritoryID = T3.TerritoryID WHERE T3.TerritoryDescription = 'Hollis'",
        "difficulty": ""
    },
    {
        "question": "For all transactions for WRAP in August 2016, list the time to achieve highest price and the time to achieve the lowest price.",
        "hint": "in May 2013 refers to month(date) = 5 AND year(date) = 2013; time to achieve the highest price refers to time_high; time to achieve the lowest price refers to time_low; WRAP refers to name = 'WARP'",
        "error_sql": "SELECT T2.time_high, T2.time_low FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WRAP' AND STRFTIME('%Y', T2.date) = '2016' AND STRFTIME('%m', T2.date) = '08'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names and values are accurate and match the provided schema and problem description. In this case, the error was due to a typo in the coin name ('WRAP' instead of 'WARP') and the format of the date filter. To avoid such mistakes, double-check the schema and problem description, and verify the accuracy of column names and values. Additionally, consider using exact matching instead of substring matching for string values to prevent errors.",
        "ground_truth_sql": "SELECT T2.time_high, T2.time_low, T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND STRFTIME('%Y-%m', T2.date) = '2016-08'",
        "difficulty": ""
    },
    {
        "question": "Please list the starting stations of the bike trips made on a day with a max humidity over 80 in 2013 in the area where the zip code is 94107.",
        "hint": "starting stations refers to start_station_name; day with a max humidity over 80 refers to max_humidity>80; in 2013 refers to date LIKE'%2013';",
        "error_sql": "SELECT T1.start_station_name FROM trip AS T1 INNER JOIN weather AS T2 ON T1.zip_code = T2.zip_code WHERE T2.max_humidity > 80 AND T2.date LIKE '%2013'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and consistent with the data types of the columns being joined. In this case, the initial error was due to the incorrect assumption that the zip_code column in the weather table is of type TEXT, when in fact it is of type INTEGER in the trip table. Additionally, when filtering dates, use a more robust method such as SUBSTR(CAST(date AS TEXT), -4) to extract the year, rather than relying on the LIKE operator with a wildcard. Finally, double-check the conditions in the WHERE clause to ensure they match the problem requirements, in this case, the max_humidity condition was incorrect and should be max_temperature_f instead.",
        "ground_truth_sql": "SELECT DISTINCT T1.start_station_name FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2013' AND T2.zip_code = 94107 AND T2.max_temperature_f > 80",
        "difficulty": ""
    },
    {
        "question": "Give the full name of legislators who have accounts on OpenSecrets.org.",
        "hint": "full name refers to first_name, last_name; have accounts on OpenSecrets.org refers to opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "error_sql": "SELECT first_name, last_name FROM current WHERE opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen generating SQL queries, carefully consider the column names and table structure to avoid selecting incorrect columns or using non-existent columns. In this case, the error SQL query and SQL after reflection were incorrect because they selected the wrong columns. The correct query should select the full name of legislators, which is likely a combination of first_name and last_name, or possibly the official_full_name column. Additionally, the SQL after reflection incorrectly selected the count of rows instead of the actual names. To avoid this mistake, double-check the column names and table structure before generating the SQL query.",
        "ground_truth_sql": "SELECT COUNT(*) FROM current WHERE opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "difficulty": ""
    },
    {
        "question": "How much more expensive in percentage is the product with the highest selling price from the product with the lowest selling price in the Clothing category?",
        "hint": "selling price refers to ListPrice; highest selling price refers to MAX(ListPrice); lowest selling price refers to MIN(ListPrice);",
        "error_sql": "SELECT CAST(((MAX(ListPrice) - MIN(ListPrice)) * 100.0) / MIN(ListPrice) AS REAL) FROM Product WHERE ProductSubcategoryID IN (SELECT ProductSubcategoryID FROM ProductSubcategory WHERE Name = 'Clothing')",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and that all necessary tables are included in the join. In this case, the error SQL query only joined the Product table with the ProductSubcategory table, but missed the ProductCategory table which is necessary to filter the products by category name. Additionally, when performing calculations with aggregate functions like MAX and MIN, ensure that the calculation is correct and that the data types are compatible. In this case, the calculation was correct, but the CAST function was unnecessary and could be removed.",
        "ground_truth_sql": "SELECT (MAX(T1.ListPrice) - MIN(T1.ListPrice)) * 100 / MIN(T1.ListPrice) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE T3.Name = 'Clothing'",
        "difficulty": ""
    },
    {
        "question": "How many turnovers per game did the assist champion had in the 2003 NBA season?",
        "hint": "turnovers per game = avg(turnovers); 2003 refers to year = 2003; NBA refers to lgID = 'NBA'",
        "error_sql": "SELECT AVG(T1.turnovers / T1.GP) FROM players_teams AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T2.year = 2003 AND T2.lgID = 'NBA'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, it's essential to carefully analyze the question and identify the correct tables and columns to use. In this case, the error SQL query and the SQL after reflection both failed to correctly identify the assist champion and calculate the average turnovers per game. The key mistake was not using the `GROUP BY` and `ORDER BY` clauses to find the player with the maximum assists in the 2003 season and then calculate the average turnovers for that player. Additionally, the `LIMIT 1` clause is necessary to ensure that only the top assist champion is considered. To avoid similar mistakes in the future, it's crucial to carefully read the problem statement, identify the relevant tables and columns, and use the correct SQL clauses to achieve the desired result.",
        "ground_truth_sql": "SELECT AVG(T2.turnovers) FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 2003 GROUP BY T1.playerID, T2.assists ORDER BY T2.assists DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the independent countries, how many of them has a GDP per capita of over 5000?",
        "hint": "",
        "error_sql": "SELECT COUNT(T1.Code) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T1.Code = T3.Country WHERE T2.Independence IS NOT NULL AND T3.GDP / T1.Population > 5000",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and consistent. In the Error SQL Query, the join condition for the economy table was incorrect, using T1.Code = T3.Country instead of T3.Country = T1.Code. Additionally, when counting the number of countries, use COUNT(DISTINCT T1.Name) to avoid counting duplicate countries. Also, be careful when using aggregate functions like SUM, AVG, MAX, MIN, etc., as they can return incorrect results if not used correctly. In this case, the GDP per capita was calculated incorrectly, and the condition should be T3.GDP > 5000, not T3.GDP / T1.Population > 5000.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE T2.Independence IS NOT NULL AND T3.GDP > 5000",
        "difficulty": ""
    },
    {
        "question": "Which order have the highest unit cost?",
        "hint": "order have the highest unit cost refers to OrderNumber where MAX(Unit Cost);",
        "error_sql": "SELECT OrderNumber FROM `Sales Orders` ORDER BY CAST(REPLACE(`Unit Cost`, ',', '') AS REAL) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the maximum or minimum value in a column, avoid using ORDER BY and LIMIT, as this can return incorrect results if there are multiple rows with the same maximum or minimum value. Instead, use a subquery to find the maximum or minimum value, and then use this value to select the corresponding rows. This ensures that all rows with the maximum or minimum value are returned, not just one of them.",
        "ground_truth_sql": "SELECT OrderNumber FROM `Sales Orders` WHERE REPLACE(`Unit Cost`, ',', '') = ( SELECT REPLACE(`Unit Cost`, ',', '') FROM `Sales Orders` ORDER BY REPLACE(`Unit Cost`, ',', '') DESC LIMIT 1 )",
        "difficulty": ""
    },
    {
        "question": "List the names and business certificates of the eateries which got inspection score under 50.",
        "hint": "eateries which got inspection score under 50 refer to business_id where score < 50;",
        "error_sql": "SELECT T1.name, T1.business_certificate FROM businesses AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id WHERE T2.score < 50",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the correct table alias is used to access the columns. In this case, the `businesses` table is being joined with the `inspections` table, and the `businesses` table contains the columns `name` and `business_certificate`. Therefore, the correct query should use the alias of the `businesses` table (`T2`) to access these columns. Additionally, the `business_id` column should be accessed from the `businesses` table (`T2`) instead of the `inspections` table (`T1`).",
        "ground_truth_sql": "SELECT T2.name, T2.business_id FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score < 50",
        "difficulty": ""
    },
    {
        "question": "What is the average number of less severe crimes reported a day in February of 2018?",
        "hint": "day in February of 2018 refers to date LIKE '2/%/2018'; less severe crime refers to index_code = 'N'; average = Divide (Count(case_number), 28)",
        "error_sql": "SELECT CAST(COUNT(T1.case_number) AS REAL) / 28 FROM Crime AS T1 INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no WHERE T2.index_code = 'N' AND T1.date LIKE '2/%/2018'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the SELECT and WHERE clauses match the table aliases used in the JOIN clause. In this case, the Error SQL Query used T1.case_number, but T1 was the alias for the IUCR table, which does not have a case_number column. The correct column name is T2.case_number, where T2 is the alias for the Crime table. Always double-check the table aliases and column names to avoid this mistake.",
        "ground_truth_sql": "SELECT CAST(COUNT(T2.case_number) AS REAL) / 28 FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no WHERE T2.date LIKE '2/%/2018%' AND T1.index_code = 'N'",
        "difficulty": ""
    },
    {
        "question": "How many universities have no less than 20,000 female students in 2016? Identify how many of the said universities are located in the United States of America.",
        "hint": "have no less than 20,000 female students refers to DIVIDE(MULTIPLY(pct_female_students, num_students), 100) > 20000; in 2016 refers to year = 2016; located in the United States of America refers to country_name = 'United States of America'",
        "error_sql": "SELECT COUNT(IIF(T2.country_name = 'United States of America', T1.id, NULL)) AS usa_universities, COUNT(T1.id) AS total_universities \nFROM university AS T1 \nINNER JOIN country AS T2 \nON T1.country_id = T2.id \nINNER JOIN university_year AS T3 \nON T1.id = T3.university_id \nWHERE T3.year = 2016 AND (T3.num_students * T3.pct_female_students / 100) > 20000",
        "compiler_hint": "no such column: T1.university_id",
        "reflective_cot": "### Tip:\nWhen using aggregate functions like COUNT() or SUM() with conditional statements, it's essential to ensure that the column being referenced exists in the table or subquery being used. In this case, the error occurred because the column 'university_id' was not present in the 'university' table, but rather 'id'. Additionally, using IIF() or CASE WHEN is not necessary when counting rows that meet a specific condition, as SUM(CASE WHEN) can be used instead. Always verify the column names and data types to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(*) , SUM(CASE WHEN T3.country_name = 'United States of America' THEN 1 ELSE 0 END) AS nums_in_usa FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.year = 2016 AND T2.num_students * T2.pct_female_students / 100 > 20000",
        "difficulty": ""
    },
    {
        "question": "What is the total number of fans or followers who received most likes of their comments in the business?",
        "hint": "fans and followers refers to user_fans; most likes of their comments refer to Max(likes)",
        "error_sql": "SELECT MAX(T1.user_fans) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully read and understand the question. In this case, the question asks for the \"total number of fans or followers\" who received the most likes for their comments. The mistake in the initial attempts was focusing on finding the maximum number of fans (MAX(T1.user_fans)) or incorrectly ordering by likes. The correct approach is to count the number of fans who received the most likes, which involves grouping by user_id, counting the likes for each user, and then ordering by this count in descending order to find the maximum. This requires a more nuanced understanding of the problem and the use of aggregate functions (COUNT, GROUP BY) in conjunction with ordering and limiting results.",
        "ground_truth_sql": "SELECT COUNT(T1.user_fans) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id ORDER BY COUNT(T2.likes) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the patients who were immunized with meningococcal MCV4P, how many have viral sinusitis disorder after getting the immunization?",
        "hint": "immunized with meningococcal MCV4P refers to DESCRIPTION = 'meningococcal MCV4P' from immunizations; viral sinusitis disorder refers to DESCRIPTION = 'Viral sinusitis (disorder)' from conditions;",
        "error_sql": "SELECT COUNT(T1.PATIENT) FROM immunizations AS T1 INNER JOIN conditions AS T2 ON T1.PATIENT = T2.PATIENT WHERE T1.DESCRIPTION = 'meningococcal MCV4P' AND T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and counting the number of distinct entities, it's essential to consider the potential for duplicate records in the joined table. In this case, the error SQL query and the SQL after reflection both used `COUNT(T1.PATIENT)`, which would count duplicate records multiple times. To avoid this, use `COUNT(DISTINCT T1.patient)` to ensure that each patient is only counted once, even if they have multiple records in the joined table.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.patient) FROM immunizations AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.DESCRIPTION = 'meningococcal MCV4P' AND T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "What is the category and itune url of the title \"Scaling Global\"?",
        "hint": "",
        "error_sql": "SELECT T3.category, T2.itunes_url FROM reviews AS T1 INNER JOIN podcasts AS T2 ON T1.podcast_id = T2.podcast_id INNER JOIN categories AS T3 ON T2.podcast_id = T3.podcast_id WHERE T1.title = 'Scaling Global'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the columns used in the WHERE clause are from the correct table. In this case, the error was in the WHERE clause where the title was being compared from the 'reviews' table instead of the 'podcasts' table. Also, the join condition in the Error SQL Query was incorrect. To avoid this mistake, carefully examine the schema of the database, identify the correct tables and columns to use, and ensure that the join conditions are correct.",
        "ground_truth_sql": "SELECT T1.category, T2.itunes_url FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.title = 'Scaling Global'",
        "difficulty": ""
    },
    {
        "question": "For the event which happened at 14:09:49 on 2016/5/6, in the location coordinate(116, 40), how many apps were active?",
        "hint": "at 14:09:49 on 2016/5/6 refers to timestamp = '2016/5/6 14:09:49'; location coordinate(116, 40) refers to longitude = '116' AND latitude = '40'; active refers to is_active = '1';",
        "error_sql": "SELECT COUNT(T2.app_id) FROM events AS T1 INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE T1.timestamp = '2016/5/6 14:09:49' AND T1.longitude = 116 AND T1.latitude = 40 AND T2.is_active = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the column names and aliases are correctly referenced in the WHERE and SELECT clauses. In this case, the mistake was in the column references in the WHERE clause. The correct references should be based on the table aliases used in the FROM clause. Additionally, pay attention to the data types and formats of the columns being compared, such as the date format in the timestamp column.",
        "ground_truth_sql": "SELECT COUNT(T1.app_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE T2.timestamp = '2016-05-06 14:09:49' AND T1.is_active = '1' AND T2.longitude = '116' AND T2.latitude = '40'",
        "difficulty": ""
    },
    {
        "question": "How many releases by the artist michael jackson are tagged \"pop\"?",
        "hint": "tag = 'pop';",
        "error_sql": "SELECT COUNT(T1.id) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.artist = 'Michael Jackson' AND T2.tag = 'pop'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and filtering data, ensure that the filter conditions are case-insensitive if the database or column collation allows for it. In this case, the error occurred because the artist's name was filtered with 'Michael Jackson' (title case) instead of 'michael jackson' (lowercase), which is the actual case in the database. To avoid this mistake, use case-insensitive filtering methods such as LOWER() or UPPER() functions, or ensure that the filter values match the case of the data in the database.",
        "ground_truth_sql": "SELECT COUNT(T1.groupName) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'pop' AND T1.artist = 'michael jackson'",
        "difficulty": ""
    },
    {
        "question": "On 8/29/2013, who took the longest to arrive in California Ave Caltrain Station from University and Emerson? Indicate the bike id.",
        "hint": "start_date = '8/29/2013'; end_date = '8/29/2013'; end_station_name = 'California Ave Caltrain Station'; start_station_name = 'University and Emerson'; who took the longest to arrive refers to MAX(duration);",
        "error_sql": "SELECT bike_id FROM trip WHERE start_date LIKE '8/29/2013' AND end_date LIKE '8/29/2013' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' ORDER BY duration DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using the `ORDER BY` clause with `LIMIT 1` to find the maximum or minimum value in a column, it's essential to ensure that the query is correctly filtering the data before ordering. However, relying solely on `ORDER BY` and `LIMIT 1` can be problematic if there are multiple rows with the same maximum or minimum value, as it will only return one of them arbitrarily. To avoid this issue, use a subquery to find the maximum or minimum value first, and then filter the data to include all rows with that value, as shown in the Ground Truth SQL. This approach ensures that all relevant rows are returned, not just one of them.",
        "ground_truth_sql": "SELECT bike_id FROM trip WHERE start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' AND duration = ( SELECT MAX(duration) FROM trip WHERE start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' )",
        "difficulty": ""
    },
    {
        "question": "Which Apollo Ltd customer's order number has the most expensive unit price, indicating the order date?",
        "hint": "\"Apollo Ltd\" is the Customer Names; most expensive unit price refers to max(Unit Price)",
        "error_sql": "SELECT T1.OrderNumber, T1.OrderDate FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T1._CustomerID = T2.CustomerID WHERE T2.`Customer Names` = 'Apollo Ltd' ORDER BY CAST(REPLACE(T1.`Unit Price`, ',', '') AS REAL) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen comparing or ordering by a column that contains currency or numeric values with commas, it's essential to convert the column to a numeric data type after removing the commas. However, in this case, the error was in the conversion process. The correct approach is to remove the commas and then convert to a numeric data type. But, in the provided SQL queries, the conversion was done correctly. The issue was in the comparison of the unit price. The correct approach is to compare the unit price without considering the commas, but the unit price should be in the same format for all records. In this case, the error was in the SQL after Reflection, where the conversion was done correctly, but the comparison was not correct. The correct comparison should be done without considering the commas, but the unit price should be in the same format for all records. The Ground Truth SQL query shows that the comparison should be done directly on the unit price column without any conversion, assuming that the unit price is in the same format for all records. Therefore, the tip is to be careful when comparing or ordering by a column that contains currency or numeric values with commas, and make sure that the comparison is done correctly.",
        "ground_truth_sql": "SELECT T1.OrderNumber, T1.OrderDate FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE T2.`Customer Names` = 'Apollo Ltd' ORDER BY T1.`Unit Price` DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many game publisher IDs have published games on the X360 platform?",
        "hint": "X360 refers to platform_name = 'X360';",
        "error_sql": "SELECT COUNT(DISTINCT T1.game_publisher_id) FROM game_platform AS T1 INNER JOIN platform AS T2 ON T1.platform_id = T2.id WHERE T2.platform_name = 'X360'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and that all necessary tables are included in the join. However, do not over-join tables, as this can lead to unnecessary complexity and incorrect results. In this case, the game_publisher table was not necessary for the query, as the game_publisher_id is already present in the game_platform table. Therefore, the correct query only requires joining the game_platform and platform tables.",
        "ground_truth_sql": "SELECT COUNT(T1.game_publisher_id) FROM game_platform AS T1 INNER JOIN platform AS T2 ON T1.platform_id = T2.id WHERE T2.platform_name = 'X360'",
        "difficulty": ""
    },
    {
        "question": "Where is the school that needs a \"Viewscreen LCD from Texas Instruments, TI-84 Plus\"? Provide the latitude and longitude of that school.",
        "hint": "needs a \"Viewscreen LCD from Texas Instruments, TI-84 Plus\" refers to item_name = 'Viewscreen LCD from Texas Instruments, TI-84 Plus'; where is the school refers to school_city; latitude refers to school_latitude; longtitude refers to school_longitude",
        "error_sql": "SELECT T1.school_latitude, T1.school_longitude FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.item_name = 'Viewscreen LCD from Texas Instruments, TI-84 Plus'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names in the SELECT statement match the table alias used in the JOIN clause. In this case, the Error SQL Query used T1 for the projects table, but the correct table alias for projects is T2. Additionally, the query should also return the school_city as per the problem statement. Always double-check the table aliases and the columns being selected to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.school_city, T2.school_latitude, T2.school_longitude FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.item_name = 'Viewscreen LCD FROM Texas Instruments, TI-84 Plus'",
        "difficulty": ""
    },
    {
        "question": "In the state where Lisa Murkowski is the representative, how many cities have zero employees?",
        "hint": "zero employee refers to employees = 0",
        "error_sql": "SELECT COUNT(T1.city) FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE T3.first_name = 'Lisa' AND T3.last_name = 'Murkowski' AND T1.employees = 0",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join order and conditions are correct. In this case, the error was due to incorrect join order and conditions. The correct join order should start from the congress table, then join with the state table, and finally join with the zip_data table. Additionally, the join conditions should be based on the correct columns, such as the abbreviation column in the state table. It's also important to note that the COUNT function should be used with the correct table alias, which in this case is T3. To avoid making the same mistake in the future, it's essential to carefully review the table schema and the join conditions to ensure that they are correct.",
        "ground_truth_sql": "SELECT COUNT(T3.city) FROM congress AS T1 INNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE T1.first_name = 'Murkowski' AND T1.last_name = 'Lisa' AND T3.employees = 0",
        "difficulty": ""
    },
    {
        "question": "Provide the supplier company name in Sydney and its homepage address if available.",
        "hint": "in Sydney refers to City = 'Sydney';",
        "error_sql": "SELECT SupplierName FROM Suppliers WHERE City = 'Sydney'",
        "compiler_hint": "no such column: HomePage",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names in the SELECT clause match the actual column names in the table. In this case, the correct column name is 'CompanyName', not 'SupplierName' or 'SupplierCompany'. Also, the table 'Suppliers' does not have a column named 'HomePage', it's likely that the correct column name is 'HomePage' but it's not present in the provided schema, double-check the schema and the column names to avoid such mistakes.",
        "ground_truth_sql": "SELECT CompanyName, HomePage FROM Suppliers WHERE City = 'Sydney'",
        "difficulty": ""
    },
    {
        "question": "What is the newest established organization where Singapore is a member of?",
        "hint": "",
        "error_sql": "SELECT MAX(T1.Established) FROM organization AS T1 INNER JOIN isMember AS T2 ON T1.Abbreviation = T2.Organization WHERE T2.Country = 'Singapore'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\n\nWhen joining tables, ensure that the join conditions are correct and consider all relevant tables and relationships. In this case, the error SQL query and SQL after reflection were incorrect because they did not properly join the tables. The error SQL query only joined the `organization` table with the `isMember` table, but did not consider the `country` table. The SQL after reflection joined the `country` table with the `isMember` table and then with the `organization` table, but the join condition with the `organization` table was incorrect. To avoid making the same mistake in the future, it's essential to carefully analyze the relationships between tables and ensure that the join conditions are correct.",
        "ground_truth_sql": "SELECT T3.Name FROM country AS T1 INNER JOIN isMember AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country WHERE T1.Name = 'Singapore' ORDER BY T3.Established DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Name the teams played in a match which resulted in a tie in 2015.",
        "hint": "resulted in a tie refers to Win_Type = 'Tie'; in 2015 refers to SUBSTR(Match_Date, 1, 4) = 2015",
        "error_sql": "SELECT T1.Team_Name, T3.Team_Name \nFROM Team AS T1 \nINNER JOIN Match AS T2 \nON T1.Team_Id = T2.Team_1 \nINNER JOIN Team AS T3 \nON T2.Team_2 = T3.Team_Id \nWHERE T2.Win_Type = 'Tie' AND SUBSTR(T2.Match_Date, 1, 4) = 2015",
        "compiler_hint": "no such column: T2.Team_Name",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the columns being referenced exist in the correct tables and that the join conditions are correctly specified. In this case, the error occurred because the `Team_Name` column was being referenced from the `Match` table instead of the `Team` table. Additionally, when retrieving data from multiple tables, consider using `OR` conditions in the `WHERE` clause to account for different scenarios, such as a team being either `Team_1` or `Team_2` in the `Match` table.",
        "ground_truth_sql": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Win_By AS T3 ON T2.Win_Type = T3.Win_Id WHERE SUBSTR(T2.Match_Date, 1, 4) = '2015' AND T3.Win_Type = 'Tie' LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Please indicate the business id have the closing time with the category of Arts & Entertainment on Sunday.",
        "hint": "Sunday refers to day_of_week = 'Sunday' where day_id = 1; category of Arts & Entertainment refers to category_name = 'Arts & Entertainment';",
        "error_sql": "SELECT T1.business_id FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business_Categories AS T3 ON T1.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T2.day_of_week = 'Sunday' AND T4.category_name = 'Arts & Entertainment'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the columns being joined are correct. In this case, the error was in the join order and the columns being selected. The correct join order should start with the table that has the category information, then join with the table that has the business information, and finally join with the table that has the hours information. Additionally, the correct columns to select should include the closing time from the Business_Hours table. To avoid making the same mistake in the future, double-check the join order and the columns being selected to ensure they match the requirements of the query.",
        "ground_truth_sql": "SELECT T1.business_id, T3.closing_time FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE T2.category_name = 'Arts & Entertainment' AND T4.day_of_week = 'Sunday'",
        "difficulty": ""
    },
    {
        "question": "How many rainy days were recorded in Mountain View?",
        "hint": "rainy days refers to events = 'rain'; Mountain View refers to zip_code = 94041;",
        "error_sql": "SELECT COUNT(date) FROM weather WHERE events = 'rain' AND zip_code = '94041'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with data types and string comparisons in SQL, be mindful of case sensitivity and data type consistency. In this case, the error was due to the case sensitivity of the string 'rain' vs 'Rain' and the data type inconsistency of the zip_code column which is TEXT in the schema but should be compared as an INTEGER. Additionally, the correct approach to count the number of rainy days is to use a conditional aggregation function like SUM(IIF()) instead of COUNT() to ensure accurate results.",
        "ground_truth_sql": "SELECT SUM(IIF(zip_code = 94041 AND events = 'Rain', 1, 0)) FROM weather",
        "difficulty": ""
    },
    {
        "question": "For the Yelp business which had the most number of \"short\" tips, which category does it belong to?",
        "hint": "short tips refers to tip_length = 'short'; most number of short tips refers to MAX(COUNT(tip_length = 'short')); category refers to category_name;",
        "error_sql": "SELECT T4.category_name FROM Tips AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T1.tip_length = 'short' GROUP BY T4.category_name ORDER BY COUNT(T1.tip_length) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order makes sense logically and that the correct columns are being joined. In this case, the error was due to incorrect join order and incorrect column references. To avoid this mistake, take the time to carefully plan out the join order and ensure that each join is referencing the correct columns. Additionally, when using aggregate functions like COUNT, make sure to group by the correct columns to avoid incorrect results.",
        "ground_truth_sql": "SELECT DISTINCT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Tips AS T4 ON T3.business_id = T4.business_id WHERE T4.tip_length LIKE 'short'",
        "difficulty": ""
    },
    {
        "question": "How many authors drafted the paper \"Subcellular localization of nuclease in barley aleurone\"?",
        "hint": "'Subcellular localization of nuclease in barley aleurone' is the title of paper",
        "error_sql": "SELECT COUNT(AuthorId) FROM PaperAuthor WHERE PaperId IN ( SELECT Id FROM Paper WHERE Title = 'Subcellular localization of nuclease in barley aleurone' )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that you are counting the correct column to avoid overcounting or undercounting. In this case, counting `AuthorId` directly would be incorrect because it may contain duplicate values for the same paper. Instead, join the `Paper` and `PaperAuthor` tables and count the distinct `Name` column from the `PaperAuthor` table to get the correct number of authors. Additionally, using `DISTINCT` keyword is crucial when counting to avoid counting duplicate values.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.Name) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'",
        "difficulty": ""
    },
    {
        "question": "Give the number of followers for the user who posted the most lists.",
        "hint": "number of followers refers to user_subscriber; posted the most lists refers to MAX(COUNT(list_id))",
        "error_sql": "SELECT MAX(T1.user_subscriber) FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id GROUP BY T1.user_id ORDER BY COUNT(T2.list_id) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables and performing aggregations, ensure that the GROUP BY clause is referencing the correct table and column. In this case, the GROUP BY clause should reference the user_id from the lists table (T1), not the lists_users table (T2), because the list_followers column is in the lists table. Additionally, the SUM aggregation function should be used to calculate the total number of followers for each user, not the MAX function which would return the maximum value of user_subscriber, which is not relevant to the problem.",
        "ground_truth_sql": "SELECT SUM(T1.list_followers) FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id GROUP BY T1.user_id ORDER BY COUNT(T1.list_id) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the ratio of active and inactive app users of the event ID \"58\"?",
        "hint": "ratio = DIVIDE(SUM(is_active = 1), SUM(is_active = 0)); active refers to is_active = 1; inactive refers to is_active = 0;",
        "error_sql": "SELECT CAST(SUM(IIF(T1.is_active = 1, 1, 0)) AS REAL) / SUM(IIF(T1.is_active = 0, 1, 0)) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE T2.event_id = 58",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating ratios, ensure that the denominator is not zero to avoid division by zero errors. In this case, the SQL query should be modified to handle the case where the sum of inactive users is zero. Additionally, the CAST function is not necessary in this case, as the division operation will automatically return a real number. The join with the events table is also unnecessary, as the event_id is already present in the app_events table.",
        "ground_truth_sql": "SELECT SUM(IIF(is_active = 1, 1, 0)) / SUM(IIF(is_active = 0, 1, 0)) AS per FROM app_events WHERE event_id = 58",
        "difficulty": ""
    },
    {
        "question": "List the student's first and last name that got a C in the course named \"Applied Deep Learning\".",
        "hint": "student's first name refers to f_name; student's last name refers to l_name; got a C refers to grade = 'C';",
        "error_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Applied Deep Learning' AND T2.grade = 'C'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and filtering data, ensure that the column values used in the WHERE clause are exact matches. In this case, the error was due to a trailing space in the course name 'Applied Deep Learning '. Always verify the data and column values to avoid such mistakes. It's also a good practice to use the TRIM() function to remove leading and trailing spaces from the column values before comparing them.",
        "ground_truth_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Applied Deep Learning ' AND T2.grade = 'C'",
        "difficulty": ""
    },
    {
        "question": "How many 4-year public institutions are there in the state of Florida? Give all of their names.",
        "hint": "4-year refers to level = '4-year'; public refers to control = 'Public'; names refers to chronname;",
        "error_sql": "SELECT COUNT(T1.chronname), T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON T1.state = T2.state WHERE T1.state = 'FL' AND T1.level = '4-year' AND T2.control = 'Public'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and that the columns being joined are from the correct tables. In this case, the error was in the join condition and the selection of columns. The correct join condition should be based on the state_sector_details table, and the columns being selected should only be from the institution_details table. Additionally, the control column should be from the institution_details table, not the state_sector_details table. To avoid making the same mistake in the future, double-check the join conditions and the columns being selected to ensure they are correct and from the correct tables.",
        "ground_truth_sql": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 WHERE T2.level = '4-year' AND T2.control = 'Public' AND T2.state = 'Florida'",
        "difficulty": ""
    },
    {
        "question": "Indicate the quantity of Blade products sold.",
        "hint": "Blade' is name of product;",
        "error_sql": "SELECT SUM(T1.Quantity) FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'Blade'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and performing an aggregation operation, ensure that the column being aggregated is from the correct table. In this case, the `Quantity` column is in the `Sales` table, not the `Products` table. Additionally, when retrieving a single value, use `SELECT DISTINCT` or `SELECT` with a `GROUP BY` clause instead of `SUM` to avoid summing up all quantities. However, in this case, the correct approach would be to use `SELECT SUM` if you want to get the total quantity of 'Blade' products sold, not `SELECT DISTINCT` or `SELECT` with a `GROUP BY` clause. The correct query should be the Error SQL Query.",
        "ground_truth_sql": "SELECT DISTINCT T2.Quantity FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Blade'",
        "difficulty": ""
    },
    {
        "question": "What is the ratio of female users to male users who uses a vivo device?",
        "hint": "ratio = DIVIDE(SUM(gender = 'M' WHERE phone_brand = 'vivo'), SUM(gender = 'F' WHERE phone_brand = 'vivo')); female refers to gender = 'F'; male refers to gender = 'M'; vivo device refers to phone_brand = 'vivo';",
        "error_sql": "SELECT CAST(SUM(IIF(T1.gender = 'F' AND T2.phone_brand = 'vivo', 1, 0)) AS REAL) / SUM(IIF(T1.gender = 'M' AND T2.phone_brand = 'vivo', 1, 0)) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating ratios, ensure that the conditions for both the numerator and denominator are correctly applied. In this case, the error was due to the incorrect application of the condition for the phone brand 'vivo' in the SQL query. The condition should be applied in the WHERE clause, not within the IIF function. Additionally, the ratio calculation was incorrect, as it was calculating the ratio of female to male users, whereas the question asked for the ratio of female users to male users. To avoid this mistake, carefully review the conditions and calculations in the SQL query to ensure they align with the problem requirements.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "difficulty": ""
    },
    {
        "question": "What is the inventory ID of Karen Jackson?",
        "hint": "",
        "error_sql": "SELECT T1.inventory_id FROM inventory AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN film_actor AS T3 ON T2.film_id = T3.film_id INNER JOIN actor AS T4 ON T3.actor_id = T4.actor_id WHERE T4.first_name = 'KAREN' AND T4.last_name = 'JACKSON'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join is based on the correct relationships between the tables. In this case, the error SQL query joined the inventory table with the film, film_actor, and actor tables, but the correct join should be between the customer table and the rental table, as the customer's name is stored in the customer table and the inventory ID is stored in the rental table. Always carefully examine the schema and relationships between tables to avoid incorrect joins.",
        "ground_truth_sql": "SELECT T2.inventory_id FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'KAREN' AND T1.last_name = 'JACKSON'",
        "difficulty": ""
    },
    {
        "question": "How many teams did the team with the most victories in 1915 play against?\nIndicate the name of the team who won the most games in 1915, as well as the names of the opposing team.",
        "hint": "team playing refers to tmID; oppositng team refers to oppID; victories' and 'wins' are synonyms; most victories refers to max(w)",
        "error_sql": "SELECT COUNT(T2.oppID), T1.name, T2.oppID \nFROM Teams AS T1 \nINNER JOIN TeamVsTeam AS T2 \nON T1.tmID = T2.tmID \nWHERE T1.year = 1915 AND T1.W = ( SELECT MAX(W) FROM Teams WHERE year = 1915 )",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the team with the most victories in a specific year and the number of teams they played against, it's essential to consider the following:\n\n1.  **Grouping**: Group the results by the team ID to ensure that the count of opposing teams is accurate for each team.\n2.  **Ordering**: Order the results by the sum of wins in descending order to find the team with the most victories.\n3.  **Limiting**: Limit the results to the top team with the most victories.\n4.  **Distinct Count**: Use a distinct count to ensure that each opposing team is only counted once.\n5.  **Joining**: Join the Teams table with the TeamVsTeam table on both the year and team ID to ensure accurate matching.\n\nBy considering these factors, you can avoid making the same mistake in the future and ensure that your SQL queries produce accurate results.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT oppID), T2.tmID, T2.oppID FROM Teams AS T1 INNER JOIN TeamVsTeam AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID WHERE T2.year = 1915 GROUP BY T2.tmID, T2.oppID ORDER BY SUM(T2.W) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "List out the phone number of the shipping company of order id 10296.",
        "hint": "shipping company refers to Shippers; phone number refers to Phone",
        "error_sql": "SELECT T3.Phone FROM Orders AS T1 INNER JOIN OrderDetails AS T2 ON T1.OrderID = T2.OrderID INNER JOIN Shippers AS T3 ON T1.ShipperID = T3.ShipperID WHERE T1.OrderID = 10296",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct column is used for the join condition. In this case, the correct column to join the Orders table with the Shippers table is ShipVia, not ShipperID. Additionally, verify the accuracy of the WHERE clause condition, as the OrderID in the Error SQL Query and SQL after Reflection was incorrect. Always double-check the table schema and the query conditions to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.Phone FROM Orders AS T1 INNER JOIN Shippers AS T2 ON T1.ShipVia = T2.ShipperID WHERE T1.OrderID = 10260",
        "difficulty": ""
    },
    {
        "question": "Which different vendor has the most amount of orders? Calculate the total estimated earnings.",
        "hint": "amount of order refers to quantityOrdered; most amount of orders refers to SUM(QuantityOrdered); estimated earnings refers to expected profits; expected profits = SUBTRACT(msrp, buyPrice);",
        "error_sql": "SELECT T1.productVendor, SUM(T1.MSRP * T2.quantityOrdered - T1.buyPrice * T2.quantityOrdered) \nFROM products AS T1 \nINNER JOIN `orderdetails` AS T2 \nON T1.productCode = T2.productCode \nGROUP BY T1.productVendor \nORDER BY SUM(T2.quantityOrdered) DESC \nLIMIT 1",
        "compiler_hint": "no such column: T2.MSRP",
        "reflective_cot": "### Tip: \nWhen calculating the total estimated earnings, it's essential to understand that the earnings per product are the difference between the MSRP and the buyPrice, and this difference should be multiplied by the quantityOrdered. However, the SQL after Reflection still incorrectly multiplies the quantityInStock by the MSRP, which is not relevant to the calculation. To avoid this mistake, carefully analyze the problem and identify the relevant columns and their relationships. In this case, the correct calculation should be the difference between the MSRP and the buyPrice, multiplied by the quantityOrdered, and then summed for each vendor. The Ground Truth SQL correctly calculates the difference between the MSRP and the buyPrice for each product and then orders the results by the count of quantityOrdered in descending order, effectively finding the vendor with the most orders and the estimated earnings per product.",
        "ground_truth_sql": "SELECT DISTINCT T1.productVendor, T1.MSRP - T1.buyPrice FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode GROUP BY T1.productVendor, T1.MSRP, T1.buyPrice ORDER BY COUNT(T2.quantityOrdered) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many male employees have the job position of sales person?",
        "hint": "Sales person refers to PersonType = 'SP'; Male refers to Gender = 'M';",
        "error_sql": "SELECT COUNT(BusinessEntityID) FROM Employee WHERE JobTitle = 'Sales Person' AND Gender = 'M'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns used in the WHERE clause are from the correct tables. In this case, the error was due to using the wrong column (JobTitle) to filter for sales persons, instead of using the PersonType column from the Person table. Additionally, the Gender column should be from the Employee table, not the Person table. Always verify the schema and the relationships between tables to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'M' AND T2.PersonType = 'SP'",
        "difficulty": ""
    },
    {
        "question": "How many times of repetition does the word \"exemple\" show in the Catalan language?",
        "hint": "exemple refers to word = 'exemple'; repetition refers to langs_words.occurrences; lid = 1 menas it's Catalan language",
        "error_sql": "SELECT T1.occurrences FROM langs_words AS T1 INNER JOIN langs AS T2 ON T1.lid = T2.lid INNER JOIN words AS T3 ON T1.wid = T3.wid WHERE T2.lang = 'Catalan' AND T3.word = 'exemple'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and the columns used for joining are correct. In this case, the error was due to incorrect join order and not using the correct lid value directly. To avoid this mistake, carefully analyze the table relationships and the query requirements, and make sure to use the most efficient and correct join order. Additionally, when possible, use the actual values (e.g., lid = 1) instead of joining another table to get that value, as it can simplify the query and reduce the chance of errors.",
        "ground_truth_sql": "SELECT T2.occurrences FROM words AS T1 INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE T1.word = 'exemple' AND T2.lid = 1",
        "difficulty": ""
    },
    {
        "question": "How many items did Customer#000021159 order? Calculate those items total charges.",
        "hint": "items Customer#000021159 order refer to l_linenumber where c_name = 'Customer#000021159'; SUM(MULTIPLY(MULTIPLY(l_extendedprice, SUBTRACT(1, l_discount)), SUM(1, l_tax))) where c_name = 'Customer#000021159';",
        "error_sql": "SELECT COUNT(T3.l_linenumber), SUM(T3.l_extendedprice * (1 - T3.l_discount) * (1 + T3.l_tax)) \nFROM customer AS T1 \nINNER JOIN orders AS T2 \nON T1.c_custkey = T2.o_custkey \nINNER JOIN lineitem AS T3 \nON T2.o_orderkey = T3.l_orderkey \nWHERE T1.c_name = 'Customer#000021159'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables and performing aggregation operations, ensure that you are grouping by the correct columns to avoid incorrect results. In this case, the initial query was missing the GROUP BY clause, and the column used in the COUNT function was incorrect. The corrected query groups by the order key and counts the number of orders, while also summing the total charges for each order. To avoid similar mistakes, always verify the logic of your query and ensure that you are grouping by the correct columns when performing aggregation operations.",
        "ground_truth_sql": "SELECT COUNT(T2.o_orderkey), SUM(T3.l_extendedprice * (1 - T3.l_discount) * (1 + T3.l_tax)) FROM customer AS T1 INNER JOIN orders AS T2 ON T1.c_custkey = T2.o_custkey INNER JOIN lineitem AS T3 ON T2.o_orderkey = T3.l_orderkey WHERE T1.c_name = 'Customer#000021159' GROUP BY T3.l_linenumber",
        "difficulty": ""
    },
    {
        "question": "Indicate the name of the country where Leka Trading supplies Ipoh Coffee product.",
        "hint": "'Leka Trading' is a CompanyName; 'Ipoh Coffee' is a ProductName",
        "error_sql": "SELECT T4.Country FROM Suppliers AS T1 INNER JOIN Products AS T2 ON T1.SupplierID = T2.SupplierID INNER JOIN OrderDetails AS T3 ON T2.ProductID = T3.ProductID INNER JOIN Orders AS T4a ON T3.OrderID = T4a.OrderID INNER JOIN Customers AS T4 ON T4a.CustomerID = T4.CustomerID WHERE T1.SupplierName = 'Leka Trading' AND T2.ProductName = 'Ipoh Coffee'",
        "compiler_hint": "no such column: T1.CompanyName",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the WHERE clause match the actual column names in the tables being joined. In this case, the error occurred because 'CompanyName' does not exist in the 'Suppliers' table, it should be 'SupplierName'. Also, the 'Country' column is in the 'Suppliers' table, not in the 'Customers' table. Always double-check the schema of the database to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.Country FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.ProductName = 'Ipoh Coffee' AND T2.CompanyName = 'Leka Trading'",
        "difficulty": ""
    },
    {
        "question": "Provide the price and country origin of the car named Ford Maverick.",
        "hint": "country origin refers to country; Ford Maverick refers to car_name = 'ford maverick'",
        "error_sql": "SELECT T1.price, T3.country FROM price AS T1 INNER JOIN data AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.ID WHERE T2.car_name = 'Ford Maverick'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and the tables are joined in the correct order. In this case, the error was due to incorrect join conditions and order. The production table is the bridge between the data table and the country table, so it should be joined first. Additionally, the country origin is stored in the production table, not in the data table. To avoid this mistake, carefully analyze the schema and the relationships between the tables before writing the SQL query. Also, make sure to handle case sensitivity when comparing string values, as in this case, the car_name 'Ford Maverick' was compared with 'ford maverick'.",
        "ground_truth_sql": "SELECT DISTINCT T1.price, T3.country FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE T4.car_name = 'ford maverick'",
        "difficulty": ""
    },
    {
        "question": "What are the titles and genres of the one-act works of Shakespeare?",
        "hint": "one-act works refers to count(Act) = 1; genre refers to GenreType\n",
        "error_sql": "SELECT T1.Title, T1.GenreType FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id GROUP BY T1.Title, T1.GenreType HAVING COUNT(T2.Act) = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and applying a filter condition, consider whether the condition should be applied before or after the join. In this case, the condition `T2.Act = 1` should be applied before the join to ensure that only rows with `Act = 1` are considered. However, the initial query used `HAVING COUNT(T2.Act) = 1`, which is incorrect because it counts the number of acts, not filters by act. The second query used `WHERE T2.Act = 1`, but it's still incorrect because it doesn't account for the possibility of multiple acts in a work. The correct query uses `SELECT DISTINCT` to ensure that each title and genre is only returned once, and the `WHERE` clause to filter by act before the join. To avoid this mistake, carefully consider the logic of the query and the relationships between the tables.",
        "ground_truth_sql": "SELECT DISTINCT T1.Title, T1.GenreType FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = 1",
        "difficulty": ""
    },
    {
        "question": "How many images have less than 15 object samples?",
        "hint": "images refer to IMG_ID; less than 15 object samples refer to COUNT(OBJ_SAMPLE_ID) < 15;",
        "error_sql": "SELECT COUNT(IMG_ID) FROM ( SELECT IMG_ID, COUNT(OBJ_SAMPLE_ID) AS OBJ_SAMPLE_COUNT FROM IMG_OBJ GROUP BY IMG_ID ) WHERE OBJ_SAMPLE_COUNT < 15",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, carefully consider the conditions and constraints. In this case, the condition is \"images have less than 15 object samples\", which means we need to count the number of object samples for each image and then filter the images with a count less than 15. However, the condition OBJ_SAMPLE_ID < 15 is incorrect because OBJ_SAMPLE_ID is not the count of object samples, but rather a unique identifier for each object sample. The correct approach is to use the HAVING clause with a subquery or a GROUP BY clause to count the object samples for each image, as in the SQL after Reflection. However, the SQL after Reflection is still incorrect because it uses a subquery which is not necessary. A better approach is to use the GROUP BY and HAVING clauses directly on the IMG_OBJ table. The correct SQL query would be: SELECT COUNT(IMG_ID) FROM IMG_OBJ GROUP BY IMG_ID HAVING COUNT(OBJ_SAMPLE_ID) < 15",
        "ground_truth_sql": "SELECT COUNT(IMG_ID) FROM IMG_OBJ WHERE OBJ_SAMPLE_ID < 15",
        "difficulty": ""
    },
    {
        "question": "How much time do businesses in El Mirage City, AZ State operate in average daily?",
        "hint": "how much time does this business open refers to SUBTRACT(closing_time, opening_time); DIVIDE(SUM(SUBTRACT(closing_time, opening_time)), SUM(Business.business_id))",
        "error_sql": "SELECT CAST(SUM(SUBSTR(T2.closing_time, INSTR(T2.closing_time, ':') + 1) * 60 + SUBSTR(T2.closing_time, 1, INSTR(T2.closing_time, ':') - 1) - SUBSTR(T2.opening_time, INSTR(T2.opening_time, ':') + 1) * 60 - SUBSTR(T2.opening_time, 1, INSTR(T2.opening_time, ':') - 1)) AS REAL) / COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen working with time data in SQL, be aware of the data type and format of the time columns. In this case, the `closing_time` and `opening_time` columns are likely stored as strings in the format 'HH:MM'. However, the initial query attempted to perform arithmetic operations on these strings, which is incorrect. The corrected query should take into account the format of the time data and perform the necessary conversions or calculations accordingly. Additionally, the use of `SUBSTR` and `INSTR` functions to extract the hour and minute components is unnecessary if the database management system supports date and time arithmetic operations. In this case, the ground truth SQL query simply subtracts the `opening_time` from the `closing_time`, assuming that the database management system can perform date and time arithmetic operations correctly.",
        "ground_truth_sql": "SELECT SUM(T2.closing_time - T2.opening_time) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of device users in the F27-28 age group who experienced an event on the 3rd of May 2016?",
        "hint": "percentage = MULTIPLY(DIVIDE(SUM(`group` = 'F27-28'), COUNT(device_id)), 1.0); on the 3rd of May 2016 refers to timestamp = '2016-05-03%';",
        "error_sql": "SELECT CAST(SUM(IIF(T1.`group` = 'F27-28', 1, 0)) AS REAL) / COUNT(T1.device_id) * 1.0 FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE T2.timestamp LIKE '2016-05-03%'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined based on the problem requirements. In this case, the error was joining `events` instead of `events_relevant` which is the correct table to join with `gender_age`. Additionally, when filtering dates, use the correct date format and function to extract the date part, in this case, using `SUBSTR` to extract the first 10 characters of the timestamp. Also, be mindful of the calculation order, in this case, the multiplication by 100 should be done before the division to get the correct percentage.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.`group` = 'F27-28', 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE SUBSTR(T2.timestamp, 1, 10) = '2016-05-03'",
        "difficulty": ""
    },
    {
        "question": "What is the salary rate per hour that the company paid to the first 5 employees that they hired?",
        "hint": "salary rate per hour refers to Rate; first 5 employees that were hired refers to 5 oldest HireDate;",
        "error_sql": "SELECT Rate FROM EmployeePayHistory ORDER BY RateChangeDate LIMIT 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that you are joining on the correct columns and that you are including all necessary tables to accurately retrieve the desired data. In this case, the EmployeePayHistory table needs to be joined with the Employee table to access the HireDate, and the Employee table also needs to be joined with the Person table to ensure that the BusinessEntityID is correctly matched. Additionally, the ORDER BY clause should be used in conjunction with the LIMIT clause to ensure that the correct 5 employees are being selected based on their HireDate.",
        "ground_truth_sql": "SELECT T1.Rate FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID ORDER BY T2.HireDate ASC LIMIT 0, 5",
        "difficulty": ""
    },
    {
        "question": "What is the full address of the office where the employee who is a sales representative for the customer whose business is located in the city of New York works?",
        "hint": "full address = addressLine1 + addressLine2; NYC is a shortname of New York City.",
        "error_sql": "SELECT T1.addressLine1 || ', ' || T1.addressLine2 FROM offices AS T1 INNER JOIN employees AS T2 ON T1.officeCode = T2.officeCode INNER JOIN customers AS T3 ON T2.employeeNumber = T3.salesRepEmployeeNumber WHERE T3.city = 'New York'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions and the tables being joined are correct. In this case, the error was in the join order and the conditions. The correct join order is employees -> customers -> offices, and the condition should be T2.city = 'NYC' instead of T3.city = 'New York'. Additionally, the job title condition should be included to filter the employees who are sales representatives. Always carefully review the table relationships and the join conditions to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.addressLine1, T2.addressLine2 FROM employees AS T1 INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber INNER JOIN offices AS T3 ON T1.officeCode = T3.officeCode WHERE T2.city = 'NYC' AND T1.jobTitle = 'Sales Rep'",
        "difficulty": ""
    },
    {
        "question": "Which distinct state makes beer that has the least amount of bitterness?",
        "hint": "",
        "error_sql": "SELECT DISTINCT T1.state FROM breweries AS T1 INNER JOIN beers AS T2 ON T1.id = T2.brewery_id ORDER BY T2.ibu ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully consider the requirements of the query. In this case, the task was to find the distinct state that produces the beer with the least amount of bitterness. The initial error was in the ORDER BY and LIMIT approach, which would only return one state, even if multiple states produce beers with the same minimum bitterness. The second attempt was closer, but it didn't return the actual ibu value, which is necessary to verify the correctness of the result. To avoid similar mistakes, always make sure to include all required columns in the SELECT statement and use subqueries or joins to ensure that the result set includes all possible answers, not just one.",
        "ground_truth_sql": "SELECT DISTINCT T2.state, T1.ibu FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T1.ibu IS NOT NULL AND T1.ibu = ( SELECT MIN(ibu) FROM beers )",
        "difficulty": ""
    },
    {
        "question": "When did the earliest complaint start on 2017/3/22?",
        "hint": "earliest complaint refers to oldest ser_start; on 2017/3/22 refers to \"Date received\" = '2017-03-22';",
        "error_sql": "SELECT MIN(ser_start) FROM callcenterlogs WHERE `Date received` = '2017-03-22'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, carefully read the question and understand what is being asked. In this case, the question asks for the earliest complaint start time on a specific date, but the provided SQL queries return the minimum service start time (ser_start) or service time (ser_time). However, the correct interpretation is that the earliest complaint start time refers to the oldest service start time (ser_start) or the shortest service time (ser_time) is not necessarily the earliest start time. The correct answer should be the minimum ser_start time. But the question asks for the earliest complaint start time, which is actually the minimum ser_start time among the complaints that started on '2017-03-22'. But the question also says \"When did the earliest complaint start\", which means we need to get the minimum ser_start time among all the complaints that were received on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum ser_start time among all the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'. But the question actually wants the time when the earliest complaint started, which is actually the minimum time among all the ser_start times of the complaints that were received on '2017-03-22' and also started on '2017-03-22'.",
        "ground_truth_sql": "SELECT MIN(ser_time) FROM callcenterlogs WHERE `Date received` = '2017-03-22'",
        "difficulty": ""
    },
    {
        "question": "What is the country location of the employee who handled order id 10257?",
        "hint": "",
        "error_sql": "SELECT T4.Country FROM Orders AS T1 INNER JOIN Employees AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Customers AS T3 ON T2.EmployeeID = T3.CustomerID INNER JOIN Suppliers AS T4 ON T3.Country = T4.Country WHERE T1.OrderID = 10257",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and that the tables are joined in the correct order. In this case, the error was due to joining the Employees table with the Customers table and then with the Suppliers table, which is not necessary and incorrect. The correct join is between the Orders table and the Employees table. Additionally, the country location is a column in the Employees table, not in the Suppliers table. To avoid this mistake, carefully analyze the table schema and the relationships between the tables, and ensure that the join conditions are correct and necessary.",
        "ground_truth_sql": "SELECT T1.Country FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE T2.OrderID = 10257",
        "difficulty": ""
    },
    {
        "question": "Identify the customer, which placed the largest order in terms of value.",
        "hint": "value refers to SUM(UnitPrice * Quantity * SUBTRACT(1, Discount)); the largest order in value refers to MAX(value)",
        "error_sql": "SELECT T3.CustomerName \nFROM OrderDetails AS T1 \nINNER JOIN Products AS T2 \nON T1.ProductID = T2.ProductID \nINNER JOIN Customers AS T3 \nON T3.CustomerID = T1.OrderID \nGROUP BY T3.CustomerName \nORDER BY SUM(T2.Price * T1.Quantity) DESC \nLIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and that the correct columns are being referenced. In the Error SQL Query, the join condition between Customers and Orders was incorrect, as it was joining on OrderID instead of CustomerID. Additionally, the Error SQL Query was missing the join with the Order Details table, which is necessary to calculate the total value of the order. The SQL after Reflection was closer to correct, but still had an error in the GROUP BY clause, as it should have been grouping by the CustomerID instead of the CompanyName. To avoid making the same mistake in the future, double-check the join conditions and ensure that the correct columns are being referenced, and also verify that the GROUP BY clause is grouping by the correct column.",
        "ground_truth_sql": "SELECT T1.CompanyName FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN `Order Details` AS T3 ON T2.OrderID = T3.OrderID GROUP BY T2.CustomerID ORDER BY SUM(T3.UnitPrice * T3.Quantity * (1 - T3.Discount)) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among professors with the highest teachability, how many of their students have high salary?",
        "hint": "highest teachability refers to MAX(teachability); high salary refers to salary = 'high';",
        "error_sql": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.teachingability = ( SELECT MAX(teachingability) FROM prof ) AND T1.salary = 'high'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with aggregate functions like MAX, MIN, or COUNT, and filtering based on these values, consider whether the query should be filtering the data before or after the aggregation. In this case, the query should first filter the professors with the highest teaching ability and then count the number of their students with high salary. However, the provided SQL queries were either filtering the professors after joining with the RA table or using ORDER BY and LIMIT to get the professors with the highest teaching ability, which is not the correct approach. The correct approach would be to first get the professors with the highest teaching ability and then join this result with the RA table to count the number of their students with high salary.",
        "ground_truth_sql": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T1.salary = 'high' ORDER BY T2.teachingability DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What percentage of sell orders on 04/04/2020 were for the state of New York?",
        "hint": "sales order on 04/04/2020 refers to OrderDate = '4/4/20'; 'New York' is\u00a0 the City Name; percentage = Divide (Sum(OrderNumber where City Name = 'New York'), Count (OrderNumber)) * 100",
        "error_sql": "SELECT CAST(SUM(IIF(T1.`City Name` = 'New York', 1, 0)) AS REAL) * 100 / COUNT(T2.OrderNumber) FROM `Store Locations` AS T1 INNER JOIN `Sales Orders` AS T2 ON T1.StoreID = T2._StoreID WHERE T2.OrderDate = '4/4/20'",
        "compiler_hint": "no such column: T1.OrderNumber",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column references in the SELECT, WHERE, and CASE statements match the table aliases used in the JOIN clause. In this case, the error occurred because the column references were swapped between the two tables. To avoid this mistake, carefully review the table aliases and column references to ensure consistency throughout the query. Additionally, verify that the column names and table aliases match the actual column names and table structures in the database schema.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.State = 'New York' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T1.OrderDate = '4/4/20'",
        "difficulty": ""
    },
    {
        "question": "How many employees have salary greater than 70000 but fail the inspection?",
        "hint": "salary greater than 70000 refers to salary > 70000; fail the inspection refers to results = 'Fail'",
        "error_sql": "SELECT COUNT(T1.employee_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T1.salary > 70000 AND T2.results = 'Fail'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and counting distinct values, ensure that the join is correct and the distinct count is applied to the correct column. In this case, the error was not in the join or the distinct count, but rather in the order of the conditions in the WHERE clause. However, the order of conditions in the WHERE clause does not affect the result. The issue with the first two queries is that they are counting the number of inspections that failed, not the number of employees who failed an inspection and have a salary greater than 70000. To fix this, we need to ensure that we are counting distinct employees, not distinct inspections. The correct query is already provided as the Ground Truth SQL. The key takeaway is to carefully consider what you are counting and ensure that it aligns with the question being asked.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.employee_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.results = 'Fail' AND T1.salary > 70000",
        "difficulty": ""
    },
    {
        "question": "How many users, who were a paying subscriber when they rated the movie, gave the movie that was released in 1924 and directed by Erich von Stroheim a rating score of 5?",
        "hint": "Directed by Buster Keaton refers to director_name; released in 1924 refers to movie_release_year = 1924; paying subscriber refers to user_has_payment_method = 1\n\n",
        "error_sql": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T1.user_id = T3.user_id WHERE T2.movie_release_year = 1924 AND T2.director_name = 'Erich von Stroheim' AND T1.rating_score = 5 AND T3.user_has_payment_method = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the column names and table aliases are correctly referenced. In this case, the error occurred because the `user_has_payment_method` column was referenced from the `ratings` table instead of the `ratings_users` table. Additionally, the `COUNT` function was referencing the wrong table alias. To avoid this mistake, double-check the table aliases and column names in the query, and ensure that the correct tables are being referenced.",
        "ground_truth_sql": "SELECT COUNT(T2.user_id) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T1.movie_release_year = 1924 AND T1.director_name = 'Erich von Stroheim' AND T2.rating_score = 5 AND T2.user_has_payment_method = 1",
        "difficulty": ""
    },
    {
        "question": "Which supplier supplies the most amount of products?",
        "hint": "supplier refers to SupplierID; most amount refers to max(count(ProductID))",
        "error_sql": "SELECT SupplierID FROM Products GROUP BY SupplierID ORDER BY COUNT(ProductID) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, it's essential to carefully consider the columns being referenced in the SELECT, GROUP BY, and ORDER BY clauses. In this case, the error occurred because the query was trying to return the SupplierID instead of the SupplierName, and also because the COUNT function was referencing the wrong column (ProductID instead of ProductName). To avoid this mistake, always ensure that the columns being referenced match the desired output, and double-check the table schema to confirm the correct column names. Additionally, when joining tables, make sure to include all necessary columns in the GROUP BY clause to avoid errors.",
        "ground_truth_sql": "SELECT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID GROUP BY T2.SupplierID, T2.CompanyName ORDER BY COUNT(T1.ProductName) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Who directed the movie with the most voice actors?",
        "hint": "who directed refers director;",
        "error_sql": "SELECT T1.director FROM director AS T1 INNER JOIN \"voice-actors\" AS T2 ON T1.name = T2.movie GROUP BY T1.director ORDER BY COUNT(T2.`voice-actor`) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns being joined are the correct ones. In this case, the initial error was joining on `T1.movie = T2.name` instead of `T1.movie = T2.name` and also not selecting the count of voice actors. The second attempt was close but still incorrect as it didn't select the count of voice actors. To avoid this mistake, double-check the schema of the tables being joined and ensure that the join condition is correct. Also, make sure to select all the required columns in the final query.",
        "ground_truth_sql": "SELECT T2.director, COUNT(DISTINCT T1.`voice-actor`) FROM `voice-actors` AS T1 INNER JOIN director AS T2 ON T1.movie = T2.name GROUP BY T2.director ORDER BY COUNT(DISTINCT T1.`voice-actor`) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What percentage of students are highly satisfied with the Intro to Database 2 course?",
        "hint": "percentage = MULTIPLY(DIVIDE(COUNT(MAX(sat)), (COUNT(student_id))), 1.0); highly satisfied refers to MAX(sat);",
        "error_sql": "SELECT CAST(COUNT(T1.student_id) AS REAL) / (SELECT COUNT(student_id) FROM registration WHERE course_id = (SELECT course_id FROM course WHERE name = 'Intro to Database 2')) * 1.0 FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.name = 'Intro to Database 2' AND T1.sat = (SELECT MAX(sat) FROM registration AS T3 INNER JOIN course AS T4 ON T3.course_id = T4.course_id WHERE T4.name = 'Intro to Database 2')",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that the numerator and denominator are correctly aligned with the problem's requirements. In this case, the numerator should represent the count of highly satisfied students, and the denominator should represent the total number of students who took the course. Avoid mistakenly using the count of students who took the course as the numerator and the total count of students who took the course as the denominator. Additionally, be cautious when using subqueries and joins to ensure that the logic is correct and the results are accurate.",
        "ground_truth_sql": "SELECT CAST(( SELECT COUNT(*) FROM course WHERE name = 'Intro to Database 2' AND course_id IN ( SELECT course_id FROM registration WHERE sat = ( SELECT MAX(sat) FROM registration ) ) ) AS REAL) * 100  / COUNT(T1.student_id) FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.name = 'Intro to Database 2'",
        "difficulty": ""
    },
    {
        "question": "What kind of preparation is needed for apple juice to make a raspberry-pear couscous cake?",
        "hint": "apple juice is a name of an ingredient; raspberry-pear couscous cake refers to title",
        "error_sql": "SELECT T3.preparation FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T2.ingredient_id = T3.ingredient_id WHERE T1.title = 'raspberry-pear couscous cake' AND T3.name = 'apple juice'",
        "compiler_hint": "no such column: T3.preparation",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column references are correct and match the table aliases used in the query. In this case, the error occurred because the `preparation` column was referenced from the wrong table alias (`T3` instead of `T2`). To avoid this mistake, double-check the table aliases and column references in the query, and make sure they match the actual table structures and column names. Additionally, verify that the join conditions are correct and that the correct tables are being joined.",
        "ground_truth_sql": "SELECT T2.preparation FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.title = 'Raspberry-Pear Couscous Cake' AND T3.name = 'apple juice'",
        "difficulty": ""
    },
    {
        "question": "State the male population for all zip code which were under the Berlin, NH CBSA.",
        "hint": "\"Berlin, NH\" is the CBSA_name",
        "error_sql": "SELECT T1.zip_code, T1.male_population FROM zip_data AS T1 INNER JOIN CBSA AS T2 ON T1.CBSA = T2.CBSA WHERE T2.CBSA_name = 'Berlin, NH'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the column names and aliases are correctly referenced in the SELECT statement. In this case, the error was due to the incorrect alias used in the SELECT statement. The correct alias should be used consistently throughout the query. Additionally, when grouping data, ensure that all non-aggregated columns are included in the GROUP BY clause. In this case, the GROUP BY clause was missing, which would have caused an error if the query had been executed.",
        "ground_truth_sql": "SELECT T2.male_population FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Berlin, NH' GROUP BY T2.male_population",
        "difficulty": ""
    },
    {
        "question": "What is the total number of game played for players from USA?",
        "hint": "game played refers to GP; from USA refers to birthCountry = 'USA';",
        "error_sql": "SELECT SUM(T1.GP) FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T2.birthCountry = 'USA'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen aggregating data, ensure that the correct aggregation function is used. In this case, the task asks for the total number of games played, but the provided SQL queries use `SUM` and `COUNT` incorrectly. `SUM` is used to add up numerical values, whereas `COUNT` is used to count the number of rows. Since `GP` is a numerical value, `SUM` is the correct function to use. However, the correct SQL query should use `SUM` instead of `COUNT`. The correct SQL query should be: `SELECT SUM(T2.GP) FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCountry = 'USA'`.",
        "ground_truth_sql": "SELECT COUNT(T2.GP) FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCountry = 'USA'",
        "difficulty": ""
    },
    {
        "question": "List all the order numbers along with its product name for each order under the sales team of 'Douglas Tucker'.",
        "hint": "",
        "error_sql": "SELECT T1.OrderNumber, T4.`Product Name` \nFROM `Sales Orders` AS T1 \nINNER JOIN `Sales Team` AS T2 \nON T1._SalesTeamID = T2.SalesTeamID \nINNER JOIN Products AS T4 \nON T1._ProductID = T4.ProductID \nWHERE T2.`Sales Team` = 'Douglas Tucker'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the tables being joined are correct. In this case, the error was due to the incorrect assumption that the `Sales Orders` table should be the primary table. However, since we are filtering by `Sales Team` and then getting the corresponding `Product Name`, it makes more sense to start with the `Products` table and join it with the `Sales Orders` table, and then with the `Sales Team` table. This ensures that we are getting the correct products associated with the specified sales team.",
        "ground_truth_sql": "SELECT DISTINCT T1.ProductID, T1.`Product Name` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T3.`Sales Team` = 'Douglas Tucker'",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of historical works that have not fewer than five scenes in the 1500s?",
        "hint": "historical works refers to GenreType = 'history'; have not fewer than five scenes in the 1500s refers to count(Scene) > = 5 and DATE > = 1500 AND DATE < = 1599; percentage = divide(count(works.id) where GenreType = 'history' and count(Scene) > = 5, count(works.id) ) as percentage",
        "error_sql": "SELECT CAST(SUM(IIF(T1.GenreType = 'history' AND T2.SceneCount >= 5, 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN ( SELECT work_id, COUNT(Scene) AS SceneCount FROM chapters WHERE work_id IN ( SELECT id FROM works WHERE Date BETWEEN 1500 AND 1599 ) GROUP BY work_id ) AS T2 ON T1.id = T2.work_id",
        "compiler_hint": "no such column: DATE",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the filtering conditions are applied to the correct table. In this case, the `DATE` column is in the `works` table, not the `chapters` table. Therefore, the filtering condition `DATE BETWEEN 1500 AND 1599` should be applied to the `works` table, not the `chapters` table. Additionally, when calculating the percentage, make sure to count the total number of works that meet the filtering conditions, not just the total number of works. This can be achieved by applying the filtering conditions to the `works` table before joining it with the `chapters` table.",
        "ground_truth_sql": "SELECT CAST(( SELECT COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.GenreType = 'History' AND T1.DATE BETWEEN 1500 AND 1599 GROUP BY T1.id HAVING COUNT(T2.Scene) >= 5 ) AS REAL) * 100 / COUNT(id) FROM works WHERE GenreType = 'History' AND DATE BETWEEN 1500 AND 1599",
        "difficulty": ""
    },
    {
        "question": "List at least 3 categories with the lowest number of users.",
        "hint": "lowest number of users refers to MIN(COUNT(label_id));",
        "error_sql": "SELECT T1.category, COUNT(T1.label_id) FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.category ORDER BY COUNT(T1.label_id) ASC LIMIT 3",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully analyze the question and understand what is being asked. In this case, the question asks for categories with the lowest number of users, but the provided tables do not have a direct \"users\" column. The correct approach is to count the number of distinct app_ids (which can be considered as users) for each category. However, the correct SQL query does not even need to count or group by, it simply needs to order by the label_id and limit to 3, because the label_id is already a unique identifier for each category. The mistake in the previous queries was overcomplicating the problem by trying to count and group by, when a simple order by and limit would suffice.",
        "ground_truth_sql": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id ORDER BY T2.label_id LIMIT 3",
        "difficulty": ""
    },
    {
        "question": "Please list the business IDs of all the Yelp_Businesses that are good for kids.",
        "hint": "good for kids refers to attribute_name = 'Good for Kids' and attribute_value = 'true'\n",
        "error_sql": "SELECT T2.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name = 'Kids' AND T2.attribute_value = 'true'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and filtering data, ensure that the attribute names and values are accurately matched. In this case, the error was due to the incorrect attribute name 'Kids' instead of 'Good for Kids'. To avoid this mistake, double-check the schema and data to ensure that the attribute names and values are correctly referenced in the SQL query. Additionally, using the LIKE operator with the correct attribute name and value can help to accurately filter the data.",
        "ground_truth_sql": "SELECT T2.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name LIKE 'Good for Kids' AND T2.attribute_value LIKE 'TRUE'",
        "difficulty": ""
    },
    {
        "question": "Name the suppliers that supply products under the category 'cheeses.'",
        "hint": "suppliers refers to CompanyName; 'cheeses' is a Description",
        "error_sql": "SELECT T3.SupplierName FROM Categories AS T1 INNER JOIN Products AS T2 ON T1.CategoryID = T2.CategoryID INNER JOIN Suppliers AS T3 ON T2.SupplierID = T3.SupplierID WHERE T1.Description = 'Cheeses'",
        "compiler_hint": "no such column: T3.CompanyName",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the column names in the SELECT clause match the actual column names in the tables. In this case, the Suppliers table has a column named 'SupplierName', not 'CompanyName'. Also, pay attention to the order of the tables in the JOIN clause, as it can affect the column names available for selection.",
        "ground_truth_sql": "SELECT DISTINCT T1.CompanyName FROM Suppliers AS T1 INNER JOIN Products AS T2 ON T1.SupplierID = T2.SupplierID INNER JOIN Categories AS T3 ON T2.CategoryID = T3.CategoryID WHERE T3.Description = 'Cheeses'",
        "difficulty": ""
    },
    {
        "question": "Among the users who received high compliments from other users, which users joined Yelp earliest?",
        "hint": "high compliments refers to number_of_compliments = ' High'; joined Yelp earliest refers to min(user_yelping_since_year)",
        "error_sql": "SELECT T2.user_id FROM Users_Compliments AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T1.number_of_compliments = 'High' ORDER BY T2.user_yelping_since_year ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition is correct and the tables are joined in the correct order. In this case, the error was due to the incorrect order of the tables in the join condition. The correct order should be to join the Users table with the Users_Compliments table, not the other way around. Additionally, when using aggregate functions like MIN, ensure that the subquery is correctly formulated to return the desired result. In this case, the subquery should return the minimum user_yelping_since_year from the Users table, and then this value should be used to filter the results.",
        "ground_truth_sql": "SELECT T2.user_id FROM Users AS T1 INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id WHERE T2.number_of_compliments = 'High' AND T1.user_yelping_since_year = ( SELECT MIN(user_yelping_since_year) FROM Users )",
        "difficulty": ""
    },
    {
        "question": "What is the average star with highest percentage for episodes that have received award?",
        "hint": "received award refers to result = 'Winner'; the highest percentage refers to max(percent); average star = divide(sum(stars), count(episode_id))",
        "error_sql": "SELECT AVG(T1.stars / T1.votes) FROM Vote AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T2.result = 'Winner'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, it's essential to carefully read and understand the question, especially when it comes to aggregations and filtering. In this case, the question asks for the average star with the highest percentage for episodes that have received an award. However, the provided solutions incorrectly calculate the average star and fail to filter by the highest percentage. To avoid this mistake, break down the problem into smaller steps: (1) filter episodes that have received an award, (2) find the episode with the highest percentage, and (3) calculate the average star for that episode. Additionally, ensure that aggregations are correctly applied, and filtering conditions are accurately translated into SQL.",
        "ground_truth_sql": "SELECT T2.person_id FROM Vote AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id ORDER BY T1.percent DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the response and number of inhabitants of the oldest female customer?",
        "hint": "number of inhabitants refers to INHABITANTS_K; oldest female customer refers to SEX = 'Female' where MAX(age);",
        "error_sql": "SELECT T3.RESPONSE, T4.INHABITANTS_K FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN mailings3 AS T3 ON T2.REFID = T3.REFID INNER JOIN Demog AS T4 ON T1.GEOID = T4.GEOID WHERE T1.SEX = 'Female' ORDER BY T1.age DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and that the tables are joined in the correct order. In this case, the error was caused by joining `Mailings1_2` with `mailings3` instead of joining `Customers` with `Demog` directly. Also, verify that the column names and table aliases are correct to avoid confusion. To avoid this mistake, carefully review the schema and the relationships between tables before writing the SQL query.",
        "ground_truth_sql": "SELECT T2.RESPONSE, T3.INHABITANTS_K FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.SEX = 'Female' ORDER BY T1.age DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Please list any three episodes that have an excellent rating.",
        "hint": "an excellent rating refers to 7 < rating < = 10",
        "error_sql": "SELECT title FROM Episode WHERE rating > 7 AND rating <= 10 LIMIT 3",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen using the BETWEEN operator in SQL, it is inclusive of both the start and end values. However, in this case, the problem statement specifies that an excellent rating refers to 7 < rating <= 10, which means the start value (7) should be excluded. Therefore, the correct SQL query should use the greater than operator (>) for the start value and the less than or equal to operator (<=) for the end value, rather than the BETWEEN operator. The correct SQL query should be: SELECT title FROM Episode WHERE rating > 7 AND rating <= 10 LIMIT 3.",
        "ground_truth_sql": "SELECT title FROM Episode WHERE rating BETWEEN 7 AND 10 LIMIT 3;",
        "difficulty": ""
    },
    {
        "question": "What is the yearly average review done by user ID 3?",
        "hint": "yearly average review = Divide( Count(business_id), Subtract('%Y'(CURRENT_TIME), user_yelping_since_year))",
        "error_sql": "SELECT CAST(COUNT(T1.business_id) AS REAL) / (strftime('%Y', 'now') - T2.user_yelping_since_year) FROM Reviews AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T2.user_id = 3",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average review count per year for a user, ensure that you are counting the number of reviews (review_stars) and not the number of businesses (business_id). Also, avoid unnecessary casting to REAL, as it may not be required in this case.",
        "ground_truth_sql": "SELECT COUNT(review_stars) / (strftime('%Y', 'now') - T1.user_yelping_since_year) FROM Users AS T1 INNER JOIN Reviews AS T2 ON T1.user_id = T2.user_id WHERE T1.user_id = 3",
        "difficulty": ""
    },
    {
        "question": "Who are the suppliers of the discontinued products?",
        "hint": "discontinued product refers to Discontinued = 1; supplier refers to CompanyName",
        "error_sql": "SELECT T2.SupplierName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.Discontinued = 1",
        "compiler_hint": "no such column: T2.CompanyName",
        "reflective_cot": "### Tip: \nAlways carefully review the schema of the database before generating SQL queries. In this case, the error occurred because the column 'Discontinued' does not exist in the 'Products' table. Instead, the 'DiscontinuedDate' column is used to indicate discontinued products. However, the Ground Truth SQL suggests that 'Discontinued' should be used, which is not present in the provided schema. To avoid this mistake, ensure that the column names used in the SQL query match the actual column names in the database schema.",
        "ground_truth_sql": "SELECT DISTINCT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.Discontinued = 1",
        "difficulty": ""
    },
    {
        "question": "Please list out all annual indicator names of Sudan in 1961?",
        "hint": "Sudan is the name of the country; Periodicity = 'Annual'; Year = '1961'",
        "error_sql": "SELECT T3.IndicatorName FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN Series AS T3 ON T2.IndicatorCode = T3.SeriesCode WHERE T1.LongName = 'Sudan' AND T3.Periodicity = 'Annual' AND T2.Year = 1961",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and the columns being joined are of the same data type. In the Error SQL Query, the join condition `T2.IndicatorCode = T3.SeriesCode` is incorrect because `IndicatorCode` is not the same as `SeriesCode`. Also, the join condition `T1.IndicatorName = T2.IndicatorName` in the SQL after Reflection is also incorrect because `IndicatorName` is not a unique identifier in the `Series` table. To avoid this mistake, carefully examine the schema of the tables and ensure that the join conditions are correct and the columns being joined are of the same data type. Additionally, use the correct table and column names to avoid confusion. In this case, the correct join condition is `T1.IndicatorName = T2.IndicatorName` and `T1.CountryCode` should be joined with `Country` table to get the country name.",
        "ground_truth_sql": "SELECT T1.IndicatorName FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T1.CountryName = 'Sudan' AND T1.Year = 1961 AND T2.Periodicity = 'Annual'",
        "difficulty": ""
    },
    {
        "question": "Provide any 5 customers' full names who have rented from Mike Hillyer.",
        "hint": "full name refers to first_name, last_name; 'Mike Hillyer' is a full name of a staff;",
        "error_sql": "SELECT T1.first_name, T1.last_name \nFROM customer AS T1 \nINNER JOIN rental AS T2 \nON T1.customer_id = T2.customer_id \nINNER JOIN staff AS T3 \nON T2.staff_id = T3.staff_id \nWHERE T3.first_name = 'Mike' AND T3.last_name = 'Hillyer'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and that the tables are joined in the correct order. In this case, the error was due to the incorrect assumption that the staff table should be joined with the rental table, and then the rental table should be joined with the customer table. However, the correct join order is staff -> address -> customer. This is because the staff table is related to the address table, and the address table is related to the customer table. Always carefully examine the schema and relationships between tables to ensure correct join conditions and order.",
        "ground_truth_sql": "SELECT T3.first_name, T3.last_name FROM staff AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id WHERE T1.first_name = 'Mike' AND T1.last_name = 'Hillyer' LIMIT 5",
        "difficulty": ""
    },
    {
        "question": "Name the product from the 'Classic Cars' production line that has the greatest expected profit.",
        "hint": "The greatest expected profit refers to MAX(SUBTRACT(MSRP, buyPrice);",
        "error_sql": "SELECT productName FROM products WHERE productLine = 'Classic Cars' ORDER BY MSRP - buyPrice DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, it's essential to carefully consider the columns that need to be returned. In this case, the question asks for the product name with the greatest expected profit, but the expected profit itself is also a crucial piece of information. The initial query only returned the product name, whereas the correct query should return both the product name and the expected profit (calculated as MSRP - buyPrice). To avoid similar mistakes in the future, always ensure that the SELECT clause includes all the necessary columns to answer the question accurately.",
        "ground_truth_sql": "SELECT t.productName, t.MSRP - t.buyPrice FROM products AS t WHERE t.productLine = 'Classic Cars' ORDER BY t.MSRP - t.buyPrice DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the users who use SUGAR, calculate the percentage of those who are above 20 years old.",
        "hint": "SUGAR refers to phone_brand = 'SUGAR'; percentage = MULTIPLY(DIVIDE(SUM(age > 20), COUNT(device_id)) 1.0); above 20 years old refers to age > 20;",
        "error_sql": "SELECT CAST(SUM(IIF(T1.age > 20, 1, 0)) AS REAL) * 100 / COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'SUGAR'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that the division is performed as a floating-point operation to avoid integer division. However, in this case, the issue was not with the division, but rather with the unnecessary multiplication by 100 and casting to REAL. The correct approach is to simply divide the sum of ages greater than 20 by the total count of device IDs. Additionally, consider using a more explicit and readable way of calculating the percentage, such as using a CASE statement or a subquery, to improve code maintainability and readability.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'SUGAR'",
        "difficulty": ""
    },
    {
        "question": "How many owners have 5 or more establishments?",
        "hint": "5 or more establishments COUNT(business_id) > = 5;",
        "error_sql": "SELECT COUNT(owner_name) FROM businesses GROUP BY owner_name HAVING COUNT(business_id) >= 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using the HAVING clause to filter grouped results, ensure that the aggregated condition is correctly specified. In this case, the condition should be `COUNT(owner_name) > 5` instead of `COUNT(business_id) >= 5` or `COUNT(business_id) > 4`. This is because we want to count the number of owners who have more than 5 establishments, not the number of businesses. Additionally, the correct query should use a subquery to first group the results by owner_name and then count the number of owners who meet the condition.",
        "ground_truth_sql": "SELECT COUNT(T1.owner_name) FROM ( SELECT owner_name FROM businesses GROUP BY owner_name HAVING COUNT(owner_name) > 5 ) T1",
        "difficulty": ""
    },
    {
        "question": "Give the number of 30-year-old users who were active in the events on 2016/5/2.",
        "hint": "30-year-old refers to age = '30'; active refers to is_active = 1; on 2016/5/2 refers to timestamp = '2016/5/2 XX:XX:XX';",
        "error_sql": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events AS T3 ON T2.event_id = T3.event_id WHERE T1.age = 30 AND T3.is_active = 1 AND SUBSTR(T2.timestamp, 1, 10) = '2016-05-02'",
        "compiler_hint": null,
        "reflective_cot": "The tip is to carefully review the SQL query and consider the following points:\n\n1. **Table names and aliases**: Ensure that the table names and aliases used in the query are correct and consistent with the schema.\n2. **Join conditions**: Verify that the join conditions are correct and that the tables are being joined on the correct columns.\n3. **Query logic**: Double-check the query logic to ensure that it accurately represents the problem being solved.\n4. **Table order**: Consider the order of the tables in the query and whether it affects the result.\n5. **Read the problem carefully**: Make sure to read the problem statement carefully and understand the requirements before writing the query.\n\nIn this case, the mistake was made in the table names and the join conditions. The query should use the `events` table instead of `events_relevant` and the `app_events` table should be joined with the `events` table instead of the other way around.",
        "ground_truth_sql": "SELECT COUNT(T3.device_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-02' AND T1.is_active = 1 AND T3.age = '30'",
        "difficulty": ""
    },
    {
        "question": "Provide all the orders from WARE-NMK1003. Name the product and sales team for each of these order.",
        "hint": "all the orders from WARE-NMK1003 refer to OrderNumber where WarehouseCode = 'WARE-NMK1003'; product refers to Product Name;",
        "error_sql": "SELECT T1.OrderNumber, T3.`Product Name`, T4.`Sales Team` \nFROM `Sales Orders` AS T1 \nINNER JOIN Products AS T3 \nON T1._ProductID = T3.ProductID \nINNER JOIN `Sales Team` AS T4 \nON T1._SalesTeamID = T4.SalesTeamID \nWHERE T1.WarehouseCode = 'WARE-NMK1003'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table aliases (e.g., T1, T2, T3) are consistent across the entire query. In the Error SQL Query and SQL after Reflection, the aliases for the Products table were T3 and T2, respectively, but the correct alias should be T2 to maintain consistency. Additionally, the query should select the Product Name and Sales Team, not the OrderNumber, as per the problem statement.",
        "ground_truth_sql": "SELECT DISTINCT T1.`Product Name`, T3.`Sales Team` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T2.WarehouseCode = 'WARE-NMK1003'",
        "difficulty": ""
    },
    {
        "question": "How many servings does the recipe with the highest unsaturated fat have?",
        "hint": "with the highest unsaturated fat refers MAX(SUBTRACT(total_fat, sat_fat))",
        "error_sql": "SELECT T1.servings FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY (T2.total_fat - T2.sat_fat) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, it's essential to carefully read and understand the question. In this case, the question asks for the number of servings, but the provided Ground Truth SQL is incorrect. The correct interpretation is that the question asks for the number of servings of the recipe with the highest unsaturated fat, not the count of recipes. Therefore, the correct SQL query should return the servings column from the Recipe table, not the count of titles. Additionally, the correct calculation for unsaturated fat is indeed MAX(total_fat - sat_fat), but the question asks for the number of servings, not the maximum unsaturated fat value. The correct SQL query should be:\n\n```sql\nSELECT T1.servings FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY T2.total_fat - T2.sat_fat DESC LIMIT 1\n```\n\nHowever, this query is still not entirely correct. The correct query should be:\n\n```sql\nSELECT T1.servings FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY T2.total_fat - T2.sat_fat DESC LIMIT 1\n```\n\nis actually correct, the issue was with the Ground Truth SQL provided. The correct Tip is to always double-check the question and the provided Ground Truth SQL to ensure that the interpretation is correct.",
        "ground_truth_sql": "SELECT COUNT(T1.title) FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY T2.total_fat - T2.sat_fat DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the total trip duration made within Palo Alto city? Convert the duration to hour.",
        "hint": "total trip duration to hour = DIVIDE(SUM(duration), 3600);",
        "error_sql": "SELECT SUM(T1.duration) / 3600 FROM trip AS T1 INNER JOIN station AS T2 ON T1.start_station_id = T2.id WHERE T2.city = 'Palo Alto'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and considers the actual relationship between the tables. In this case, the initial query joined on `start_station_id`, but the correct join condition is on `start_station_name` because the `trip` table does not have a direct foreign key reference to the `station` table's `id` column. Additionally, using `LEFT JOIN` instead of `INNER JOIN` ensures that all trips starting in Palo Alto are included, even if there is no matching station in the `station` table.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.duration) AS REAL) / 3600 FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'Palo Alto'",
        "difficulty": ""
    },
    {
        "question": "Which country has the lowest percentage of arable land?",
        "hint": "which country refers to countryname; the lowest percentage of arable land refers to min(value where indicatorname = 'Arable land (% of land area)')",
        "error_sql": "SELECT CountryName FROM Indicators WHERE IndicatorName = 'Arable land (% of land area)' ORDER BY Value ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with queries that involve finding the minimum or maximum value, it's essential to consider the context of the data. In this case, the query is looking for the country with the lowest percentage of arable land. The mistake in the initial queries was in the ORDER BY clause, where it was sorting in ascending order (ASC) instead of descending order (DESC). This is because the lowest percentage would be the smallest value, and sorting in ascending order would return the country with the highest percentage. To avoid this mistake, always consider the context of the data and the desired outcome, and adjust the ORDER BY clause accordingly. Additionally, using LIKE instead of = for the IndicatorName can help to account for any slight variations in the indicator name.",
        "ground_truth_sql": "SELECT CountryName FROM Indicators WHERE IndicatorName LIKE 'Arable land (% of land area)' ORDER BY Value DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the average runs scored during the first half of all first innings.",
        "hint": "first half refers to 1 < Over_Id and Over_Id < 25; average = divide(sum(Over_Id) when 1 < Over_Id and Over_Id < 25, sum(Runs_Scored)) as percentage; first innings refers to Innings_No = 1",
        "error_sql": "SELECT CAST(SUM(CASE WHEN Over_Id BETWEEN 1 AND 25 THEN Runs_Scored ELSE 0 END) AS REAL) / SUM(Runs_Scored) FROM Batsman_Scored WHERE Innings_No = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating averages or percentages, ensure that you are dividing by the correct denominator. In this case, the mistake was dividing by the total runs scored (SUM(Runs_Scored)) instead of the total number of overs in the first half (COUNT(CASE WHEN 1 < Over_Id AND Over_Id < 25 THEN 1 ELSE NULL END)). To avoid this mistake, carefully consider what you are trying to calculate and ensure that your denominator accurately reflects the total number of units being averaged or the total number of occurrences being considered.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN 1 < Over_Id AND Over_Id < 25 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(Runs_Scored) FROM Batsman_Scored WHERE Innings_No = 1",
        "difficulty": ""
    },
    {
        "question": "Which 1,000,000,000+ intalls apps has the most no comment reviews?",
        "hint": "no comment refers to Translated_Review = 'nan'; most no comment reviews = (MAX(COUNT(Translated_Review = 'nan')));",
        "error_sql": "SELECT T1.App FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Installs = '1,000,000,000+' GROUP BY T1.App ORDER BY COUNT(CASE WHEN T2.Translated_Review = 'nan' THEN 1 END) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and filtering for a specific condition in one of the tables, ensure that the condition is applied before the join operation to avoid incorrect results. In this case, the condition `T2.Translated_Review = 'nan'` should be applied in the `WHERE` clause of a subquery on the `user_reviews` table before joining it with the `playstore` table. Additionally, be careful with the `Installs` value, as it seems there was a typo in the original query ('1,000,000,000+' instead of '1,000,000+').",
        "ground_truth_sql": "SELECT T1.App FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Installs = '1,000,000+' AND T2.Translated_Review = 'nan' GROUP BY T1.App ORDER BY COUNT(T2.Translated_Review) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many shipments were shipped to the most densely populated city?",
        "hint": "most densely populated city refers to Max(Divide(area, population))",
        "error_sql": "SELECT COUNT(T2.ship_id) FROM city AS T1 INNER JOIN shipment AS T2 ON T1.city_id = T2.city_id WHERE T1.area / T1.population = (SELECT MAX(area / population) FROM city)",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a calculated field (in this case, population density), it's generally more efficient and accurate to use ORDER BY and LIMIT instead of trying to join the table with a subquery that calculates the maximum or minimum value. This is because the subquery approach can be prone to errors if there are multiple rows with the same maximum or minimum value, or if the calculated field is not unique. By using ORDER BY and LIMIT, you can ensure that you get the correct result even in these edge cases. Additionally, this approach can also be more efficient because it avoids the need for a subquery.",
        "ground_truth_sql": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id ORDER BY T2.area / T2.population DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the area of Egypt as a percentage of Asia?",
        "hint": "",
        "error_sql": "SELECT CAST(T1.Area AS REAL) * 100 / T3.Area \nFROM country AS T1 \nINNER JOIN encompasses AS T2 ON T1.Code = T2.Country \nINNER JOIN continent AS T3 ON T2.Continent = T3.Name \nWHERE T1.Name = 'Egypt'",
        "compiler_hint": "no such column: T1.Continent",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join is performed on the correct columns and that these columns exist in the tables being joined. In this case, the error occurred because the `country` table does not have a `Continent` column, but instead, the `encompasses` table has a `Continent` column which should be joined with the `continent` table. Additionally, the `encompasses` table has a `Country` column which should be joined with the `country` table using the `Code` column.",
        "ground_truth_sql": "SELECT T2.Percentage FROM country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent WHERE T3.Name = 'Asia' AND T1.Name = 'Egypt'",
        "difficulty": ""
    },
    {
        "question": "How many users with a long tip and 2 likes for their tip have a high number of fans?",
        "hint": "long tip refers to tip_length = 'Long'; 2 likes refers to likes = 2; high number of fans refers to user_fans = 'High'",
        "error_sql": "SELECT COUNT(T1.user_id) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T2.tip_length = 'Long' AND T2.likes = 2 AND T1.user_fans = 'High'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and counting distinct values, always consider whether the join operation could result in duplicate rows. In this case, a user could have multiple tips with the same characteristics, resulting in duplicate rows when joining the Users and Tips tables. To avoid this, use the DISTINCT keyword when counting to ensure that each user is only counted once.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.user_id) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T2.tip_length = 'Long' AND T2.likes = 2 AND T1.user_fans = 'High'",
        "difficulty": ""
    },
    {
        "question": "List out the stop date of the care plan of dead patients.",
        "hint": "stop date of the care plan refers to careplans.STOP; dead patients refers to deathdate is not null;",
        "error_sql": "SELECT T2.STOP FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.deathdate IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table with the column of interest (in this case, careplans.STOP) is the primary table in the FROM clause, and the other table (patients) is the secondary table in the JOIN clause. This is because the primary table's columns are being selected, and the secondary table is being used to filter the results. In this case, the correct SQL query should start with \"SELECT DISTINCT T1.STOP FROM careplans AS T1\" instead of \"SELECT T2.STOP FROM patients AS T1\".",
        "ground_truth_sql": "SELECT DISTINCT T1.STOP FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NOT NULL AND T1.STOP IS NOT NULL",
        "difficulty": ""
    },
    {
        "question": "Calculate the average duration of absense of female students.",
        "hint": "average duration = DIVIDE(SUM(month), COUNT(longest_absence_from_school.name which are NOT in male.name)); female students refers to longest_absence_from_school.name who are NOT in male.name;",
        "error_sql": "SELECT CAST(SUM(IIF(T1.name NOT IN (SELECT name FROM male), T1.month, 0)) AS REAL) / COUNT(T1.name) FROM longest_absense_from_school AS T1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average value of a specific group, consider using the AVG() function directly on the filtered group instead of manually summing and counting the values. This approach can simplify the query and reduce the chance of errors. Additionally, use LEFT JOIN and WHERE clause to filter out the unwanted group (in this case, male students) instead of using IIF() or NOT IN() to conditionally sum the values.",
        "ground_truth_sql": "SELECT AVG(T2.month) FROM person AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE T3.name IS NULL",
        "difficulty": ""
    },
    {
        "question": "How many trains with fully loaded head cars are running east?",
        "hint": "fully loaded refers to load_num = 3; head cars refers to position = 1",
        "error_sql": "SELECT COUNT(T2.id) FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T1.load_num = 3 AND T2.direction = 'east'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen counting distinct entities, consider the table that directly contains the entity you want to count. In this case, the entity is 'trains', and it's directly contained in the 'cars' table through the 'train_id' foreign key. Therefore, counting distinct 'train_id' from the 'cars' table is more accurate than counting distinct 'id' from the 'trains' table. Additionally, since the 'direction' of the train is already filtered in the 'trains' table, there's no need to include it in the count query.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.train_id) FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T1.load_num = 3",
        "difficulty": ""
    },
    {
        "question": "Find and list the full name of customers who bought products above-average quantity.",
        "hint": "full name of the customer = FirstName, MiddleInitial, LastName; above-average quantity = Quantity > AVG(Quantity);",
        "error_sql": "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName \nFROM Customers AS T1 \nINNER JOIN Sales AS T2 \nON T1.CustomerID = T2.CustomerID \nWHERE T2.Quantity > (SELECT AVG(Quantity) FROM Sales)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen comparing a value to an aggregate function result, ensure that the comparison is done at the correct level of granularity. In this case, the comparison should be done at the individual sale level, not at the customer level. The original query was incorrect because it compared the average quantity across all sales to the quantity of each individual sale, which is not the correct interpretation of \"above-average quantity\". The second query was also incorrect because it compared the sum of quantities for each customer to the average quantity across all sales, which is still not the correct interpretation. The correct query should compare each individual sale's quantity to the average quantity across all sales, and then return the customers who have made such sales.",
        "ground_truth_sql": "SELECT T2.FirstName, T2.MiddleInitial, T2.LastName FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Quantity HAVING T1.Quantity > ( SELECT AVG(Quantity) FROM Sales )",
        "difficulty": ""
    },
    {
        "question": "Which indicator name uses the Weighted average method and has the lowest value?",
        "hint": "AggregationMethod = 'Weighted average'; the lowest value implies MIN(Value);",
        "error_sql": "SELECT T1.IndicatorName FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorCode = T2.SeriesCode WHERE T2.AggregationMethod = 'Weighted average' ORDER BY T1.Value ASC LIMIT 1",
        "compiler_hint": "ambiguous column name: IndicatorName",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the column names are unique or properly qualified with the table alias. In this case, the join condition should be based on the IndicatorName instead of IndicatorCode, and the MIN function should be used with the GROUP BY clause to get the correct result. Additionally, the LIMIT clause is not necessary when using the MIN function.",
        "ground_truth_sql": "SELECT T1.IndicatorName, MIN(T1.Value) FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T2.AggregationMethod = 'Weighted average'",
        "difficulty": ""
    },
    {
        "question": "What is the reason for sales order \"51883\"?",
        "hint": "reason means the category of sales reason which refers to ReasonType",
        "error_sql": "SELECT T3.ReasonType FROM SalesOrderHeader AS T1 INNER JOIN SalesOrderHeaderSalesReason AS T2 ON T1.SalesOrderID = T2.SalesOrderID INNER JOIN SalesReason AS T3 ON T2.SalesReasonID = T3.SalesReasonID WHERE T1.SalesOrderNumber = 'SO51883'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being selected. In this case, the error was in the join condition of the first query, where it was joining on SalesOrderNumber instead of SalesOrderID. Additionally, the correct column to select is the Name column from the SalesReason table, not the ReasonType column. To avoid this mistake, double-check the table schema and the join conditions to ensure they are correct.",
        "ground_truth_sql": "SELECT T2.Name FROM SalesOrderHeaderSalesReason AS T1 INNER JOIN SalesReason AS T2 ON T1.SalesReasonID = T2.SalesReasonID WHERE T1.SalesOrderID = 51883",
        "difficulty": ""
    },
    {
        "question": "Find the average ride duration during the rain of more than 0.8 inches.",
        "hint": "rain of more than 0.8 inches refers to events = rain where precipitation_inches>0.8; average ride duration = DIVIDE(SUM(duration), COUNT(duration));",
        "error_sql": "SELECT CAST(SUM(T1.duration) AS REAL) / COUNT(T1.duration) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.events = 'Rain' AND CAST(REPLACE(T2.precipitation_inches, '\"', '') AS REAL) > 0.8",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the data types of the columns being joined are compatible. In this case, the `zip_code` column in the `trip` table is an integer, while in the `weather` table it's a text. To avoid this mistake, always check the data types of the columns being joined and perform any necessary conversions. Additionally, when comparing string values, consider using case-insensitive comparisons or converting both values to the same case to avoid missing matches due to case differences.",
        "ground_truth_sql": "SELECT AVG(T1.duration) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE (T2.events = 'Rain' AND T2.precipitation_inches > 0.8) OR (T2.events = 'rain' AND T2.precipitation_inches > 0.8)",
        "difficulty": ""
    },
    {
        "question": "Between 1/1/2010 to 12/31/2020, how many users, who were a trialist when they created the list, gave the movie \"The Secret Life of Words\" a rating score of 3?",
        "hint": "Between 1/1/2010 to 12/31/2020 refers to rating_timestamp_utc between '2010-01-01%' and '2020-12-31%'; a trialist refers to user_trialist = 1; movie \"The Secret Life of Words\" refers to movie_title = 'The Secret Life of Words'; rating score of 3 refers to rating_score = 3",
        "error_sql": "SELECT COUNT(T4.user_id) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists_users AS T3 ON T2.user_id = T3.user_id INNER JOIN ratings_users AS T4 ON T3.user_id = T4.user_id WHERE T1.movie_title = 'The Secret Life of Words' AND T2.rating_score = 3 AND T3.user_trialist = 1 AND T2.rating_timestamp_utc BETWEEN '2010-01-01%' AND '2020-12-31%'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, carefully consider the relationships between the tables and the columns used in the join conditions. In this case, the error was caused by joining `lists_users` and `ratings_users` tables, which was unnecessary and incorrect. The correct approach is to join `ratings` with `movies` and use the `user_trialist` column from the `ratings` table directly. Additionally, be mindful of the column names and their corresponding tables to avoid incorrect joins and conditions.",
        "ground_truth_sql": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'The Secret Life of Words' AND T1.rating_score = 3 AND T1.user_trialist = 0 AND T1.rating_timestamp_utc BETWEEN '2010%' AND '2020%'",
        "difficulty": ""
    },
    {
        "question": "Provide the full address of Ursola Purdy.",
        "hint": "full address refers to street_number, street_name, city, country_name",
        "error_sql": "SELECT T3.street_number, T3.street_name, T3.city, T4.country_name FROM customer AS T1 INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T2.address_id = T3.address_id INNER JOIN country AS T4 ON T3.country_id = T4.country_id WHERE T1.first_name = 'Ursola' AND T1.last_name = 'Purdy'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and consistent. In this case, the error was in the join condition between the `address` table and the `country` table. The correct join condition should be `T4.country_id = T3.country_id` instead of `T3.country_id = T4.country_id`. Additionally, the `country_name` column should be selected from the `country` table, not the `address` table. To avoid making the same mistake in the future, double-check the join conditions and the columns being selected to ensure they are correct and consistent with the database schema.",
        "ground_truth_sql": "SELECT T3.street_number, T3.street_name, T3.city FROM customer AS T1 INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id INNER JOIN country AS T4 ON T4.country_id = T3.country_id WHERE T1.first_name = 'Ursola' AND T1.last_name = 'Purdy'",
        "difficulty": ""
    },
    {
        "question": "Which were the trips that started at Mountain View City Hall and ended on a rainy day?",
        "hint": "started at refers to start_station_name; start_station_name = 'Mountain View City Hall'; ended on a rainy day refers to end_date where events = 'rain';",
        "error_sql": "SELECT T1.id FROM trip AS T1 INNER JOIN weather AS T2 ON T2.date = T1.end_date WHERE T1.start_station_name = 'Mountain View City Hall' AND T2.events = 'Rain'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition is correct and complete. In this case, the initial error was due to missing the zip_code condition in the join, which was later corrected. However, the corrected query still had an unnecessary condition in the join clause (T2.date = T1.end_date). The correct join condition should only include the zip_code, as the date condition is already covered in the WHERE clause. Additionally, the join type (INNER JOIN) should be used with caution, as it may exclude trips that do not have a matching weather record. Consider using LEFT JOIN or FULL OUTER JOIN if necessary.",
        "ground_truth_sql": "SELECT T1.id FROM trip AS T1 INNER JOIN weather AS T2 WHERE T2.events = 'Rain' AND T1.start_station_name = 'Mountain View City Hall'",
        "difficulty": ""
    },
    {
        "question": "Provide the github address with the summary of method \"A test for Decompose\n\".",
        "hint": "github address refers to Url; summary of method refers to Summary; Summary = 'A test for Decompose';",
        "error_sql": "SELECT T1.Url, T3.Summary FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE T3.Summary = 'A test for Decompose'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the selected columns are correctly matched with the corresponding tables. In this case, the Error SQL Query incorrectly included T3.Summary in the SELECT statement, which was not requested in the problem statement. The SQL after Reflection was correct, but it's essential to double-check the problem statement to ensure that all requested columns are included. To avoid this mistake, carefully read the problem statement and verify that the selected columns match the requested information.",
        "ground_truth_sql": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE T3.Summary = 'A test for Decompose'",
        "difficulty": ""
    },
    {
        "question": "How many likes did short comment left by users who joined in 2010 get?",
        "hint": "short comment refers to tip_length = 'Short'; users who joined in 2010 refer to user_id where user_yelping_since_year = 2010;",
        "error_sql": "SELECT SUM(T2.likes) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2010 AND T2.tip_length = 'Short'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and applying filters, ensure that all conditions are correctly specified. In this case, the error was not in the SQL query itself, but rather in the interpretation of the question. The question asks for the total likes of short comments left by users who joined in 2010, but the provided SQL query only filters for users who joined in 2010, without considering the tip_length condition. However, the Ground Truth SQL provided also does not filter for tip_length = 'Short'. To correctly answer the question, the filter for tip_length = 'Short' should be included in the WHERE clause. The correct SQL query should be:\n\nSELECT SUM(T2.likes) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2010 AND T2.tip_length = 'Short'\n\nThe tip is to carefully read and understand the question, and ensure that all conditions are correctly specified in the SQL query.",
        "ground_truth_sql": "SELECT SUM(T2.likes) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2010",
        "difficulty": ""
    },
    {
        "question": "In which streets of the city of San Francisco are there restaurants that serve seafood?",
        "hint": "street refers to street_name; seafood refers to food_type = 'seafood'",
        "error_sql": "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T1.city = T3.city WHERE T2.food_type = 'seafood' AND T3.city = 'San Francisco'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and consider the case sensitivity of the data. In this case, the city name 'San Francisco' should be in lowercase 'san francisco' to match the data in the table. Also, the join with the geographic table is unnecessary as the city information is already available in the generalinfo table. Additionally, the condition to check for 'seafood' should be case-insensitive to handle different cases in the data.",
        "ground_truth_sql": "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.city = 'san francisco' AND T2.food_type = 'seafood' AND street_name IS NOT NULL",
        "difficulty": ""
    },
    {
        "question": "Describe the product names delivered in 2021 for the customer \"Sundial\".",
        "hint": "delivered in 2021 refer to DeliveryDate LIKE '%/21'; 'Sundial' is the Customer Names",
        "error_sql": "SELECT DISTINCT T3.`Product Name` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T1.`Customer Names` = 'Sundial' AND T2.DeliveryDate LIKE '%/21'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using the LIKE operator with a date format, consider the actual format of the date in the database. In this case, the date format is 'MM/DD/YY', so the correct pattern should be '%/%/21' instead of '%/21'. Additionally, when filtering data based on multiple conditions, consider using a subquery or a CASE statement to ensure that the conditions are applied correctly and to avoid returning NULL values.",
        "ground_truth_sql": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.DeliveryDate LIKE '%/%/21' AND T1.`Customer Names` = 'Sundial ' THEN T3.`Product Name` END AS T FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products T3 ON T3.ProductID = T2._ProductID ) WHERE T IS NOT NULL",
        "difficulty": ""
    },
    {
        "question": "How many players did not get more than 10 steals between the years 2000 and 2005?",
        "hint": "did not get more than 10 steals refers to count(steals) < = 10; between the years 2000 and 2005 refers to season_id between 2000 and 2005",
        "error_sql": "SELECT COUNT(T1.playerID) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T2.season_id BETWEEN 2000 AND 2005 AND T2.steals <= 10",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, consider whether the join is necessary and whether it might cause duplicate counts. In this case, joining the `players` table is unnecessary because the `player_allstar` table already contains the `playerID` column. Additionally, joining the tables could potentially cause duplicate counts if a player has multiple entries in the `players` table. To avoid this mistake, carefully consider the schema of the tables involved and whether a join is truly necessary to answer the question.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT playerID) FROM player_allstar WHERE season_id BETWEEN 2000 AND 2005 AND steals <= 10",
        "difficulty": ""
    },
    {
        "question": "Among the products that have a retail price greater than 1,000, how many products were shipped via ship?",
        "hint": "products refer to l_partkey; retail price greater than 1,000 refers to p_retailprice > 1000; shipped via ship refers to l_shipmode = 'SHIP';",
        "error_sql": "SELECT COUNT(T1.l_partkey) FROM lineitem AS T1 INNER JOIN part AS T2 ON T1.l_partkey = T2.p_partkey WHERE T2.p_retailprice > 1000 AND T1.l_shipmode = 'SHIP'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and that the correct tables are being joined. In this case, the error was due to the fact that the `partsupp` table was not being joined, which is necessary to link the `part` table to the `lineitem` table. Additionally, the join condition should be based on the correct columns, in this case, `ps_suppkey` and `l_suppkey`, as well as `ps_partkey` and `p_partkey`. Always carefully review the schema and the join conditions to ensure that the query is correct.",
        "ground_truth_sql": "SELECT COUNT(T1.ps_suppkey) FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_retailprice > 1000 AND T2.l_shipmode = 'SHIP'",
        "difficulty": ""
    },
    {
        "question": "How many category id have low review count and rating more than 2?",
        "hint": "rating more than 2 refers to stars > 2;",
        "error_sql": "SELECT COUNT(T1.category_id) FROM Business_Categories AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T2.review_count = 'Low' AND T2.stars > 2",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join is performed on the correct columns and that the correct tables are being joined. In this case, the error was due to joining Business_Categories with Business on the wrong column (category_id instead of business_id) and not including the Categories table in the join. To avoid this mistake, carefully review the schema and ensure that the joins are correct and that all necessary tables are included. Additionally, use the DISTINCT keyword when counting to avoid counting duplicate values.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.category_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T3.review_count = 'Low' AND T3.stars > 2",
        "difficulty": ""
    },
    {
        "question": "When was the birthday for the goalie who had most goal againsts in 1965 season?",
        "hint": "Birthday refers to CONCAT(birthYear / birthMon / birthDate);most goal against refers to MAX(GA);1965 season refers to year = '1965'\n\n",
        "error_sql": "SELECT CONCAT(T1.birthYear, '/', T1.birthMon, '/', T1.birthDay) FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year = '1965' ORDER BY T2.GA DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column, it's better to use a subquery to first find the maximum or minimum value, and then use that value to filter the results. This is because using ORDER BY and LIMIT can return incorrect results if there are multiple rows with the same maximum or minimum value. In this case, the Error SQL Query was trying to find the goalie with the most goals against in the 1965 season, but it was using ORDER BY and LIMIT, which could return an incorrect result if there were multiple goalies with the same number of goals against. The SQL after Reflection was closer to the correct solution, but it was still not correct because it was using a subquery to find the maximum number of goals against, but it was not considering the case where there are multiple goalies with the same number of goals against. The Ground Truth SQL is the correct solution because it is using ORDER BY and LIMIT to find the goalie with the most goals against, and it is not using a subquery to find the maximum number of goals against.",
        "ground_truth_sql": "SELECT T1.birthYear, T1.birthMon, birthDay FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1965 ORDER BY T2.GA DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the percentage of pages that have 1500 different words.",
        "hint": "DIVIDE(COUNT(pages WHERE words = 1500), COUNT(pages)) as percentage;",
        "error_sql": "SELECT CAST(SUM(IIF(T1.words = 1500, 1, 0)) AS REAL) * 100 / COUNT(T1.pid) FROM pages AS T1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that the numerator and denominator are correctly defined. In this case, the numerator should count the number of pages with 1500 words, and the denominator should count the total number of pages. Also, be careful with the column names used in the query, as they should match the actual column names in the table. In the Error SQL Query and SQL after Reflection, the column name 'pid' was used in the denominator, which is incorrect. The correct column name to use is 'page'. Additionally, the LIMIT clause should be used with caution, as it can affect the accuracy of the result. In this case, the LIMIT clause was used incorrectly, which would have returned an incorrect result.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN words = 1500 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(page) FROM pages WHERE words > 300 LIMIT 3",
        "difficulty": ""
    },
    {
        "question": "For the state which has the 113 2-year public schools, tell the number of graduated Asian students who seeks another type of degree or certificate at a 2-year institution in 2013.",
        "hint": "schools_count = 113; 2-year refers to level = '2-year'; public refers to control = 'public'; Asian refers to race = 'A'; seeks another type of degree or certificate at a 2-year institution refers to cohort = '2y all'; in 2013 refers to year = 2013;",
        "error_sql": "SELECT COUNT(T1.grad_cohort) FROM state_sector_grads AS T1 INNER JOIN state_sector_details AS T2 ON T1.state = T2.state WHERE T2.level = '2-year' AND T2.control = 'Public' AND T2.schools_count = 113 AND T1.race = 'A' AND T1.cohort = '2y all' AND T1.year = 2013",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being referenced. In this case, the initial error was due to joining on the 'state' column instead of the 'stateid' column, which is the correct foreign key. Additionally, the initial query was counting from the wrong table (T1 instead of T2). The second query still had errors due to referencing the wrong table for the 'level' and 'control' columns. To avoid such mistakes, double-check the table schema and the join conditions to ensure that they are correct.",
        "ground_truth_sql": "SELECT COUNT(T2.grad_cohort) FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T2.level = '2-year' AND T2.control = 'Public' AND T2.gender = 'B' AND T2.race = 'A' AND T2.cohort = '2y all' AND T1.schools_count = 113",
        "difficulty": ""
    },
    {
        "question": "Please list the emails of the clients whose complaint date received is 7/3/2014.",
        "hint": "7/3/2014 refers to Date received = '2014-07-03'",
        "error_sql": "SELECT T2.email FROM callcenterlogs AS T1 INNER JOIN client AS T2 ON T1.`rand client` = T2.client_id WHERE T1.`Date received` = '2014-07-03'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the columns being referenced are from the correct tables. In this case, the error was in the join condition and the column being referenced. The correct join should be between the 'client' table and the 'events' table, not the 'callcenterlogs' table, and the column 'Date received' should be referenced from the 'events' table, not the 'callcenterlogs' table. Additionally, the alias 'T2' was incorrectly assigned to the 'events' table, when it should have been assigned to the 'client' table. To avoid this mistake, carefully review the schema and the relationships between tables before writing the SQL query.",
        "ground_truth_sql": "SELECT T1.email FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Date received` = '2014-07-03'",
        "difficulty": ""
    },
    {
        "question": "How many donations from teachers were done in the state of Colorado?",
        "hint": "from teachers refers to is_teacher_acct = 't'; the state of Colorado refers to donor_state = 'CO-Colorado'",
        "error_sql": "SELECT COUNT(donationid) FROM donations WHERE is_teacher_acct = 't' AND donor_state = 'CO-Colorado'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen filtering data based on a specific state, ensure that the state abbreviation is used correctly. In this case, the correct abbreviation for Colorado is 'CO', not 'CO-Colorado'. The latter is likely a full name or description of the state, which may not match the actual data in the 'donor_state' column. Always verify the data format and content to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(donationid) FROM donations WHERE is_teacher_acct = 't' AND donor_state = 'CO'",
        "difficulty": ""
    },
    {
        "question": "Who are the top 8 suppliers supplying the products with the highest user satisfaction?",
        "hint": "highest user satisfaction refers to max(ReorderLevel);",
        "error_sql": "SELECT T1.CompanyName FROM Suppliers AS T1 INNER JOIN Products AS T2 ON T1.SupplierID = T2.SupplierID ORDER BY T2.ReorderLevel DESC LIMIT 8",
        "compiler_hint": "no such column: T2.ReorderLevel",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names and table aliases are correctly referenced. In this case, the error occurred because the column 'ReorderLevel' does not exist in the 'Products' table, and the table aliases were swapped in the 'SELECT' and 'JOIN' clauses. To avoid this mistake, double-check the table schema and ensure that the column names and table aliases are correctly referenced in the SQL query. Additionally, verify that the column 'ReorderLevel' actually exists in the 'Products' table, as it is not present in the provided schema.",
        "ground_truth_sql": "SELECT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID ORDER BY T1.ReorderLevel DESC LIMIT 8",
        "difficulty": ""
    },
    {
        "question": "How many users, between the age 27 to 35, were surveyed in 2018?",
        "hint": "Age 27 to 35 refer to AnswerText 27 BETWEEN 35 where questionid = 1; 2018 refer to SurveyID\n\n",
        "error_sql": "SELECT COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID INNER JOIN Question AS T3 ON T1.QuestionID = T3.QuestionID WHERE T3.questionid = 1 AND T1.AnswerText BETWEEN 27 AND 35 AND T2.Description = '2018'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and the columns being joined are of the same data type. In the Error SQL Query, the join condition for the Question table was incorrect (T1.QuestionID = T3.QuestionID should be T1.QuestionID = T3.questionid). Additionally, when using the BETWEEN operator, ensure that the data types of the values being compared are consistent. In this case, the AnswerText column is of type TEXT, so the values '27' and '35' should be enclosed in single quotes. Furthermore, the SurveyID in the Ground Truth SQL is an integer, so the correct query should filter by SurveyID = 2018, not by Description = '2018'.",
        "ground_truth_sql": "SELECT T1.UserID FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T1.SurveyID = 2018 AND T2.questionid = 1 AND T1.AnswerText BETWEEN '27' AND '35'",
        "difficulty": ""
    },
    {
        "question": "List the territory IDs, description and region description under the in-charge of Mrs. Margaret Peacock.",
        "hint": "",
        "error_sql": "SELECT T2.TerritoryID, T2.TerritoryDescription, T3.RegionDescription \nFROM Employees AS T1 \nINNER JOIN EmployeeTerritories AS T2 \nON T1.EmployeeID = T2.EmployeeID \nINNER JOIN Region AS T3 \nON T2.RegionID = T3.RegionID \nWHERE T1.FirstName = 'Margaret' AND T1.LastName = 'Peacock'",
        "compiler_hint": "no such table: EmployeeTerritories",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names and column names match the actual schema of the database. In this case, the error occurred because the tables 'EmployeeTerritories' and 'Region' were not present in the original schema provided. However, upon closer inspection, it appears that the correct schema does contain these tables, but they were not included in the original schema provided. To avoid this mistake, always verify the schema of the database before generating SQL queries. Additionally, be aware of the actual relationships between tables and the correct column names to join them.",
        "ground_truth_sql": "SELECT T3.TerritoryID, T3.TerritoryDescription, T4.RegionDescription FROM Employees AS T1 INNER JOIN EmployeeTerritories AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Territories AS T3 ON T2.TerritoryID = T3.TerritoryID INNER JOIN Region AS T4 ON T3.RegionID = T4.RegionID WHERE T1.TitleOfCourtesy = 'Mrs.' AND T1.LastName = 'Peacock' AND T1.FirstName = 'Margaret'",
        "difficulty": ""
    },
    {
        "question": "Count the total venues located in Pune City.",
        "hint": "Pune City refers to City_Name = 'Pune'",
        "error_sql": "SELECT COUNT(Venue_Id) FROM Venue WHERE City_Id IN ( SELECT City_Id FROM City WHERE City_Name = 'Pune' )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen counting the number of rows that match a certain condition, use the COUNT() function with a column that is guaranteed to be non-null, such as the primary key or a column that is defined as NOT NULL. In this case, the error SQL query and SQL after reflection are correct, but the ground truth SQL is incorrect because it is trying to sum the Venue_Name column, which is a string, instead of counting the number of rows. The correct SQL query should be:\n\n```sql\nSELECT COUNT(Venue_Id) FROM Venue WHERE City_Id IN ( SELECT City_Id FROM City WHERE City_Name = 'Pune' )\n```\n\nOr, using a JOIN:\n\n```sql\nSELECT COUNT(V1.Venue_Id) FROM Venue AS V1 INNER JOIN City AS C1 ON V1.City_Id = C1.City_Id WHERE C1.City_Name = 'Pune'\n```",
        "ground_truth_sql": "SELECT SUM(T1.Venue_Name) FROM Venue AS T1 INNER JOIN City AS T2 ON T1.City_Id = T2.City_Id WHERE T2.City_Name = 'Pune'",
        "difficulty": ""
    },
    {
        "question": "In 2010, which episode did Joel H. Cohen win an award for?",
        "hint": "In 2010 refers to year = 2010",
        "error_sql": "SELECT T1.episode_id FROM Award AS T1 INNER JOIN Person AS T2 ON T1.person = T2.name WHERE T1.year = 2010 AND T2.name = 'Joel H. Cohen'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\n\nWhen joining tables, ensure that the join is performed on the correct columns and that the correct table is being joined. In this case, the initial error was joining the Award table with the Person table, but the question asked for the episode title, which is stored in the Episode table. Therefore, the correct join should be between the Award table and the Episode table. Additionally, the year column in the Award table is a string, so the correct way to compare it with the year 2010 is by using the SUBSTR function to extract the first 4 characters.",
        "ground_truth_sql": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2010' AND T1.person = 'Joel H. Cohen';",
        "difficulty": ""
    },
    {
        "question": "Which team did the MVP of 1997 NBA season play in?",
        "hint": "team refers to tmID; MVP refers to award like '%MVP'; 1997 refers to year = 1997; NBA refers to lgID = 'NBA'",
        "error_sql": "SELECT T2.tmID FROM awards_players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T1.award LIKE '%MVP' AND T1.year = 1997 AND T1.lgID = 'NBA'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, make sure to include all relevant tables and join conditions to avoid missing information. In this case, the `teams` table was missing, and the `award` condition was not specific enough, leading to incorrect results. Additionally, when searching for a specific award, use the exact award name instead of a wildcard to ensure accuracy.",
        "ground_truth_sql": "SELECT DISTINCT T3.tmID FROM players_teams AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T1.tmID = T3.tmID AND T1.year = T3.year WHERE T2.year = 1997 AND T2.award = 'Finals MVP' LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many awards did simpson 20 won in 2009?",
        "hint": "won refers to result = 'Winner'; in 2009 refers to year = 2009",
        "error_sql": "SELECT COUNT(T1.award_id) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.result = 'Winner' AND SUBSTR(T1.year, 1, 4) = '2009' AND T2.title = 'Simpsons 20'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, carefully consider whether the join is necessary to answer the question. In this case, the join with the Episode table is unnecessary because the Award table already contains the year and result information needed to answer the question. The join with the Episode table was likely added to filter by episode title, but this filter is not actually needed to answer the question about the number of awards won in 2009.",
        "ground_truth_sql": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009' AND result = 'Winner';",
        "difficulty": ""
    },
    {
        "question": "How many shipments were shipped by the driver named Zachary Hicks?",
        "hint": "",
        "error_sql": "SELECT COUNT(T2.ship_id) FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id WHERE T1.first_name = 'Zachary' AND T1.last_name = 'Hicks'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names in the SELECT and WHERE clauses match the table aliases used in the JOIN clause. In this case, the Error SQL Query and SQL after Reflection were incorrect because they used the wrong table alias in the COUNT() function and WHERE clause, respectively. To avoid this mistake, double-check that the table aliases are consistent throughout the query. Additionally, when using a specific driver_id in the WHERE clause, as in the Ground Truth SQL, it is more efficient and accurate than using the driver's name, as names can be duplicated, but IDs are unique.",
        "ground_truth_sql": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.driver_id = 23",
        "difficulty": ""
    },
    {
        "question": "Which country was the source of Pjandsh River? Give the full name of the country.",
        "hint": "",
        "error_sql": "SELECT T1.Name FROM country AS T1 INNER JOIN geo_source AS T2 ON T1.Code = T2.Country INNER JOIN river AS T3 ON T3.Name = T2.River WHERE T3.Name = 'Pjandsh River'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and relevant to the query. In this case, the error SQL query joined the 'geo_source' table which is not necessary for the query. The correct join is between the 'country' table and the 'located' table, as the 'located' table contains the information about the river and its corresponding country. Always analyze the schema and the relationships between tables before writing a query.",
        "ground_truth_sql": "SELECT T1.Name FROM country AS T1 INNER JOIN located AS T2 ON T1.Code = T2.Country WHERE T2.River = 'Pjandsh'",
        "difficulty": ""
    },
    {
        "question": "Please list all the territories in the Eastern Region.",
        "hint": "territories refers to TerritoryDescription; Eastern Region refers to RegionDescription = 'Eastern';",
        "error_sql": "SELECT T3.TerritoryDescription FROM Employees AS T1 INNER JOIN EmployeeTerritories AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Territories AS T3 ON T2.TerritoryID = T3.TerritoryID INNER JOIN Region AS T4 ON T3.RegionID = T4.RegionID WHERE T4.RegionDescription = 'Eastern'",
        "compiler_hint": "no such table: Region",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table with the filtering condition (in this case, RegionDescription = 'Eastern') is the one being referenced in the WHERE clause, and that the SELECT statement is retrieving columns from the correct table. Additionally, use DISTINCT to remove duplicate values when necessary, especially when joining tables with one-to-many relationships.",
        "ground_truth_sql": "SELECT DISTINCT T1.TerritoryDescription FROM Territories AS T1 INNER JOIN Region AS T2 ON T1.RegionID = T2.RegionID WHERE T2.RegionDescription = 'Eastern'",
        "difficulty": ""
    },
    {
        "question": "Provide the directions for all the trains that have 2 or less cars.",
        "hint": "2 or less cars refers to trailPosi < = 2",
        "error_sql": "SELECT T2.direction FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1",
        "compiler_hint": "unrecognized token: \"#\"",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition is correct and that the column names are correctly referenced. In this case, the error was due to the incorrect join condition and column references. To avoid this mistake, double-check the table schema and the join conditions to ensure that they are correct. Additionally, use table aliases consistently to avoid confusion.",
        "ground_truth_sql": "SELECT T1.direction FROM trains AS T1 INNER JOIN ( SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id ) AS T2 ON T1.id = T2.train_id WHERE T2.trailPosi <= 2",
        "difficulty": ""
    },
    {
        "question": "State the number of public magnet schools in New York Manhattan.",
        "hint": "public magnet school refers to school_magnet = 't'; in New York Manhattan refers to school_country = 'New York(Manhattan)';",
        "error_sql": "SELECT COUNT(school_magnet) FROM projects WHERE school_magnet = 't' AND school_city = 'New York(Manhattan)'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen filtering data based on location, ensure that the correct column is used. In this case, the error was using 'school_city' instead of 'school_county' to filter for 'New York(Manhattan)'. Always verify the column names and data types to avoid such mistakes. Additionally, when counting the number of rows, it's generally better to use COUNT(*) or COUNT(primary_key) instead of COUNT(column_name) to avoid potential issues with NULL values.",
        "ground_truth_sql": "SELECT COUNT(schoolid) FROM projects WHERE school_county = 'New York (Manhattan)' AND school_magnet = 't'",
        "difficulty": ""
    },
    {
        "question": "Among the employees who have more than 10 hours of sick leave, how many of them wish to receive e-mail promotions?",
        "hint": "Contact does wish to receive e-mail promotions refers to EmailPromotion = (1,2); more than 10 hours of sick leave refer to SickLeaveHours >10;",
        "error_sql": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.EmailPromotion IN (1, 2) AND T1.SickLeaveHours > 10",
        "compiler_hint": "no such column: EmailPromotion",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the WHERE clause are correctly referenced from the joined tables. In this case, the EmailPromotion column is in the Person table, not the Employee table, so it should be referenced as T2.EmailPromotion. Additionally, the condition for EmailPromotion should be T2.EmailPromotion = 1, not T2.EmailPromotion IN (1, 2), since the problem statement only asks for employees who wish to receive e-mail promotions, which is represented by EmailPromotion = 1.",
        "ground_truth_sql": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.EmailPromotion = 1 AND T1.SickLeaveHours > 10",
        "difficulty": ""
    },
    {
        "question": "Among the countries whose government type is republic, how many of them shares a border that's longer than 200?",
        "hint": "",
        "error_sql": "SELECT COUNT(T1.Country1) FROM borders AS T1 INNER JOIN politics AS T2 ON T1.Country1 = T2.Country WHERE T2.Government = 'republic' AND T1.Length > 200",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being referenced. In this case, the initial error was due to joining the 'politics' table with the 'borders' table on the 'Country' column, which is not present in the 'borders' table. The correct join condition is to join the 'country' table with the 'politics' table on the 'Code' column, and then join the 'borders' table with the 'country' table on the 'Code' column. Additionally, when counting the number of countries, use the 'Name' column from the 'country' table instead of the 'Country1' column from the 'borders' table to avoid counting duplicate borders.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN borders AS T3 ON T3.Country1 = T2.Country WHERE T2.Government = 'republic' AND T3.Length > 200",
        "difficulty": ""
    },
    {
        "question": "List out the name of the top 10 spenders and what credit card type are they using.",
        "hint": "top 10 spenders refers to MAX(PurchasePrice) LIMIT 10;",
        "error_sql": "SELECT T1.First, T1.Last, T2.CreditCardType FROM customers AS T1 INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY T2.PurchasePrice DESC LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the top spenders, it's essential to consider the total amount spent by each customer, not just the maximum purchase price. The initial query was incorrect because it only considered the maximum purchase price, which might not accurately represent the total spending. The second query was closer, but it still had a flaw. The correct approach is to group the transactions by customer, calculate the total purchase price for each customer, and then order the results by this total amount in descending order. Additionally, the credit card type might not be unique for each customer, so it's crucial to consider this when interpreting the results. To avoid similar mistakes in the future, always carefully analyze the problem and consider all relevant factors, including aggregation and grouping, when writing SQL queries.",
        "ground_truth_sql": "SELECT T1.First, T1.Last, T2.CreditCardType FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.CustomerID ORDER BY SUM(T2.PurchasePrice) DESC LIMIT 10",
        "difficulty": ""
    },
    {
        "question": "What is the name of the company that has the product with the highest unit price?",
        "hint": "name of the company refers to CompanyName; the highest unit price refers to MAX(UnitPrice)",
        "error_sql": "SELECT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.Price = ( SELECT MAX(Price) FROM Products )",
        "compiler_hint": "no such column: T2.CompanyName",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the column names in the WHERE clause and SELECT statement match the actual column names in the tables. In this case, the error occurred because the column name in the Suppliers table is actually 'SupplierName', not 'CompanyName', and the column name in the Products table is actually 'Price', not 'UnitPrice'. To avoid this mistake, double-check the column names in the table schema before writing the SQL query.",
        "ground_truth_sql": "SELECT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.UnitPrice = ( SELECT MAX(UnitPrice) FROM Products )",
        "difficulty": ""
    },
    {
        "question": "Among the male legislators born between 1955 to 1965, what is the percentage of the legislators with an independent party?",
        "hint": "male refers to gender_bio = 'M'; born between 1955 to 1965 refers to strftime('%Y', birthday_bio) between '1955' and '1965'; percentage = MULTIPLY(DIVIDE(SUM(party = 'Independent' WHERE gender_bio = 'M' AND strftime('%Y', birthday_bio) between '1955' and '1965'), COUNT(party WHERE gender_bio = 'M' AND strftime('%Y', birthday_bio) between '1955' and '1965')), 100.0);",
        "error_sql": "SELECT CAST(SUM(IIF(T1.party = 'Independent' AND T2.gender_bio = 'M' AND strftime('%Y', T2.birthday_bio) BETWEEN '1955' AND '1965', 1, 0)) AS REAL) / COUNT(T1.party) * 100.0 FROM \"current-terms\" AS T1 INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id",
        "compiler_hint": "no such column: party",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the WHERE and SELECT clauses are correctly referenced from the joined tables. In this case, the 'party' column is in the 'current-terms' table, not the 'current' table. Therefore, the correct reference should be T2.party instead of just party. Additionally, when using aggregate functions like SUM and COUNT, ensure that the correct columns are being referenced and that the conditions in the CASE statement are correctly filtering the data.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.party = 'Independent' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.party) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND strftime('%Y', T1.birthday_bio) BETWEEN '1955' AND '1965'",
        "difficulty": ""
    },
    {
        "question": "Please list the team names which have at least 3 all-star players.",
        "hint": "team with at least 3 all star player refers to tmID where Count(player_allstar.playerID) > = 3",
        "error_sql": "SELECT T3.name FROM player_allstar AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T2.tmID = T3.tmID AND T2.year = T3.year GROUP BY T3.name HAVING COUNT(T1.playerID) >= 3",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables and grouping by a column, ensure that the column used in the COUNT function is distinct to avoid counting duplicate values. Additionally, verify that the columns used in the JOIN and GROUP BY clauses are correct and relevant to the query's requirements. In this case, the error was in the COUNT function and the columns used in the JOIN and GROUP BY clauses. The correct query should count distinct playerIDs and group by the teamID, not the team name.",
        "ground_truth_sql": "SELECT T1.tmID FROM players_teams AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID GROUP BY T1.tmID HAVING COUNT(DISTINCT T1.playerID) >= 3",
        "difficulty": ""
    },
    {
        "question": "What is the user avatar url for user 41579158? What is the latest movie rated by him / her?",
        "hint": "user avatar url refers to user_avatar_image_url; latest movie rated refers to latest rating_date;",
        "error_sql": "SELECT T1.user_avatar_image_url, T3.movie_title FROM ratings_users AS T1 INNER JOIN ratings AS T2 ON T1.user_id = T2.user_id INNER JOIN movies AS T3 ON T2.movie_id = T3.movie_id WHERE T1.user_id = 41579158 ORDER BY T2.rating_timestamp_utc DESC LIMIT 1",
        "compiler_hint": "no such column: T2.movie_title",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the column names referenced in the SELECT and ORDER BY clauses match the actual column names in the joined tables. In this case, the error occurred because the column 'movie_title' was referenced from the wrong table alias 'T2' instead of 'T3'. To avoid this mistake, double-check the column names and their corresponding table aliases in the query. Additionally, verify that the joined tables are correctly referenced in the SELECT and ORDER BY clauses.",
        "ground_truth_sql": "SELECT T3.user_avatar_image_url, T3.rating_date_utc FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T3.user_id = T2.user_id WHERE T3.user_id = 41579158 ORDER BY T3.rating_date_utc DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the profit of the product with the highest list price and of the product with the lowest list price other than 0? Indicates the depth the component is from its parent.",
        "hint": "profit = subtract(ListPrice, StandardCost); the depth the component from its parent refers to BOMLevel;",
        "error_sql": "SELECT (T1.ListPrice - T1.StandardCost) AS Profit, T2.BOMLevel FROM Product AS T1 INNER JOIN BillOfMaterials AS T2 ON T1.ProductID = T2.ComponentID WHERE T1.ListPrice = ( SELECT MAX(ListPrice) FROM Product ) OR T1.ListPrice = ( SELECT MIN(ListPrice) FROM Product WHERE ListPrice != 0 )",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and that the correct columns are being joined. In this case, the error was in the join condition, where the ProductID was being joined with the ComponentID instead of the ProductAssemblyID. Additionally, when using OR conditions, ensure that the conditions are correctly ordered and that the correct columns are being compared. In this case, the error was in the OR condition, where the ListPrice was being compared with the MAX and MIN ListPrice, but the BOMLevel was not being correctly retrieved. To avoid making the same mistake in the future, double-check the join conditions and OR conditions to ensure that they are correct and that the correct columns are being compared.",
        "ground_truth_sql": "SELECT ( SELECT ListPrice - StandardCost FROM Product WHERE ListPrice != 0 ORDER BY ListPrice DESC LIMIT 1 ) , ( SELECT ListPrice - StandardCost FROM Product WHERE ListPrice != 0 ORDER BY ListPrice LIMIT 1 )",
        "difficulty": ""
    },
    {
        "question": "Among the root beer brands that do not advertise on Facebook and Twitter, which brand has the highest number of purchases?",
        "hint": "do not advertise on Facebook and Twitter refers to FacebookPage IS NULL AND Twitter IS NULL; highest number of purchases refers to MAX(COUNT(BrandID));",
        "error_sql": "SELECT T1.BrandName FROM rootbeerbrand AS T1 INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID WHERE T1.FacebookPage IS NULL AND T1.Twitter IS NULL GROUP BY T1.BrandID, T1.BrandName ORDER BY COUNT(T2.BrandID) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table aliases used in the SELECT, WHERE, GROUP BY, and ORDER BY clauses match the actual column names and table aliases used in the JOIN clause. In this case, the error occurred because the column name in the ORDER BY clause was incorrect. To avoid this mistake, double-check the column names and table aliases used in the query to ensure consistency. Additionally, when using aggregate functions like COUNT, make sure to count the correct column, which in this case should be the column from the table being joined (T1.BrandID), not the column from the table being queried (T1.RootBeerID or T2.BrandID).",
        "ground_truth_sql": "SELECT T2.BreweryName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T2.FacebookPage IS NULL AND T2.Twitter IS NULL GROUP BY T2.BrandID ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the credit card number for Michelle E Cox?",
        "hint": "credit card number refers to CreditCardID",
        "error_sql": "SELECT T2.CardNumber FROM Person AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE T1.FirstName = 'Michelle' AND T1.LastName = 'E Cox'",
        "compiler_hint": "no such column: T2.CardNumber",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names in the SELECT statement match the actual column names in the joined tables. In this case, the error occurred because the column name 'CardNumber' was referenced from the wrong table alias 'T2' instead of 'T3'. To avoid this mistake, double-check the column names and their corresponding table aliases in the SELECT statement.",
        "ground_truth_sql": "SELECT T3.CreditCardID FROM Person AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE T1.FirstName = 'Michelle' AND T1.MiddleName = 'E' AND T1.LastName = 'Cox'",
        "difficulty": ""
    },
    {
        "question": "How many Eredivisie teams have played in 2008?",
        "hint": "Eredivisie is the name of division; 2008 refers to season; teams refer to HomeTeam;",
        "error_sql": "SELECT COUNT(DISTINCT HomeTeam) FROM matchs WHERE season = 2008 AND Div = 'Eredivisie'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is based on the correct columns. In this case, the error SQL query directly used 'Eredivisie' in the WHERE clause with the Div column, which is incorrect because 'Eredivisie' is actually the value in the 'name' column of the 'divisions' table, not the 'division' column. The SQL after reflection correctly joins the 'matchs' table with the 'divisions' table on the 'Div' column and then filters by the 'name' column in the 'divisions' table.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.HomeTeam) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'Eredivisie' AND T1.season = 2008",
        "difficulty": ""
    },
    {
        "question": "How many movies did Wolfgang Reitherman direct?",
        "hint": "Wolfgang Reitherman refers director = 'Wolfgang Reitherman';",
        "error_sql": "SELECT COUNT(T1.movie_title) FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, make sure to join on a common column that exists in both tables. In this case, the join condition `T1.movie_title = T2.name` is incorrect because `T2.name` is actually the `movie_title` column from the `characters` table, not the `movie_title` column itself. However, since we only need to count the number of movies directed by Wolfgang Reitherman, we can simply query the `director` table without joining it with the `characters` table.",
        "ground_truth_sql": "SELECT COUNT(name) FROM director WHERE director = 'Wolfgang Reitherman'",
        "difficulty": ""
    },
    {
        "question": "Among all the residential areas in Delaware, how many of them implement daylight saving?",
        "hint": "\"Delaware\" is a county; implement daylight savings refers to daylight_saving = 'Yes'",
        "error_sql": "SELECT COUNT(T1.zip_code) FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.state = 'Delaware' AND T1.daylight_savings = 'Yes'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is based on the correct columns that relate the two tables. In this case, the error was due to joining the 'state' column from 'zip_data' with the 'abbreviation' column from 'state', and then filtering by 'name' from 'state'. However, the correct join should be between 'zip_code' from 'zip_data' and 'zip_code' from 'country', and then filtering by 'county' from 'country'. Always verify the schema and relationships between tables to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T1.zip_code) FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'DELAWARE' AND T1.daylight_savings = 'Yes'",
        "difficulty": ""
    },
    {
        "question": "Which resource type is commonly bought by the Los Angeles Unified School District?",
        "hint": "resource type refer to project_resource_type; most commonly bought refer to COUNT(project_resource_type where school_district = \u2019Los Angeles Unif Sch Dist\u2019); Los Angeles Unified School District refer to school_district = \u2019Los Angeles Unif Sch Dist\u2019",
        "error_sql": "SELECT project_resource_type FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_district = 'Los Angeles Unif Sch Dist' GROUP BY T2.school_district ORDER BY COUNT(T1.project_resource_type) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen using GROUP BY and ORDER BY in SQL queries, ensure that the column used in GROUP BY is the same as the column used in the SELECT statement, especially when trying to find the most common value. In this case, the GROUP BY should be on T1.project_resource_type instead of T2.school_district, because we are trying to find the most common project_resource_type, not school_district.",
        "ground_truth_sql": "SELECT T1.project_resource_type FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_district = 'Los Angeles Unif Sch Dist' GROUP BY T2.school_district ORDER BY COUNT(T1.project_resource_type) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the average sales of \"\"Sharp AL-1530CS Digital Copier in the east and the west superstore.",
        "hint": "Sharp AL-1530CS Digital Copier' is the \"Product Name\"; average sales = AVG(Sales)",
        "error_sql": "SELECT AVG(T1.Sales) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'Sharp AL-1530CS Digital Copier'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that you are joining on all necessary tables and columns to avoid missing data or incorrect results. In this case, the people table was not joined, which is necessary to ensure that the sales data is correctly linked to the product data. Additionally, when using UNION ALL, ensure that the queries are correctly structured to return the desired results. In this case, the correct query should join the west_superstore table with the people and product tables to get the correct average sales.",
        "ground_truth_sql": "SELECT AVG(T1.Sales) FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T3.`Product Name` = 'Sharp AL-1530CS Digital Copier'",
        "difficulty": ""
    },
    {
        "question": "Identify the percent of long reviews among all 5-star reviews given to businesses by the Yelp users.",
        "hint": "percentage = divide(count(business_id where review_length = 'Long' and review_stars = 5), count(business_id)) * 100%; long reviews refers to review_length = 'Long'; 5-star review refers to review_stars = 5",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.review_length = 'Long' AND T1.review_stars = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) FROM Reviews AS T1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating percentages, ensure that the denominator is the total count of the specific group you're interested in, not the total count of a different column. In this case, the denominator should be the count of reviews with review_length, not the count of business_id. Additionally, apply filters (e.g., WHERE review_stars = 5) before calculating the percentage to ensure you're only considering the relevant data.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN review_length = 'Long' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(review_length) FROM Reviews WHERE review_stars = 5",
        "difficulty": ""
    },
    {
        "question": "Provide the contact person name, title and supplied products by \"Escargots Nouveaux\" company.",
        "hint": "\"Escargots Nouveaux\" company refers to CompanyName = 'Escargots Nouveaux';",
        "error_sql": "SELECT T3.ContactName, T3.Title, T2.ProductName FROM Products AS T2 INNER JOIN Suppliers AS T3 ON T2.SupplierID = T3.SupplierID WHERE T3.CompanyName = 'Escargots Nouveaux'",
        "compiler_hint": "no such column: T1.ContactName",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table aliases are correctly referenced. In this case, the error occurred because the column 'Title' does not exist in the 'Suppliers' table, and the correct column name is 'ContactTitle'. Additionally, the table aliases were incorrectly assigned, leading to incorrect column references. To avoid this mistake, double-check the table schema and column names before writing the SQL query, and ensure that the table aliases are correctly assigned to the corresponding tables.",
        "ground_truth_sql": "SELECT T2.ContactName, T2.ContactTitle, T1.ProductName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T2.CompanyName = 'Escargots Nouveaux'",
        "difficulty": ""
    },
    {
        "question": "What is the highest point highest point of Per Mars in the draft year?",
        "hint": "highest point in the draft year refers to MAX(P);",
        "error_sql": "SELECT MAX(T1.P) FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Per Mars' AND T1.SEASON = T2.draftyear",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the maximum or minimum value of a specific column, consider whether you need to return the entire row or just the maximum/minimum value. In this case, the goal was to find the highest point of 'Per Mars' in the draft year, which requires returning the entire row with the maximum point value, not just the maximum point value itself. To achieve this, use the ORDER BY and LIMIT clauses instead of the MAX function, which allows you to return the entire row with the desired value.",
        "ground_truth_sql": "SELECT T1.P FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Per Mars' ORDER BY T1.P DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "List the full name its capital of all the countries with parliamentary democracy government.",
        "hint": "Parliamentary democracy is a government form",
        "error_sql": "SELECT T1.Name, T1.Capital FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE T2.Government = 'parliamentary democracy'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the selected columns match the query's requirements. In this case, the query asks for the \"full name\" of the country, but the provided SQL queries only select the \"Name\" or \"Capital\" of the country. To fix this, the correct SQL query should select both the \"Name\" and \"Capital\" of the country, or simply the \"Name\" if that is considered the full name. However, the correct interpretation is that the \"full name\" refers to the \"Name\" of the country, not the \"Capital\".",
        "ground_truth_sql": "SELECT T1.Capital FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE T2.Government = 'parliamentary democracy'",
        "difficulty": ""
    },
    {
        "question": "What is the average width and height of the objects in image ID 47? List their object classes as well.",
        "hint": "The bounding box's W and H abbreviations stand for the object's width and height in which average width and height refer to AVG(W) and AVG(H) respectively; image ID 47 refers to IMG_ID = 47; object classes refer to OBJ_CLASS;",
        "error_sql": "SELECT AVG(T1.W), AVG(T1.H), T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 47",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using aggregate functions like AVG() in SQL, make sure to include all non-aggregated columns in the GROUP BY clause to avoid errors. In this case, the OBJ_CLASS column was missing from the GROUP BY clause in the initial query, which would have resulted in an error. The corrected query includes OBJ_CLASS in the GROUP BY clause, ensuring that the AVG() function is applied correctly to each group of object classes.",
        "ground_truth_sql": "SELECT T2.OBJ_CLASS, AVG(T1.W), AVG(T1.H) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 47 GROUP BY T2.OBJ_CLASS",
        "difficulty": ""
    },
    {
        "question": "Please list the full names of all the customers who have rented the film with the highest replacement cost.",
        "hint": "full name refers to first_name, last_name; highest replacement cost refers to Max(replacement_cost)",
        "error_sql": "SELECT T1.first_name, T1.last_name FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T4.replacement_cost = (SELECT MAX(replacement_cost) FROM film)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve data based on a maximum or minimum value, consider using ORDER BY and LIMIT instead of trying to match the exact value with a subquery. This is because the subquery may return multiple values if there are ties for the maximum or minimum, and the main query may not return all the desired results. By using ORDER BY and LIMIT, you can ensure that you get all the rows that have the maximum or minimum value.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id ORDER BY T4.replacement_cost DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the elite users of 10 consecutive year from 2005 to 2014, list down the user ID and their number of compliment on photos.",
        "hint": "from 2005 to 2014 refers to year_id BETWEEN 2005 AND 2014; compliment_type = 'photos';",
        "error_sql": "SELECT T1.user_id, COUNT(T3.compliment_id) FROM Elite AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id INNER JOIN Users_Compliments AS T3 ON T2.user_id = T3.user_id WHERE T3.compliment_id = ( SELECT compliment_id FROM Compliments WHERE compliment_type = 'photos' ) AND T1.year_id BETWEEN 2005 AND 2014",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and conditions are correct. In this case, the error was due to incorrect join order and conditions. The correct join order should start with the Compliments table, then join with Users_Compliments, and finally join with Elite. Additionally, the condition for compliment_type should be applied to the Compliments table, not the Users_Compliments table. To avoid this mistake, carefully analyze the relationships between the tables and ensure that the join conditions are correct.",
        "ground_truth_sql": "SELECT T2.user_id, T2.number_of_compliments FROM Compliments AS T1 INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id INNER JOIN Elite AS T3 ON T2.user_id = T3.user_id WHERE T3.year_id BETWEEN 2005 AND 2014 AND T1.compliment_type = 'photos'",
        "difficulty": ""
    },
    {
        "question": "What are the teams that played in a match with the point of winning margin of 38 on April 30, 2009?",
        "hint": "point of winning margin of 38 refers to win_margin = 38; on April 30, 2009 refers to match_date = '2009-04-30'; team refers to Team_Name;",
        "error_sql": "SELECT T1.Team_Name, T2.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Team AS T3 ON T2.Team_2 = T3.Team_Id OR T2.Team_1 = T3.Team_Id WHERE T2.Win_Margin = 38 AND T2.Match_Date = '2009-04-30'",
        "compiler_hint": "no such column: T3.Team_Name",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and that the columns being referenced exist in the tables being joined. In this case, the error occurred because the join with Win_By table was incorrect, and the column Team_Name was being referenced from the wrong table. To avoid this mistake, carefully review the schema and ensure that the join conditions and column references are correct. Additionally, when retrieving data from multiple tables, consider the relationships between the tables and ensure that the joins are performed correctly to avoid retrieving incorrect or duplicate data.",
        "ground_truth_sql": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 WHERE T2.win_margin = 38 AND match_date = '2009-04-30'",
        "difficulty": ""
    },
    {
        "question": "What is the bounding box of the object sample in image no.5 that has a self-relation?",
        "hint": "bounding box of the object sample refers to (x, y, W, H); image no.5 refers to IMG_ID = 5; has a self-relation refers to OBJ1_SAMPLE_ID = OBJ2_SAMPLE_ID",
        "error_sql": "SELECT T1.X, T1.Y, T1.W, T1.H FROM IMG_OBJ AS T1 INNER JOIN IMG_REL AS T2 ON T1.IMG_ID = T2.IMG_ID AND T1.OBJ_SAMPLE_ID = T2.OBJ1_SAMPLE_ID WHERE T2.OBJ1_SAMPLE_ID = T2.OBJ2_SAMPLE_ID AND T1.IMG_ID = 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition is correct and complete. In this case, the join condition should only include the IMG_ID, as the OBJ_SAMPLE_ID is already filtered by the self-relation condition. Including OBJ_SAMPLE_ID in the join condition may lead to incorrect results if there are multiple object samples in the same image.",
        "ground_truth_sql": "SELECT T2.X, T2.Y, T2.W, T2.H FROM IMG_REL AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.IMG_ID = T2.IMG_ID WHERE T1.IMG_ID = 5 AND T1.OBJ1_SAMPLE_ID = T1.OBJ2_SAMPLE_ID",
        "difficulty": ""
    },
    {
        "question": "Which state has greater than 50 CBSA officers of metro type?",
        "hint": "greater than 50 CBSA officers of metro type refers to COUNT(CBSA_type = 'Metro') > 50;",
        "error_sql": "SELECT T2.name FROM CBSA AS T1 INNER JOIN state AS T2 ON T1.state = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE T1.CBSA_type = 'Metro' GROUP BY T2.name HAVING COUNT(T1.CBSA) > 50",
        "compiler_hint": "no such column: T1.state",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the column being referenced exists in the table. In this case, the error occurred because the `state` column does not exist in the `CBSA` table. To avoid this mistake, carefully review the schema of the tables being joined and ensure that the join condition is correct. Additionally, when referencing columns in the `WHERE` or `GROUP BY` clauses, ensure that the column exists in the table being referenced. In this case, the correct join was with the `zip_data` table, and the correct column to group by was `state` from the `zip_data` table, not `name` from the `state` table.",
        "ground_truth_sql": "SELECT T2.state FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_type = 'Metro' GROUP BY T2.state HAVING COUNT(T1.CBSA_type) > 50",
        "difficulty": ""
    },
    {
        "question": "What is the profit on net of the vendor with the highest standard price? If there are two vendors of the same amount, calculate only for one vendor.",
        "hint": "profit on net = SUBTRACT(LastReceiptCost, StandardPrice);",
        "error_sql": "SELECT MAX(StandardPrice - LastReceiptCost) FROM ProductVendor",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating the profit on net, ensure that the subtraction is performed in the correct order. In this case, the correct calculation is `LastReceiptCost - StandardPrice`, not `StandardPrice - LastReceiptCost`. Additionally, when joining tables, ensure that the correct columns are being referenced and that the join is being performed on the correct keys. In this case, the `Vendor` table should be joined with the `ProductVendor` table on the `BusinessEntityID` column.",
        "ground_truth_sql": "SELECT LastReceiptCost - StandardPrice FROM ProductVendor ORDER BY StandardPrice DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which religion has the largest population in Martinique?",
        "hint": "",
        "error_sql": "SELECT T1.Name FROM religion AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T2.Name = 'Martinique' ORDER BY T1.Percentage DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table aliases are correctly matched. In this case, the error was due to incorrect aliasing and column matching. Additionally, when ordering by a column, ensure that it is the correct column that represents the population, not the percentage of the population. In this case, the population column is not present in the religion table, so it should be joined with the country table to access the population column.",
        "ground_truth_sql": "SELECT T2.Name FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Martinique' ORDER BY T1.population DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "In the year that the Montreal Canadiens had 24 penalty minutes in the Stanley Cup finals, how many wins did the team had in total?",
        "hint": "penalty minutes refer to PIM = 24; wins refer to W;",
        "error_sql": "SELECT SUM(T1.W) FROM Teams AS T1 INNER JOIN TeamsPost AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.name = 'Montreal Canadiens' AND T2.PIM = '24'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition accurately reflects the relationship between the tables. In this case, the error was due to joining Teams with TeamsPost, which is not the correct table to join with. TeamsSC is the correct table to join with because it contains the penalty minutes (PIM) for the Stanley Cup finals. Additionally, when aggregating data, consider whether a GROUP BY clause is necessary to ensure accurate results. In this case, the SUM aggregation function was used, but the query was only returning a single row, so the SUM was not necessary.",
        "ground_truth_sql": "SELECT T2.W FROM Teams AS T1 INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.name = 'Montreal Canadiens' AND T2.PIM = 24",
        "difficulty": ""
    },
    {
        "question": "Which territory has the greatest difference in sales from previous year to this year? Indicate the difference, as well as the name and country of the region.",
        "hint": "greatest difference in sales from previous year to this year refers to Max(Subtract(SalesLastYear,SalesYTD));",
        "error_sql": "SELECT T1.Name, T1.CountryRegionCode, T2.SalesYTD - T2.SalesLastYear AS Difference FROM CountryRegion AS T1 INNER JOIN SalesTerritory AS T2 ON T1.CountryRegionCode = T2.CountryRegionCode ORDER BY T2.SalesYTD - T2.SalesLastYear DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen comparing values to find the greatest difference, ensure that the subtraction is performed in the correct order. In this case, the greatest difference in sales from previous year to this year would be found by subtracting SalesYTD from SalesLastYear, not the other way around. Additionally, the table with the sales data (SalesTerritory) should be the primary table in the JOIN, not the CountryRegion table.",
        "ground_truth_sql": "SELECT SalesLastYear - SalesYTD, Name, CountryRegionCode FROM SalesTerritory ORDER BY SalesLastYear - SalesYTD DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How old was composer of the show when he was nominated for Emmy's Outstanding Music Composition for a Series in 2009. Indicate his full name as well.",
        "hint": "in 2009 refers to year = 2009; old refers to SUBTRACT(2009, birthdate); composer of the show refers to role = 'composer'; Emmy's refers to organization = 'Primetime Emmy Awards'; nominated refers to result = 'Nominee'; Outstanding Music Composition refers to award = 'Outstanding Music Composition for a Series (Original Dramatic Score)'",
        "error_sql": "SELECT T1.name, 2009 - SUBSTR(T1.birthdate, 1, 4) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.year = 2009 AND T2.role = 'composer' AND T2.organization = 'Primetime Emmy Awards' AND T2.result = 'Nominee' AND T2.award = 'Outstanding Music Composition for a Series (Original Dramatic Score)'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen performing date arithmetic, ensure that the date is in a format that can be subtracted directly. In this case, the birthdate is stored as a string, and the year is being extracted using SUBSTR. However, this approach assumes that the birthdate is always in the format 'YYYY-MM-DD', and it does not account for the month and day of birth. A more accurate approach would be to store the birthdate as a date type and use date arithmetic functions to calculate the age. Additionally, when joining tables, ensure that the join condition is correct and that the tables are joined in the correct order. In this case, the Award table should be joined with the Person table on the person column, not the name column.",
        "ground_truth_sql": "SELECT T1.year - T2.birthdate AS ageIn2009, T2.name FROM Award AS T1 INNER JOIN Person AS T2 ON T1.person = T2.name WHERE T1.role = 'composer' AND T1.organization = 'Primetime Emmy Awards' AND T1.award = 'Outstanding Music Composition for a Series (Original Dramatic Score)' AND T1.result = 'Nominee' AND T1.year = 2009;",
        "difficulty": ""
    },
    {
        "question": "How many active businesses are opened during late afternoon in the Phoenix city? List out the top 3 categories name for these businesses.",
        "hint": "opened during late afternoon refers to Business_Hours where opening_time \u2265 '5PM'; active businesses refer to business_id where active = 'true';",
        "error_sql": "SELECT T4.category_name, COUNT(T4.category_name) \nFROM Business AS T1 \nINNER JOIN Business_Hours AS T2 \nON T1.business_id = T2.business_id \nINNER JOIN Business_Categories AS T3 \nON T1.business_id = T3.business_id \nINNER JOIN Categories AS T4 \nON T3.category_id = T4.category_id \nWHERE T1.active = 'true' AND T1.city = 'Phoenix' AND T2.opening_time >= '5PM' \nGROUP BY T4.category_name \nORDER BY COUNT(T4.category_name) DESC \nLIMIT 3",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, it's essential to carefully consider the data types and formats of the columns being compared. In this case, the `opening_time` column is likely in a 12-hour format with AM/PM suffixes, so the comparison should be done with a time string that includes the colon and AM/PM suffix (e.g., '5:00 PM'). Additionally, when retrieving distinct categories, it's better to use `SELECT DISTINCT` instead of `GROUP BY` to avoid unnecessary grouping and counting.",
        "ground_truth_sql": "SELECT DISTINCT T4.category_name FROM Business_Hours AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T2.active = 'true' AND T2.city = 'Phoenix' AND T1.opening_time >= '5PM' LIMIT 3",
        "difficulty": ""
    },
    {
        "question": "List the occupation and income of male customers with an level of education of 4 to 6.",
        "hint": "male customers with an level of education of 4 to 6 refer to SEX = 'Male' where EDUCATIONNUM BETWEEN 4 AND 6; income refers to INCOME_K;",
        "error_sql": "SELECT T1.OCCUPATION, T3.INCOME_K FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.SEX = 'Male' AND T1.EDUCATIONNUM BETWEEN 4 AND 6",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that you are joining the correct tables and that the join conditions are correct. In this case, the error was joining the `Mailings1_2` table which was not necessary for the query. Also, when using the `BETWEEN` operator, it is a good practice to explicitly specify the range to avoid any confusion. Additionally, verify that the column names and table aliases are correct to avoid any errors.",
        "ground_truth_sql": "SELECT T1.OCCUPATION, T2.INCOME_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.EDUCATIONNUM >= 4 AND T1.EDUCATIONNUM <= 6 AND T1.SEX = 'Male'",
        "difficulty": ""
    },
    {
        "question": "How much is the total bonus received by sales person and what is the percentage of it against the projected yearly sales quota in 2013?",
        "hint": "projected yearly sales quota refers to SalesQuota; projected yearly sales quota in 2013 refers to year(QuotaDate) = 2013; percentage = (MULTIPLY(DIVIDE(SUM(Bonus)), (SUM(SalesQuota))) as percentage;",
        "error_sql": "SELECT \n    SUM(T1.Bonus) AS TotalBonus, \n    (SUM(T1.Bonus) / SUM(T2.SalesQuota)) * 100 AS PercentageOfSalesQuota\nFROM \n    SalesPerson AS T1 \nINNER JOIN \n    SalesPersonQuotaHistory AS T2 \nON \n    T1.BusinessEntityID = T2.BusinessEntityID \nWHERE \n    STRFTIME('%Y', T2.QuotaDate) = '2013'",
        "compiler_hint": "no such column: Bonus",
        "reflective_cot": "### Tip:\nTo avoid making the same mistake in the future, it's crucial to carefully examine the database schema and understand the relationships between tables. In this case, the error occurred because the 'Bonus' column does not exist in the 'SalesPersonQuotaHistory' table. Instead, it exists in the 'SalesPerson' table. Therefore, a join operation is required to combine data from both tables. Additionally, the 'SalesQuota' column is also not present in the 'SalesPersonQuotaHistory' table, it's present in the 'SalesPerson' table. Hence, the correct query involves joining the 'SalesPerson' table with the 'SalesPersonQuotaHistory' table to access the required columns.",
        "ground_truth_sql": "SELECT SUM(T1.Bonus) , CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013'",
        "difficulty": ""
    },
    {
        "question": "Which female students had never been absent?",
        "hint": "had never been absent refers to month = 0",
        "error_sql": "SELECT T1.name FROM person AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE T2.month = 0 AND T3.name IS NULL",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen identifying female students, it's incorrect to use a LEFT JOIN with the male table and check for NULL values, as this approach assumes that every person is either male or female, and there are no other possibilities. A better approach is to use a NOT EXISTS or NOT IN clause to exclude male students, or to use a subquery to select all students who are not in the male table. However, in this case, the Ground Truth SQL uses a different approach by joining the male and longest_absense_from_school tables on the condition that the names are not equal, which is a clever way to exclude male students. This approach highlights the importance of thinking creatively and considering different ways to solve a problem in SQL.",
        "ground_truth_sql": "SELECT T2.name FROM male AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name <> T2.name WHERE T2.month = 0",
        "difficulty": ""
    },
    {
        "question": "Provide the sponsor and event of the menu which includes Cerealine with Milk.",
        "hint": "Cerealine with Milk is a name of dish;",
        "error_sql": "SELECT T1.sponsor, T1.event FROM Menu AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE T3.name = 'Cerealine with Milk'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order is correct and that the correct columns are being joined. In this case, the error was due to incorrect join order and incorrect column selection. To avoid this mistake, carefully analyze the table relationships and ensure that the join order makes sense. Additionally, double-check that the correct columns are being selected and joined. In this case, the correct join order is MenuItem -> MenuPage -> Menu -> Dish, and the correct columns to select are sponsor and event from the Menu table.",
        "ground_truth_sql": "SELECT T3.name, T3.event FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T4.name = 'Cerealine with Milk'",
        "difficulty": ""
    },
    {
        "question": "What are the categories of the top 2 oldest events?",
        "hint": "oldest event refers to MIN(timestamp);",
        "error_sql": "SELECT T3.category FROM events AS T1 INNER JOIN events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN app_events_relevant AS T4 ON T2.event_id = T4.event_id INNER JOIN app_labels AS T5 ON T4.app_id = T5.app_id INNER JOIN label_categories AS T3 ON T5.label_id = T3.label_id ORDER BY T1.timestamp LIMIT 2",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and the tables are joined in the correct order. In this case, the error was due to incorrect join conditions and table order. The correct join order should start from the `events_relevant` table, which contains the timestamp, and then join with `app_events_relevant`, `app_labels`, and finally `label_categories`. Additionally, the join conditions should be carefully checked to ensure that the correct relationships between tables are established. To avoid making the same mistake in the future, it's essential to carefully review the database schema and the join conditions to ensure that they are correct and logical.",
        "ground_truth_sql": "SELECT T4.category FROM events_relevant AS T1 INNER JOIN app_events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN app_labels AS T3 ON T3.app_id = T2.app_id INNER JOIN label_categories AS T4 ON T3.label_id = T4.label_id ORDER BY T1.timestamp LIMIT 2",
        "difficulty": ""
    },
    {
        "question": "Calculate the average profit of prom brushed steel products.",
        "hint": "prom brushed steel refers to p_type = 'PROMO BRUSHED STEEL'; average profit = divide(sum(subtract(multiply(l_extendedprice, subtract(1, l_discount)), multiply(ps_supplycost, l_quantity))), count(ps_partkey))",
        "error_sql": "SELECT AVG((l_extendedprice * (1 - l_discount)) - (ps_supplycost * l_quantity)) FROM lineitem INNER JOIN partsupp ON lineitem.l_partkey = partsupp.ps_partkey INNER JOIN part ON partsupp.ps_partkey = part.p_partkey WHERE part.p_type = 'PROMO BRUSHED STEEL'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average of a value, ensure that you are using the correct aggregation function. In this case, the `AVG` function is not suitable because it calculates the average of the entire column, whereas we need to calculate the average of the sum of profits divided by the count of `ps_partkey`. Instead, use the `SUM` function to calculate the total profit and then divide it by the `COUNT` function to get the average profit. Additionally, ensure that the joins are correct and the columns are correctly referenced.",
        "ground_truth_sql": "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity) / COUNT(T1.ps_partkey) FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_type = 'PROMO BRUSHED STEEL'",
        "difficulty": ""
    },
    {
        "question": "What is the average height of player who were born in 1990 and after? Compare the average height with players who were born before 1990.",
        "hint": "average height refers to AVG(height); born in 1990 refers to birthYear = 1990\n",
        "error_sql": "SELECT AVG(height) FROM Master WHERE birthYear >= 1990",
        "compiler_hint": "misuse of aggregate: AVG()",
        "reflective_cot": "### Tip: \nWhen comparing the average of two groups, it's generally better to use a single query with conditional aggregation rather than trying to compare the results of two separate queries. This is because the two separate queries will return two separate values, and it's not possible to directly compare these values within the SQL query. Instead, use a single query with conditional aggregation to calculate the averages of both groups in a single pass, and then compare the results.",
        "ground_truth_sql": "SELECT AVG(IIF(birthYear < 1990, height, NULL)) - AVG(IIF(birthYear >= 1990, height, NULL)) FROM Master",
        "difficulty": ""
    },
    {
        "question": "Among all the suppliers providing the part \"hot spring dodger dim light\", how many of them are in Europe?",
        "hint": "part \"hot spring dodger dim light\" refers to p_name = hot spring dodger dim light; Europe refers to r_name = 'EUROPE'",
        "error_sql": "SELECT COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey INNER JOIN part AS T3 ON T2.ps_partkey = T3.p_partkey INNER JOIN nation AS T4 ON T1.s_nationkey = T4.n_nationkey INNER JOIN region AS T5 ON T4.n_regionkey = T5.r_regionkey WHERE T3.p_name = 'hot spring dodger dim light' AND T5.r_name = 'EUROPE'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the columns used for joining are correct. In this case, the error was in the join order and the columns used for counting. The correct approach is to start with the region table and join it with the nation and supplier tables to get the suppliers in Europe. Then, join the supplier table with the partsupp and part tables to get the suppliers providing the specific part. However, the correct SQL query provided does not even join the partsupp and part tables, it only counts the number of regions in Europe, which is not the correct answer. The correct SQL query should be:\n\n```sql\nSELECT COUNT(T1.s_suppkey) \nFROM supplier AS T1 \nINNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey \nINNER JOIN part AS T3 ON T2.ps_partkey = T3.p_partkey \nINNER JOIN nation AS T4 ON T1.s_nationkey = T4.n_nationkey \nINNER JOIN region AS T5 ON T4.n_regionkey = T5.r_regionkey \nWHERE T3.p_name = 'hot spring dodger dim light' AND T5.r_name = 'EUROPE'\n```\n\nHowever, this query is still not correct because it counts the number of suppliers providing the part \"hot spring dodger dim light\" in Europe, but it does not consider the case where a supplier provides the part in multiple nations in Europe. To get the correct answer, we need to use a subquery to get the suppliers providing the part and then join it with the nation and region tables to get the suppliers in Europe.\n\n```sql\nSELECT COUNT(T1.s_suppkey) \nFROM supplier AS T1 \nINNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey \nINNER JOIN region AS T3 ON T2.n_regionkey = T3.r_regionkey \nWHERE T3.r_name = 'EUROPE' AND T1.s_suppkey IN (\n    SELECT T4.s_suppkey \n    FROM supplier AS T4 \n    INNER JOIN partsupp AS T5 ON T4.s_suppkey = T5.ps_suppkey \n    INNER JOIN part AS T6 ON T5.ps_partkey = T6.p_partkey \n    WHERE T6.p_name = 'hot spring dodger dim light'\n)\n```\n\nThis query first gets the suppliers providing the part \"hot spring dodger dim light\" and then joins it with the nation and region tables to get the suppliers in Europe.",
        "ground_truth_sql": "SELECT COUNT(T1.r_regionkey) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey WHERE T1.r_name = 'EUROPE'",
        "difficulty": ""
    },
    {
        "question": "Among the seafood products, which product have the highest total production of the production?",
        "hint": "seafood product refers to CategoryName = 'Seafood'; product refers to ProductID; highest total production refers to max(add(units in stock, units on order))",
        "error_sql": "SELECT T1.ProductID FROM Products AS T1 INNER JOIN Categories AS T2 ON T1.CategoryID = T2.CategoryID INNER JOIN OrderDetails AS T3 ON T1.ProductID = T3.ProductID WHERE T2.CategoryName = 'Seafood' ORDER BY T3.Quantity DESC LIMIT 1",
        "compiler_hint": "no such column: T1.UnitsInStock",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the columns referenced in the SELECT, WHERE, and ORDER BY clauses actually exist in the tables being queried. In this case, the error occurred because the 'UnitsInStock' and 'UnitsOnOrder' columns do not exist in the 'Products' table. To avoid this mistake, carefully review the schema of the database and verify the existence of columns before referencing them in the query. Additionally, consider using subqueries or joins to access related data from other tables if necessary.",
        "ground_truth_sql": "SELECT T1.ProductName FROM Products AS T1 INNER JOIN Categories AS T2 ON T1.CategoryID = T2.CategoryID WHERE T2.CategoryName = 'Seafood' ORDER BY T1.UnitsInStock + T1.UnitsOnOrder DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "In 2010, how many loses made by team 'BOS' and how many assists were made by the players?",
        "hint": "year = 2010; BOS refers to tmID; loses refer to L; assists refer to A;",
        "error_sql": "SELECT COUNT(T1.L) FROM Teams AS T1 INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID WHERE T1.year = 2010 AND T1.tmID = 'BOS'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition includes all relevant columns to avoid Cartesian product and incorrect results. In this case, the join condition should include both 'tmID' and 'year' to correctly match rows between the 'Teams' and 'Scoring' tables. Additionally, use SUM instead of COUNT to calculate the total number of loses and assists, as COUNT would only count the number of rows, not the actual values in the 'L' and 'A' columns.",
        "ground_truth_sql": "SELECT SUM(T1.L), SUM(T2.A) FROM Teams AS T1 INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.tmID = 'BOS' AND T1.year = 2010",
        "difficulty": ""
    },
    {
        "question": "How many users in Mubi give the movie \"White Night Wedding for 5\"?",
        "hint": "White Night Wedding' is movie_title; for 5 refers to rating_score = 5;",
        "error_sql": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'White Night Wedding' AND T1.rating_score = 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, ensure that the conditions in the WHERE clause are correctly ordered and logically consistent. In this case, the correct query should have the conditions in the same order as they appear in the problem statement, i.e., first filter by rating_score and then by movie_title. However, the actual order of conditions in the WHERE clause does not affect the result, as SQL evaluates all conditions before returning the result. The mistake in the Error SQL Query and SQL after Reflection is not actually an error, and both queries should return the correct result. The Ground Truth SQL is identical to the Error SQL Query and SQL after Reflection, and it is not actually a correction. To avoid confusion, it's essential to carefully review the problem statement and the generated SQL queries to ensure that they accurately reflect the requirements.",
        "ground_truth_sql": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_score = 5 AND T2.movie_title = 'White Night Wedding'",
        "difficulty": ""
    },
    {
        "question": "List the name, address, and phone number of companies that supply products for more than thirty dollars per unit.",
        "hint": "more than thirty dollars per unit refers to UnitPrice > 30",
        "error_sql": "SELECT T2.SupplierName, T2.Address, T2.Phone FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.Price > 30",
        "compiler_hint": "no such column: T2.CompanyName",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names in the SELECT statement match the actual column names in the tables being joined. In this case, the error occurred because the column name in the Suppliers table is actually 'SupplierName', not 'CompanyName'. Additionally, the WHERE clause condition should be based on the correct column name, which is 'Price' in the Products table, not 'UnitPrice'. To avoid this mistake, double-check the column names in the table schema before writing the SQL query.",
        "ground_truth_sql": "SELECT T2.CompanyName, T2.Address, T2.Phone FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.UnitPrice > 30",
        "difficulty": ""
    },
    {
        "question": "What is the size of the smallest part in a jumbo case container?",
        "hint": "size refers to p_size; the smallest part refers to min(p_size); jumbo case container refers to p_container = 'JUMBO CASE'",
        "error_sql": "SELECT MAX(p_size) FROM part WHERE p_size IS NOT NULL AND p_size IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen writing SQL queries, it's essential to carefully read and understand the problem statement. In this case, the mistake was using MAX instead of MIN to find the smallest part size, and also not including the condition for the 'JUMBO CASE' container. To avoid this mistake, take your time to analyze the problem, identify the key elements, and ensure that your query accurately reflects the requirements. Additionally, double-check your query for any logical errors before executing it.",
        "ground_truth_sql": "SELECT MIN(p_size) FROM part WHERE p_container = 'JUMBO CASE'",
        "difficulty": ""
    },
    {
        "question": "Among the employees who work as a Trainee, how many of them have a salary of over &20,000 a year?",
        "hint": "Trainee is a position title; salary of over 20,000 refers to salary > '20000'",
        "error_sql": "SELECT COUNT(T1.ssn) FROM employee AS T1 INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE T2.positiontitle = 'Trainee' AND T1.salary > '20000'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen comparing strings that represent numbers, it's essential to convert them to a numeric data type to ensure accurate results. In this case, the salary column is a string that includes a currency symbol and commas, which need to be removed and converted to a numeric type (REAL in this case) before comparison. Additionally, when using COUNT, it's more efficient and idiomatic to use COUNT(*) instead of COUNT(column_name), as it counts all rows, regardless of the column's value.",
        "ground_truth_sql": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000 AND T2.positiontitle = 'Trainee'",
        "difficulty": ""
    },
    {
        "question": "What is the full address of business number 24?",
        "hint": "Full address refers to AddressLine1+AddressLine2; business number 24 refers to BusinessEntityID = '24'",
        "error_sql": "SELECT AddressLine1 + AddressLine2 FROM Address WHERE AddressID = ( SELECT AddressID FROM BusinessEntityAddress WHERE BusinessEntityID = 24 )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, it's essential to specify the join type (e.g., INNER JOIN, LEFT JOIN, RIGHT JOIN) and the join condition (e.g., ON T1.AddressID = T2.AddressID). In this case, the error SQL query was missing the join type and condition, which would have resulted in a syntax error. Additionally, the query was trying to concatenate AddressLine1 and AddressLine2 using the \"+\" operator, which is not the correct way to concatenate strings in SQL. Instead, the correct query uses the INNER JOIN clause to join the Address and BusinessEntityAddress tables on the AddressID column, and returns the AddressLine1 and AddressLine2 columns separately.",
        "ground_truth_sql": "SELECT T1.AddressLine1, T1.AddressLine2 FROM Address AS T1 INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE T2.BusinessEntityID = 24",
        "difficulty": ""
    },
    {
        "question": "What is the name of the supplier that supplies the most products to the company?",
        "hint": "name of the supplier refers to SupplierID; the most product refers to max(count(ProductID))",
        "error_sql": "SELECT T2.SupplierName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID GROUP BY T2.SupplierID, T2.SupplierName ORDER BY COUNT(T1.ProductID) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen performing aggregation operations, such as finding the maximum count, it's essential to ensure that the GROUP BY clause only includes the columns that uniquely identify each group. In this case, the error SQL query and SQL after reflection incorrectly included both SupplierID and SupplierName in the GROUP BY clause. This is unnecessary and can lead to incorrect results. Instead, only the SupplierID should be included in the GROUP BY clause, as it uniquely identifies each supplier. Additionally, using COUNT(*) is more efficient and clear than COUNT(T1.ProductID), as it directly counts the number of rows in each group.",
        "ground_truth_sql": "SELECT T1.SupplierID FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID GROUP BY T1.SupplierID ORDER BY COUNT(*) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many employees from USA with Sales Representative title?",
        "hint": "from USA refers to Country = 'USA'",
        "error_sql": "SELECT COUNT(T1.EmployeeID) FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE T3.Country = 'USA' AND T1.Title = 'Sales Representative'",
        "compiler_hint": "no such column: T2.EmployeeID",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns being referenced exist in the tables being joined. In this case, the error was due to joining Employees with Customers on the wrong column (EmployeeID with CustomerID) and also referencing a non-existent column (Title) in the Employees table. Additionally, the Employees table does not have a Country column, it's the Customers and Suppliers tables that have this column. To avoid this mistake, carefully review the schema of the tables involved and ensure that the join conditions and column references are correct.",
        "ground_truth_sql": "SELECT COUNT(Country) FROM Employees WHERE Country = 'USA' AND Title = 'Sales Representative'",
        "difficulty": ""
    },
    {
        "question": "Which regions have online sales channels that have the most discounts?",
        "hint": "most discount refers to Max(Discount Applied)",
        "error_sql": "SELECT T4.Region FROM \"Sales Orders\" AS T1 INNER JOIN \"Store Locations\" AS T2 ON T1._StoreID = T2.StoreID INNER JOIN Regions AS T3 ON T2.StateCode = T3.StateCode INNER JOIN \"Sales Team\" AS T4 ON T3.Region = T4.Region WHERE T1.`Sales Channel` = 'Online' ORDER BY T1.`Discount Applied` DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully analyze the relationships between tables and the conditions specified in the problem. In this case, the error was due to incorrect joining of tables and misunderstanding of the problem's requirements. The correct solution only requires joining the \"Sales Orders\" table with the \"Sales Team\" table, as the region information is directly related to the sales team, not the store location or customer. To avoid similar mistakes, always carefully read the problem statement, identify the relevant tables and columns, and ensure that the joins and conditions are correct and necessary.",
        "ground_truth_sql": "SELECT T2.Region FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T1.`Sales Channel` = 'Online' ORDER BY T1.`Discount Applied` DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Did the tallest player got in the Hall of Fame? If yes, please list the year when he got in the Hall of Fame.",
        "hint": "tallest player refers to max(height)",
        "error_sql": "SELECT T2.year FROM Master AS T1 INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID ORDER BY T1.height DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the tallest player who got into the Hall of Fame, we should first find the maximum height from the Master table, then use this height to find the corresponding player(s) in the Master table, and finally check if this player(s) has a record in the HOF table. The original SQL query was incorrect because it simply sorted the players by height in descending order and took the first one, which may not necessarily be the tallest player who got into the Hall of Fame. The SQL after Reflection was closer to the correct solution, but it still had a potential issue: if there are multiple players with the same maximum height, it would only return one of them. However, since the question only asks for the year when the tallest player got into the Hall of Fame, and it is assumed that there is only one tallest player, the Ground Truth SQL query is sufficient.",
        "ground_truth_sql": "SELECT CASE WHEN T1.hofID IS NULL THEN 'NO' ELSE T2.year END FROM Master AS T1 LEFT JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T1.height = ( SELECT MAX(height) FROM Master )",
        "difficulty": ""
    },
    {
        "question": "Please list the countries under the lending category of the International Development Associations and have a external debt reporting finished by estimation.",
        "hint": "countries refer to the ShortName; International Development Associations refers to lendingcategory = 'IDA'; have a external debt reporting finished by estimation refers to ExternalDebtReportingStatus = 'Estimate'",
        "error_sql": "SELECT ShortName FROM Country WHERE LendingCategory = 'IDA' AND ExternalDebtReportingStatus = 'Estimate'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen filtering data based on specific conditions, ensure that the exact values or phrases are matched. In this case, the error occurred due to a mismatch between 'Estimate' and 'Estimation'. To avoid this mistake, double-check the values in the database or the problem statement to ensure accuracy. Additionally, consider using the 'LIKE' operator or regular expressions if the values are not exact or contain variations.",
        "ground_truth_sql": "SELECT ShortName, ExternalDebtReportingStatus FROM Country WHERE LendingCategory = 'IDA'",
        "difficulty": ""
    },
    {
        "question": "What proportion of orders are taken by the Sales Representative?",
        "hint": "DIVIDE(COUNT(OrderID where Title = 'Sales Representative'), COUNT(OrderID)) as percentage;",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.Title = 'Sales Representative' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.OrderID) FROM Orders AS T1 INNER JOIN Employees AS T2 ON T1.EmployeeID = T2.EmployeeID",
        "compiler_hint": "no such column: T2.Title",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that you are referencing the correct table and column names. In this case, the error occurred because the 'Title' column does not exist in the Employees table. The Employees table only has 'LastName' and 'FirstName' columns, but no 'Title' column. To avoid this mistake, carefully review the schema of the tables involved in the query and ensure that the column names match. Additionally, consider using table aliases that clearly indicate the table being referenced, such as 'E' for Employees and 'O' for Orders, to reduce confusion.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T1.Title = 'Sales Representative' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.OrderID) FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID",
        "difficulty": ""
    },
    {
        "question": "List all products with minimum order quantity of 100 and order them by product name in descending order.",
        "hint": "miinimum order quantity refers to MinOrderQty = 100",
        "error_sql": "SELECT ProductID, Name \nFROM Product \nWHERE MinOrderQty = 100 \nORDER BY Name DESC",
        "compiler_hint": "no such column: MinOrderQty",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the columns being selected are from the correct tables and that the join conditions are accurate. In this case, the error occurred because the MinOrderQty column is not in the Product table, but rather in the ProductVendor table. To avoid this mistake, carefully review the schema and ensure that the columns being selected and the join conditions are correct. Additionally, when selecting distinct values, use the DISTINCT keyword to ensure that only unique values are returned.",
        "ground_truth_sql": "SELECT DISTINCT T1.Name FROM Product AS T1 INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID WHERE T2.MinOrderQty = 100 ORDER BY T1.Name DESC",
        "difficulty": ""
    },
    {
        "question": "What is the series code for number of infant deaths in year 1965 for the country whose full name is Islamic State of Afghanistan?",
        "hint": "number of infant deaths refers to IndicatorName = 'Number of infant deaths'; in year 1965 refers to Year = '1965'; full name is Islamic State of Afghanistan refers to LongName = 'Islamic State of Afghanistan'",
        "error_sql": "SELECT T3.SeriesCode FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN Series AS T3 ON T2.IndicatorCode = T3.SeriesCode WHERE T1.LongName = 'Islamic State of Afghanistan' AND T2.IndicatorName = 'Number of infant deaths' AND T2.Year = 1965",
        "compiler_hint": "no such column: T2.SeriesCode",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column you are trying to access exists in the table you are referencing. In this case, the error occurred because the `SeriesCode` column does not exist in the `Indicators` table. It exists in the `Series` table, but the correct join should be with the `CountryNotes` table which has a foreign key referencing the `Series` table. Always verify the schema and relationships between tables to avoid such mistakes.",
        "ground_truth_sql": "SELECT DISTINCT T3.Seriescode FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN CountryNotes AS T3 ON T2.CountryCode = T3.Countrycode WHERE T2.IndicatorName = 'Number of infant deaths' AND T1.LongName = 'Islamic State of Afghanistan' AND T2.Year = 1965",
        "difficulty": ""
    },
    {
        "question": "How long has the \"Clear Green Turtle\" dish appeared on the menu, and tell me when its latest update was?",
        "hint": "Clear Green Turtle is a name of dish; how long a dish appeared on the menu = SUBTRACT(last_appeared, first_appeared); latest update refers to latest updated_at;",
        "error_sql": "SELECT (T1.last_appeared - T1.first_appeared) AS duration, T2.updated_at FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Clear Green Turtle' ORDER BY T2.updated_at DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables and selecting data, ensure that the aggregate function (in this case, MAX) is not necessary if you're already ordering the results by the desired column and limiting to the most recent update. Additionally, be mindful of the data types and operations being performed, as the original query attempted to subtract two integers (last_appeared and first_appeared) which would result in the number of years, but the query also attempted to get the latest update time which is not necessarily related to the duration the dish appeared on the menu. The correct approach is to simply join the tables, filter by the desired dish, and order by the update time to get the latest update.",
        "ground_truth_sql": "SELECT T1.last_appeared - T1.first_appeared, T2.updated_at FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Clear green turtle'",
        "difficulty": ""
    },
    {
        "question": "Which state has the highest number of clients who gave a 5-star review?",
        "hint": "highest number of clients refers to MAX(COUNT(client_id)); 5-star review refers to stars = 5;",
        "error_sql": "SELECT T1.State \nFROM state AS T1 \nINNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev \nINNER JOIN reviews AS T3 ON T2.district_id = T3.district_id \nINNER JOIN client AS T4 ON T2.district_id = T4.district_id \nWHERE T3.Stars = 5 \nGROUP BY T1.State \nORDER BY COUNT(T4.client_id) DESC \nLIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and that the columns being joined are the correct ones. In this case, the error was in joining the `client` table with the `district` table on `district_id`, but then not using the `client_id` from the `client` table to join with the `reviews` table. Instead, the `district_id` from the `district` table was used again to join with the `reviews` table, which is incorrect. To avoid this mistake, carefully review the schema of the tables and the join conditions to ensure that they are correct and logical. Additionally, when using aggregate functions like `COUNT`, make sure to count the correct column, in this case, it should be `T1.district_id` or `T2.district_id` instead of `T4.client_id` or `T2.state_abbrev`.",
        "ground_truth_sql": "SELECT T2.state_abbrev FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.Stars = 5 GROUP BY T2.state_abbrev ORDER BY COUNT(T2.state_abbrev) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Tweets posted from which city has a higher number of average likes, Bangkok or Chiang Mai?",
        "hint": "\"Bangkok\" and \"Chiang Mai\" are both City; average number of like = Divide (Sum(Likes), Count(TweetID))",
        "error_sql": "SELECT T3.City FROM twitter AS T1 INNER JOIN location AS T3 ON T1.LocationID = T3.LocationID WHERE T3.City IN ('Bangkok', 'Chiang Mai') GROUP BY T3.City ORDER BY AVG(T1.Likes) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen comparing two values, it's generally more accurate to calculate both values separately and then compare them, rather than trying to order and limit the results. This is because ordering and limiting can lead to incorrect results if the values are not distinct or if there are multiple maximum/minimum values. In this case, the original query was trying to order the cities by their average likes and then limit the result to the top one, but this approach is flawed because it doesn't actually compare the two cities. Instead, the correct approach is to calculate the average likes for each city separately and then compare the results.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.City = 'Bangkok' THEN Likes ELSE NULL END) / COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE 0 END) AS bNum , SUM(CASE WHEN City = 'Chiang Mai' THEN Likes ELSE NULL END) / COUNT(CASE WHEN City = 'Chiang Mai' THEN TweetID ELSE NULL END) AS cNum FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.City IN ('Bangkok', 'Chiang Mai')",
        "difficulty": ""
    },
    {
        "question": "Indicate if there is any pair formed by the words fukunaga and d'egees.",
        "hint": "Pair is a relationship of two words: w1st and w2nd, where w1st is word id of the first word and w2nd is a word id of the second word;\u00a0 w1st = word = 'fukunaga' or w2nd = word = 'fukunaga'; w1st = word = 'd'egees'or w2nd = word = 'd'egees';",
        "error_sql": "SELECT CASE WHEN COUNT(*) > 0 THEN 'Yes' ELSE 'No' END FROM biwords AS T1 INNER JOIN words AS T2 ON T1.w1st = T2.wid INNER JOIN words AS T3 ON T1.w2nd = T3.wid WHERE (T2.word = 'fukunaga' AND T3.word = 'd''egees') OR (T2.word = 'd''egees' AND T3.word = 'fukunaga')",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables with multiple conditions, ensure that the conditions are correctly applied to the correct tables and columns. In this case, the error was in the WHERE clause, where the conditions were applied to T2 and T3, but the correct conditions should be applied to T1 and the subqueries. Additionally, when using OR conditions in a JOIN, ensure that the conditions are correctly applied to the correct columns. In this case, the correct JOIN condition is T1.wid = T2.w1st OR T1.wid = T2.w2nd, but the correct conditions for the words should be applied to T1 and the subqueries. Furthermore, when using LIKE operator, ensure that the correct wildcard character is used, in this case, the correct query uses 'd%egees' instead of 'd''egees'.",
        "ground_truth_sql": "SELECT CASE WHEN COUNT(T1.wid) > 0 THEN 'yes' ELSE 'no' END FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st OR T1.wid = T2.w2nd WHERE T2.w1st = ( SELECT wid FROM words WHERE T1.word = 'fukunaga' ) AND T2.w2nd = ( SELECT wid FROM words WHERE word LIKE 'd%egees' )",
        "difficulty": ""
    },
    {
        "question": "Among all publications containing keywords 'Turbulent Fluids', what percentage of them was published in the journal named 'Physics of Fluids'?",
        "hint": "'Physics of Fluids' is the FullName of journal; percentage = DIVIDE(SUM(Keyword = 'Turbulent Fluids'), SUM(FullName = 'Physics of Fluids')) as percentage",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.Keyword = 'Turbulent Fluids' AND T2.FullName = 'Physics of Fluids' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.Keyword = 'Turbulent Fluids' THEN 1 ELSE 0 END) FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating the percentage of a subset within a larger set, ensure that the numerator and denominator are correctly defined. In this case, the numerator should be the count of papers with the keyword 'Turbulent Fluids' and the denominator should be the count of papers published in the journal 'Physics of Fluids'. The original query incorrectly combined the conditions for the numerator, and the second query incorrectly used the same condition for both the numerator and denominator. To avoid this mistake, carefully define the conditions for the numerator and denominator separately, and ensure that they accurately represent the desired subset and larger set.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.Keyword = 'Turbulent Fluids' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.FullName = 'Physics of Fluids' THEN 1 ELSE 0 END) FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id",
        "difficulty": ""
    },
    {
        "question": "For the pairs of genes with one having 8 chromosomes and the other having 6 chromosomes, what is the highest expression correlation score?",
        "hint": "",
        "error_sql": "SELECT MAX(T3.Expression_Corr) FROM Genes AS T1 INNER JOIN Genes AS T2 ON T1.GeneID != T2.GeneID INNER JOIN Interactions AS T3 ON (T1.GeneID = T3.GeneID1 AND T2.GeneID = T3.GeneID2) OR (T1.GeneID = T3.GeneID2 AND T2.GeneID = T3.GeneID1) WHERE (T1.Chromosome = 8 AND T2.Chromosome = 6) OR (T1.Chromosome = 6 AND T2.Chromosome = 8)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, consider the conditions that define the relationship between the tables. In this case, the error was in joining two instances of the Genes table and then joining the Interactions table, which led to incorrect results. Instead, join the Genes table with the Interactions table directly, and use the conditions to filter the results. Additionally, when looking for the highest expression correlation score, use the ORDER BY and LIMIT clauses to get the top result, rather than using MAX with multiple joins.",
        "ground_truth_sql": "SELECT T2.Expression_Corr FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Chromosome = 6 OR T1.Chromosome = 8 ORDER BY T2.Expression_Corr DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the increment percentage of elite user for each year since year 2005.",
        "hint": "since year 2005 refers to year_id Between 2005 and 2014; increment percentage = Divide(Count(user_id(year_id < 2014)), Count (user_id(year_id = 2015))) * 100",
        "error_sql": "SELECT T1.year_id, T2.user_id, T3.user_id FROM Years AS T1 INNER JOIN Elite AS T2 ON T1.year_id = T2.year_id INNER JOIN Elite AS T3 ON T2.user_id = T3.user_id WHERE T1.year_id BETWEEN 2005 AND 2014",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating increment percentages, ensure that the denominator is the initial value (in this case, the count of elite users in 2005) and the numerator is the total count of users across all years (excluding the initial year). Avoid using JOINs when not necessary, and use CASE statements to filter data within the COUNT function. Also, be mindful of the data type when performing division to avoid integer division, which can result in truncated decimal values.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN year_id < 2014 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(CASE WHEN year_id = 2005 THEN 1.0 ELSE NULL END) AS increment FROM Elite",
        "difficulty": ""
    },
    {
        "question": "Name the goalies who have played more than total of 5000 minutes in the all the season played. State given name of the player and from which country was he born.",
        "hint": "played more than total of 5000 minutes refers to SUM(Min)>5000;country he was born refers to birthCountry\n",
        "error_sql": "SELECT T1.nameGiven, T1.birthCountry FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID GROUP BY T1.playerID HAVING SUM(T2.Min) > 5000",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen using the GROUP BY clause, it's essential to include all non-aggregated columns from the SELECT statement in the GROUP BY clause to avoid incorrect results. In this case, the initial error was due to not including all columns from the SELECT statement in the GROUP BY clause. The corrected query uses DISTINCT to remove duplicate rows, and the GROUP BY clause includes all columns from the SELECT statement.",
        "ground_truth_sql": "SELECT DISTINCT T1.nameGiven, T1.birthCountry FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID GROUP BY T1.nameGiven, T1.birthCountry HAVING SUM(T2.Min) > 5000",
        "difficulty": ""
    },
    {
        "question": "Among the episode that get more than 950 votes, how many of the episodes were nominated for the 'Outstanding Voice-Over Performance Award in 2009'? Find the percentage of the episodes.",
        "hint": "more than 950 votes refers to votes > 950; in 2009 refers to year = 2009; number of episode = Count(episode_id); nominated refers to result = 'Nominee'; percentage = Divide(Count(award = 'Outstanding Voice-Over Performance'), Count(episode_id)) * 100",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN T2.award = 'Outstanding Voice-Over Performance' THEN T2.episode_id END) AS REAL) * 100 / COUNT(T1.episode_id) FROM Vote AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T1.votes > 950 AND T2.year = 2009 AND T2.result = 'Nominee'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join is performed on the correct tables and columns. In this case, the join should be performed between the Award table and the Episode table, not the Vote table. Additionally, when using aggregate functions, use SUM instead of COUNT when counting conditional values, and use ELSE 0 to handle cases where the condition is not met.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.award = 'Outstanding Voice-Over Performance' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.episode_id) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.votes > 950 AND T1.year = 2009;",
        "difficulty": ""
    },
    {
        "question": "Which 2 Scottish teams scored 10 goals playing as a local team and in which seasons?",
        "hint": "local team refers to HomeTeam; Scottish means belong to the country = 'Scotland'; scored 10 goals refer to FTHG = 10, which is short name for Final-time Away-team Goals;",
        "error_sql": "SELECT T1.HomeTeam, T2.season FROM matchs AS T1 INNER JOIN matchs AS T2 ON T1.HomeTeam = T2.HomeTeam WHERE T1.FTHG = 10 AND T2.FTHG = 10 AND T1.Div IN (SELECT division FROM divisions WHERE country = 'Scotland')",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join is performed with a table that contains the required information, rather than joining the same table twice. In this case, joining `matchs` with `divisions` is necessary to filter by country, but joining `matchs` with itself is unnecessary and can lead to incorrect results. Additionally, when selecting columns, only choose the columns that are required to answer the question, avoiding unnecessary columns that can lead to incorrect results.",
        "ground_truth_sql": "SELECT T1.HomeTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.country = 'Scotland' AND T1.FTHG = 10",
        "difficulty": ""
    },
    {
        "question": "How many businesses from ward 42 have at least 5 failed inspection results between 1/1/2010 to 12/31/2015?",
        "hint": "ward 42 refers to ward = 42; at least 5 failed inspection results refers to count(results = 'Fail') > = 5; between 1/1/2010 to 12/31/2015 refers to inspection_date between '2010-01-01' and '2015-12-31'",
        "error_sql": "SELECT COUNT(DISTINCT T1.license_no) \nFROM establishment AS T1 \nINNER JOIN inspection AS T2 \nON T1.license_no = T2.license_no \nWHERE T1.ward = 42 \nAND T2.inspection_date BETWEEN '2010-01-01' AND '2015-12-31' \nAND T2.results = 'Fail'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, it's essential to carefully consider the conditions and filters applied to the data. In this case, the initial query was incorrect because it only counted businesses with at least one failed inspection result, not at least 5. The second query was closer, but it still had a logical flaw. The correct approach is to first identify the businesses with at least 5 failed inspection results and then filter those results by ward and date range. To avoid similar mistakes in the future, make sure to break down complex queries into smaller, manageable parts, and verify that each part is correctly filtering the data. Additionally, use subqueries or Common Table Expressions (CTEs) to simplify complex logic and improve readability.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T2.inspection_date BETWEEN '2010-01-01' AND '2015-12-31' AND T1.ward = 42 AND T1.license_no IN ( SELECT license_no FROM ( SELECT license_no FROM inspection WHERE results = 'Fail' GROUP BY license_no HAVING COUNT(results) >= 5 ) )",
        "difficulty": ""
    },
    {
        "question": "What is the average unit price of Tokyo Traders' products?",
        "hint": "\"Tokyo Traders\" is the CompanyName; average unit price = AVG(UnitPrice)",
        "error_sql": "SELECT AVG(T1.Price) FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T2.SupplierName = 'Tokyo Traders'",
        "compiler_hint": "no such column: T2.CompanyName",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names in the WHERE clause match the actual column names in the tables. In this case, the error occurred because the column name was 'SupplierName' instead of 'CompanyName'. Additionally, when calculating the average unit price, it's more accurate to use the SUM of UnitPrice divided by the COUNT of products, rather than directly using AVG function on Price, as the latter may not account for the quantity of each product.",
        "ground_truth_sql": "SELECT SUM(T1.UnitPrice) / COUNT(T2.SupplierID) FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T2.CompanyName = 'Tokyo Traders'",
        "difficulty": ""
    },
    {
        "question": "Calculate the percentage of business with attribute name of \"Accepts Credit Cards\".",
        "hint": "percentage refers to DIVIDE(COUNT(attribute_name = 'Accepts Credit Cards'), COUNT(business_id))*100%",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.attribute_name = 'Accepts Credit Cards' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id",
        "compiler_hint": "no such column: T2.attribute_name",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column you are referencing in the WHERE or CASE clause is from the correct table. In this case, the error occurred because the column 'attribute_name' was referenced from the wrong table (T2 instead of T1). To avoid this mistake, double-check the table aliases and column names to ensure they match the actual table and column names in the database schema. Additionally, when using aggregate functions like SUM and COUNT, make sure to use the correct column and table alias to avoid incorrect results.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.attribute_name = 'Accepts Credit Cards' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.attribute_name) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id",
        "difficulty": ""
    },
    {
        "question": "Calculate the average players out in the first innings per match. How many of them were out by the leg before wicket?",
        "hint": "out by the leg refers to Out_Name = 'lbw'; out in the first innings refers to Innings_No = 2;",
        "error_sql": "SELECT CAST(SUM(CASE WHEN Kind_Out = (SELECT Out_Id FROM Out_Type WHERE Out_Name = 'lbw') THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT Match_Id) FROM Wicket_Taken WHERE Innings_No = 2",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen calculating averages or performing aggregations, ensure that the denominator accurately represents the total number of groups or units being averaged. In this case, the error was in using `COUNT(DISTINCT Match_Id)` instead of `COUNT(Match_Id)` or simply `COUNT(T1.Match_Id)`, which would give the correct total number of matches. Additionally, when joining tables, ensure that the join conditions are correct and that the correct columns are being referenced. In this case, the error was in using `Innings_No = 1` instead of `Innings_No = 2` to filter for the first innings.",
        "ground_truth_sql": "SELECT CAST(COUNT(T1.Player_Out) AS REAL) / COUNT(T1.Match_Id), SUM(CASE WHEN T2.Out_Name = 'lbw' THEN 1 ELSE 0 END) FROM Wicket_Taken AS T1 INNER JOIN Out_Type AS T2 ON T1.Kind_Out = T2.Out_Id WHERE T1.Innings_No = 2",
        "difficulty": ""
    },
    {
        "question": "List the titles for all Catalan language wikipedia page from revision page id 106600 to 106700.",
        "hint": "from revision page id 106600 to 106700 refers to revision BETWEEN 106600 AND 106700",
        "error_sql": "SELECT T1.title FROM pages AS T1 INNER JOIN langs AS T2 ON T1.lid = T2.lid WHERE T2.lang = 'Catalan' AND T1.revision BETWEEN 106600 AND 106700",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and applying filters, carefully examine the column names and their corresponding table associations to avoid mistakenly using the wrong column. In this case, the filter condition should be applied to the 'revision' column, not 'page' or 'revision' from the wrong table. Always double-check the schema and the query to ensure that the correct columns are being used.",
        "ground_truth_sql": "SELECT title FROM pages WHERE revision BETWEEN 106600 AND 106700",
        "difficulty": ""
    },
    {
        "question": "For the third largest country, which ethinic group has the most population?",
        "hint": "",
        "error_sql": "SELECT T3.Name FROM country AS T1 INNER JOIN province AS T2 ON T1.Code = T2.Country INNER JOIN ethnicGroup AS T3 ON T2.Name = T3.Country ORDER BY T2.Area DESC LIMIT 1 OFFSET 2",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being referenced. In this case, the mistake was in the join condition between the country and ethnicGroup tables. The country table's Code column should be matched with the ethnicGroup table's Country column, not the province table's Name column. Additionally, when calculating the population of each ethnic group, the population of the country should be multiplied with the percentage of the ethnic group, not the population of the province.",
        "ground_truth_sql": "SELECT T2.Name FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T1.Name = ( SELECT Name FROM country ORDER BY Area DESC LIMIT 2, 1 ) GROUP BY T2.Name ORDER BY T2.Percentage * T1.Population DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of the total products ordered were not rejected by Drill size?",
        "hint": "rejected quantity refers to ScrappedQty; rejected by Drill size refers to Name in ('Drill size too small','Drill size too large'); percentage = DIVIDE(SUM(ScrappedQty) where Name in('Drill size too small','Drill size too large'), OrderQty)",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T2.Name IN ('Drill size too small', 'Drill size too large') THEN T1.ScrappedQty ELSE 0 END) AS REAL) * 100 / SUM(T1.OrderQty) FROM WorkOrder AS T1 INNER JOIN ScrapReason AS T2 ON T1.ScrapReasonID = T2.ScrapReasonID",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nThe issue with the first two SQL queries is that they do not accurately translate the given problem statement into SQL code. The first query is trying to find the percentage of total products ordered that were rejected by Drill size, but it does not accurately calculate this percentage. The second query is trying to find the percentage of total products ordered that were not rejected by Drill size, but it still does not accurately calculate this percentage. The issue with both queries is that they do not take into account the total number of products ordered, but rather only the number of products that were rejected or not rejected by Drill size.\n\nTo avoid making the same mistake in the future, it is important to carefully read and understand the problem statement before trying to translate it into SQL code. It is also important to make sure that the SQL code accurately calculates the desired percentage or quantity, and that it takes into account all relevant information, such as the total number of products ordered.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.VacationHours > 20 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.BusinessEntityID) FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.CurrentFlag = 1 AND T2.SickLeaveHours > 10",
        "difficulty": ""
    },
    {
        "question": "What type of interactions occurs in genes whose function is cellular transport and transport medicine and are classified as non-essential?",
        "hint": "",
        "error_sql": "SELECT DISTINCT T3.Type FROM Genes AS T1 INNER JOIN Genes AS T2 ON T1.GeneID != T2.GeneID INNER JOIN Interactions AS T3 ON (T1.GeneID = T3.GeneID1 AND T2.GeneID = T3.GeneID2) OR (T1.GeneID = T3.GeneID2 AND T2.GeneID = T3.GeneID1) WHERE (T1.Function = 'cellular transport' AND T2.Function = 'transport medicine') AND (T1.Essential = 'Non-essential' AND T2.Essential = 'Non-essential')",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen generating SQL queries, carefully analyze the question and ensure that the query accurately reflects the conditions specified. In this case, the error was due to a mismatch between the conditions in the query and the conditions specified in the question. Specifically, the query was looking for genes with functions 'cellular transport' and 'transport medicine', but the ground truth SQL was looking for genes with function 'TRANSCRIPTION'. Additionally, the query was joining two instances of the Genes table, which was unnecessary. To avoid making the same mistake in the future, take the time to carefully read and understand the question, and ensure that the query accurately reflects the conditions specified.",
        "ground_truth_sql": "SELECT T2.Type FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Function = 'TRANSCRIPTION' AND T1.Essential = 'Non-Essential'",
        "difficulty": ""
    },
    {
        "question": "List the income and number of inhabitants of customers with an age greater than the 80% of average age of all customers?",
        "hint": "age greater than the 80% of average age refers to age > (AVG(age) * 0.8); income refers to INCOME_K; number of inhabitants refers to INHABITANTS_K;",
        "error_sql": "SELECT T3.INCOME_K, T3.INHABITANTS_K FROM Customers AS T1 INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.age > (SELECT AVG(age) * 0.8 FROM Customers)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using aggregate functions like AVG() in the HAVING clause, make sure to apply the aggregation to the correct table and column, and avoid using subqueries if possible. In this case, the mistake was using a subquery to calculate the average age, which was not correlated with the outer query. Instead, use the HAVING clause with the AVG() function applied to the correct column (T1.age) to filter the results correctly. Additionally, be aware of the scope of the variables and the tables being referenced in the query to avoid confusion and incorrect results.",
        "ground_truth_sql": "SELECT T2.INCOME_K, T2.INHABITANTS_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID GROUP BY T2.INCOME_K, T2.INHABITANTS_K HAVING T1.age > 0.8 * AVG(T1.age)",
        "difficulty": ""
    },
    {
        "question": "List all podcast with its itunes url for all title containing the word 'Dream'.",
        "hint": "containing the word 'Dream' refers to title LIKE '%Dream%'",
        "error_sql": "SELECT T2.itunes_url, T2.title FROM podcasts AS T2 INNER JOIN reviews AS T1 ON T2.podcast_id = T1.podcast_id WHERE T1.title LIKE '%Dream%'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, carefully consider whether a join is actually necessary to answer the question. In this case, the question only requires information from the 'podcasts' table, so a join with the 'reviews' table is unnecessary. Additionally, when using aggregate functions or grouping, ensure that all non-aggregated columns in the SELECT clause are included in the GROUP BY clause to avoid errors.",
        "ground_truth_sql": "SELECT itunes_url FROM podcasts WHERE title LIKE '%Dream%' GROUP BY itunes_url",
        "difficulty": ""
    },
    {
        "question": "For all the deceased players who are good at both left and right hand, list the player's name and the age when he died.",
        "hint": "age when he died refers to SUBTRACT(deathYear,birthYear); deceased refers to deathYear IS NOT NULL; good at both left and right hand refers to shootCatch IS NULL",
        "error_sql": "SELECT nameGiven, deathYear - birthYear FROM Master WHERE shootCatch IS NULL AND deathYear IS NOT NULL",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen generating SQL queries, it's essential to carefully consider the columns being selected. In this case, the error SQL query and the SQL after reflection only selected the player's first name and age at death, but the ground truth SQL query requires both the first name and last name. To avoid making the same mistake in the future, always double-check the columns being selected to ensure they match the requirements of the query.",
        "ground_truth_sql": "SELECT firstName, lastName, deathYear - birthYear FROM Master WHERE shootCatch IS NULL AND deathYear IS NOT NULL",
        "difficulty": ""
    },
    {
        "question": "Please list the businesses along with their numbers that have their accounts located in Duvall.",
        "hint": "Business along with their numbers refers to the BusinessEntityID; located in Duvall refers to City = 'Duvall'",
        "error_sql": "SELECT T2.Description FROM BusinessEntity AS T1 INNER JOIN BusinessEntityAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.City = 'Duvall'",
        "compiler_hint": "near \"assistant\": syntax error",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct columns are being referenced and that the join conditions are accurate. In this case, the error occurred because the column 'Description' was not found in table 'T2', which is actually 'BusinessEntityAddress'. To avoid this mistake, double-check the table and column names in the SQL query to ensure they match the actual database schema.",
        "ground_truth_sql": "SELECT T2.BusinessEntityID FROM Address AS T1 INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE T1.City = 'Duvall'",
        "difficulty": ""
    },
    {
        "question": "How many employed disabled students have zero absences?",
        "hint": "employed students refers to disabled.name who are NOT in unemployed.name; zero absences refers to month = 0;",
        "error_sql": "SELECT COUNT(T1.name) FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name LEFT JOIN unemployed AS T3 ON T1.name = T3.name WHERE T2.month = 0 AND T3.name IS NULL",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join type and conditions accurately reflect the desired relationship between the tables. In this case, the mistake was using a LEFT JOIN with unemployed, which would include disabled students who are unemployed, whereas the intention was to exclude them. Additionally, the join with unemployed should be an INNER JOIN to ensure that only employed disabled students are considered. Furthermore, the order of joins matters, and in this case, joining longest_absense_from_school with disabled first ensures that only disabled students with zero absences are considered.",
        "ground_truth_sql": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN unemployed AS T3 ON T3.name = T2.name WHERE T1.month = 0",
        "difficulty": ""
    },
    {
        "question": "List the brand names of bottled root beer whose first brewing year is no later than 1930.",
        "hint": "bottled root beer refers to ContainerType = 'Bottle'; first brewing year is no later than 1930 refers to FirstBrewedYear < 1930;",
        "error_sql": "SELECT T2.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T1.ContainerType = 'Bottle' AND T2.FirstBrewedYear < 1930",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen comparing dates in SQL, it's essential to consider the entire date, not just the year. In this case, the error SQL query and the SQL after reflection only compared the year, which could lead to incorrect results if there are root beers brewed in 1930. To avoid this, compare the entire date, and if only the year is provided, append a month and day to ensure accurate results. Additionally, consider adding an ORDER BY and LIMIT clause to ensure that only the earliest brewed root beer is returned, as in the Ground Truth SQL.",
        "ground_truth_sql": "SELECT T2.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T2.FirstBrewedYear < '1930-01-01' AND T1.ContainerType = 'Bottle' ORDER BY T2.FirstBrewedYear LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the total number of awards won by The simpson 20s: Season 20?",
        "hint": "total number of awards refers to COUNT(award); awards won refers to result = 'Winner';",
        "error_sql": "SELECT COUNT(T1.award_id) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.result = 'Winner' AND T2.title = 'The simpson 20s: Season 20'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, it's essential to carefully consider the relationships between tables and the conditions specified in the query. In this case, the error was due to the fact that the query was filtering awards based on the title of an episode, but the Award table does not have a direct relationship with the Episode table based on the title. Instead, it's based on the episode_id. However, the Ground Truth SQL query suggests that the question is actually asking for the total number of awards won, regardless of the episode title. Therefore, the correct approach is to simply count the awards with the result 'Winner', without joining with the Episode table or filtering by episode title.",
        "ground_truth_sql": "SELECT COUNT(award_id) FROM Award WHERE result = 'Winner';",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of the the users who would bring up a mental health issue with a potential employer in an interview?",
        "hint": "Percentage = DIVIDE(SUM(AnswerText = 'Yes' Or AnswerText = 'Maybe'), COUNT(QuestionID = 12))* 100",
        "error_sql": "SELECT CAST(SUM(IIF(T1.AnswerText = 'Yes' OR T1.AnswerText = 'Maybe', 1, 0)) AS REAL) / COUNT(T1.QuestionID) * 100 FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 12",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that the numerator and denominator are correctly aligned with the question being asked. In this case, the numerator should count the number of 'Yes' or 'Maybe' answers, while the denominator should count the total number of users who answered the question, not the total number of answers. Additionally, use a CASE statement or equivalent to handle multiple conditions in the numerator, and consider using the LIKE operator to account for variations in answer text.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE  WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 12",
        "difficulty": ""
    },
    {
        "question": "List out the number of students who have the longest duration of absense from school and enlisted in the peace corps.",
        "hint": "longest duration of absence refers to MAX(month); peace corps refers to organ = 'peace_corps';",
        "error_sql": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T2.organ = 'peace_corps' AND T1.month = ( SELECT MAX(month) FROM longest_absense_from_school )",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen dealing with aggregate functions like MAX, MIN, or COUNT, consider whether you need to filter the data before applying the aggregation or if you need to apply the aggregation first and then filter the results. In this case, the mistake was trying to filter the data based on the MAX(month) value, which would only return one row, instead of ordering the data by month in descending order and then limiting the result to the top row. This is because the MAX function returns a single value, whereas the ORDER BY and LIMIT approach returns the entire row(s) that correspond to the maximum value.",
        "ground_truth_sql": "SELECT COUNT(T1.NAME) FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T2.organ = 'peace_corps' ORDER BY T1.month DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What are the top 10 oldest movies and what are the average rating score for each movie? Indicate the name of the director and when the movies were released.",
        "hint": "the average rating score refers to AVG(T2.rating_score); oldest movies refers to MIN(rating_timestamp_utc)",
        "error_sql": "SELECT T1.movie_title, T1.director_name, T1.movie_release_year, AVG(T2.rating_score) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id GROUP BY T1.movie_title, T1.director_name, T1.movie_release_year ORDER BY T1.movie_release_year LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and aggregating data, ensure that the ORDER BY clause is based on the correct column that represents the desired sorting criteria. In this case, the goal was to find the top 10 oldest movies based on their release year, but the correct sorting should be based on the rating timestamp, which indicates when the movie was rated. Additionally, the AVG function should be applied to the rating score, and the result should be sorted in ascending order (ASC) to get the oldest movies. The corrected query should also include the movie_id in the SELECT clause to ensure that the correct movies are being referenced.",
        "ground_truth_sql": "SELECT T2.movie_id, AVG(T1.rating_score), T2.director_name, T2.movie_release_year FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id ORDER BY T1.rating_timestamp_utc ASC LIMIT 10",
        "difficulty": ""
    },
    {
        "question": "List at least 10 users ID that has 4 as an average ratings of all reviews sent.",
        "hint": "4 as an average rating refers to user_average_stars = 4",
        "error_sql": "SELECT user_id FROM Users WHERE user_average_stars = 4",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen the task is to list at least a certain number of items (in this case, 10 users ID), but the actual query should return the count of items that meet the condition, it's essential to understand the difference between listing items and counting items. The correct approach is to use the COUNT() function to get the total number of items that meet the condition, rather than using LIMIT to restrict the number of items returned. This ensures that the query returns the correct information, which is the total count of users with an average rating of 4, rather than just listing 10 users who meet the condition.",
        "ground_truth_sql": "SELECT COUNT(user_id) FROM Users WHERE user_average_stars = 4 LIMIT 10",
        "difficulty": ""
    },
    {
        "question": "What are the highest salary earn by the the employee and what is his/her position in the company?",
        "hint": "highest salary refers to max(salary); position refers to Title",
        "error_sql": "SELECT MAX(T1.Price), T2.Title FROM Products AS T1 INNER JOIN Employees AS T2 ON T1.EmployeeID = T2.EmployeeID",
        "compiler_hint": "no such column: salary",
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that the columns and tables referenced in the query actually exist in the database schema. In this case, the `salary` and `Title` columns do not exist in the `Employees` table, and the `EmployeeID` column does not exist in the `Products` table. Always verify the schema before generating a query to avoid such errors. Additionally, be cautious when joining tables to ensure that the join conditions are correct and that the columns being referenced are present in the joined tables.",
        "ground_truth_sql": "SELECT Salary, Title FROM Employees WHERE Salary = ( SELECT MAX(Salary) FROM Employees )",
        "difficulty": ""
    },
    {
        "question": "What is the highest total points a team got in a year?",
        "hint": "the highest total points = MAX(Pts)",
        "error_sql": "SELECT MAX(Pts) FROM Teams",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column in a database, consider whether the column is unique for each row or if it can be aggregated across multiple rows. In this case, the Pts column represents the total points for a team in a specific year, but there can be multiple teams in the same year. Therefore, simply using MAX(Pts) would not give the correct result. Instead, we need to group the teams by year and then find the maximum total points. However, the question asks for the highest total points a team got in a year, not the highest total points across all teams in a year. Therefore, we need to group the teams by year and team ID, and then find the maximum total points.",
        "ground_truth_sql": "SELECT SUM(Pts), year FROM Teams GROUP BY year, tmID ORDER BY SUM(Pts) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the bike trips started on the days with a fog in 2013, how many of those trips started from the station \"2nd at Townsend\"?",
        "hint": "started on the days with a fog refers to start_date where events = 'fog'; in 2013 refers to date LIKE '%2013'; started from station refers to start_station_name; start_station_name = '2nd at Townsend';",
        "error_sql": "SELECT COUNT(T1.id) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.events = 'fog' AND SUBSTR(CAST(T2.date AS TEXT), -4) = '2013' AND T1.start_station_name = '2nd at Townsend'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and consider all relevant constraints. In this case, the `zip_code` in the `trip` table should match the `zip_code` in the `weather` table, but the `zip_code` in the `weather` table should also be a specific value (94107) to accurately filter the results. Additionally, when filtering dates, use the `LIKE` operator with the correct pattern to match the desired year, and be mindful of the case sensitivity of the event type ('Fog' instead of 'fog').",
        "ground_truth_sql": "SELECT COUNT(T1.start_station_name) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.date LIKE '%2013%' AND T2.events = 'Fog' AND T1.start_station_name = '2nd at Townsend' AND T2.zip_code = 94107",
        "difficulty": ""
    },
    {
        "question": "On 11/3/2013, which stations are often empty? Indicate the names of the stations.",
        "hint": "time = '11/3/2013'; which stations are empty refers to bikes_available = '0';",
        "error_sql": "SELECT DISTINCT T1.start_station_name FROM trip AS T1 INNER JOIN status AS T2 ON T1.start_station_id = T2.station_id WHERE T2.time = '11/3/2013' AND T2.bikes_available = 0",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the correct columns are being referenced. In this case, the initial error was due to joining the 'trip' table instead of the 'station' table with the 'status' table. Additionally, the date format in the 'status' table was assumed to be 'MM/DD/YYYY' but it was actually 'YYYY/MM/DD', so the correct LIKE operator should be used to match the date format. Always verify the table schema and data formats before writing SQL queries.",
        "ground_truth_sql": "SELECT DISTINCT T1.name FROM station AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE T2.bikes_available = 0 AND T2.time LIKE '2013/11/03%'",
        "difficulty": ""
    },
    {
        "question": "Calculate the total trading quantity of Abraham sold to Aaron Alexander.",
        "hint": "total trading quantity = SUM(Quantity WHERE Employees.FirstName = 'Abraham' AND Customers.FirstName = 'Aaron' AND Customers.LastName = 'Alexander');",
        "error_sql": "SELECT SUM(T4.Quantity) FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID INNER JOIN Sales AS T4 ON T3.CustomerID = T4.CustomerID WHERE T1.FirstName = 'Abraham' AND T3.FirstName = 'Aaron' AND T3.LastName = 'Alexander'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and that the same table is not joined multiple times with different aliases, which can lead to incorrect results. Also, when filtering data, use the correct table alias to avoid ambiguity. In this case, the error was caused by joining the Sales table twice with different aliases, and not using the correct table alias in the WHERE clause. To avoid this mistake, carefully review the join conditions and table aliases, and use the correct table alias when filtering data. Additionally, consider using the actual values from the database instead of relying on string matching for filtering, as shown in the Ground Truth SQL.",
        "ground_truth_sql": "SELECT SUM(T2.Quantity) FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE T2.SalesPersonID = 1 AND T1.FirstName = 'Aaron' AND T1.LastName = 'Alexander' AND T3.FirstName = 'Abraham'",
        "difficulty": ""
    },
    {
        "question": "List out student names that enrolled in two schools and two organizations?",
        "hint": "enrolled in two schools refers to COUNT(school) = 2; two organizations refers to COUNT(organ) = 2;",
        "error_sql": "SELECT name FROM (SELECT name, school, organ FROM Enrollments) GROUP BY name HAVING COUNT(DISTINCT school) = 2 AND COUNT(DISTINCT organ) = 2",
        "compiler_hint": "no such table: Student",
        "reflective_cot": "### Tip:\nWhen dealing with complex queries involving multiple tables, ensure that you accurately identify the relationships between tables and use the correct join operations. In this case, the error was due to incorrect use of UNION ALL and GROUP BY, which did not accurately capture the relationships between Enrolled and Enlist tables. Instead, use INNER JOIN to combine the tables based on a common column (name) and then apply the GROUP BY and HAVING clauses to filter the results. Additionally, use COUNT(DISTINCT) to avoid counting duplicate values.",
        "ground_truth_sql": "SELECT T.name FROM ( SELECT T1.name, COUNT(T1.organ) AS num FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name ) T WHERE T.num = 2",
        "difficulty": ""
    },
    {
        "question": "Among all the users with the average ratings of at least 4 and above of all reviews, calculate the percent that have no fans or followers.",
        "hint": "average ratings of at least 4 refers to user_average_stars > = 4; no fans or followers refers to user_fans = 'None'; percentage = divide(count(user_id where user_average_stars > = 4 and user_fans = 'None'), sum(user_id where user_average_stars > = 4))*100%",
        "error_sql": "SELECT CAST(SUM(IIF(user_average_stars >= 4 AND user_fans = 'None', 1, 0)) AS REAL) * 100 / COUNT(user_id) FROM Review WHERE user_average_stars >= 4",
        "compiler_hint": "no such table: Users",
        "reflective_cot": "### Tip: \nWhen using conditional aggregation, it's essential to use the correct syntax. In this case, the initial query used `IIF` which is not a standard SQL function, whereas the correct syntax is `CASE WHEN` as shown in the Ground Truth SQL. Additionally, the condition `user_average_stars >= 4` should be applied in the `WHERE` clause, not within the `CASE` statement. To avoid similar mistakes, always verify the SQL dialect being used and ensure that the syntax is correct for that dialect.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN user_fans = 'None' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(user_id) FROM Users WHERE user_average_stars >= 4",
        "difficulty": ""
    },
    {
        "question": "How many distinct movies in English stars a male actor who acts the best?",
        "hint": "Male actors mean that a_gender = 'M'; isEnglish = 'T' means movies in English",
        "error_sql": "SELECT COUNT(DISTINCT T1.movie_id) FROM actor AS T1 INNER JOIN movie AS T2 ON T1.movie_id = T2.movie_id WHERE T1.a_gender = 'M' AND T2.isEnglish = 'T'",
        "compiler_hint": "no such table: acting",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being counted is from the correct table. In this case, the question asks for the number of distinct movies, but the correct column to count is actually the actorid, not the movieid, because the question asks for the number of distinct movies that star a male actor who acts the best, implying that the actor is the main subject of the query.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T3.isEnglish = 'T' AND T1.a_gender = 'M' AND T1.a_quality = 5",
        "difficulty": ""
    },
    {
        "question": "How many times did Keven Kuhn receive DTaP immunization?",
        "hint": "DTaP immunization refers to immunizations where DESCRIPTION = 'DTaP';",
        "error_sql": "SELECT COUNT DESCRIPTION FROM immunization WHERE DESCRIPTION = 'DTaP' AND PAT_NAME = 'Keven Kuhn'",
        "compiler_hint": "no such table: immunizations",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being counted is the one that is most relevant to the query's purpose. In this case, counting 'CODE' is more accurate than counting 'DESCRIPTION' because 'CODE' is likely to be unique for each immunization, whereas 'DESCRIPTION' might be the same for multiple immunizations. Additionally, verify the column names and table names to ensure they match the actual schema, and use the correct table alias in the COUNT function.",
        "ground_truth_sql": "SELECT COUNT(T2.CODE) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Keven' AND T1.last = 'Kuhn' AND T2.DESCRIPTION = 'DTaP'",
        "difficulty": ""
    },
    {
        "question": "What is the total amount of tax charged for the order placed by customer 88931 on 7/13/994?",
        "hint": "total amount of tax refers to sum(multiply(multiply(l_extendedprice, subtract(1, l_discount)), add(1, l_tax))); customer 88931 refers to o_custkey = 88931; on 7/13/1994 refers to o_orderdate = '1994-07-13'",
        "error_sql": "SELECT SUM(T1.l_extendedprice * (1 - T1.l_discount) * (1 + T1.l_tax)) FROM orders AS T2 INNER JOIN lineitem AS T1 ON T1.l_orderkey = T2.o_orderkey WHERE T2.o_custkey = 88931 AND T2.o_orderdate = '1994-07-13'",
        "compiler_hint": "no such table: lineitem",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names used in the SELECT, WHERE, and JOIN clauses match the actual column names in the tables. In this case, the error occurred because the column 'l_extendedprice', 'l_discount', and 'l_tax' are from the 'lineitem' table, but in the Error SQL Query, they were referenced from the 'lineitem' table aliased as 'T1', which is incorrect. The correct alias for 'lineitem' is 'T2'. To avoid this mistake, double-check the table aliases and column names to ensure they match the actual table and column names.",
        "ground_truth_sql": "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) * (1 + T2.l_tax)) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_custkey = 88931 AND T1.o_orderdate = '1994-07-13'",
        "difficulty": ""
    },
    {
        "question": "Provide the social security number of the patient with the highest systolic blood pressure.",
        "hint": "social security number refers to ssn; highest systolic blood pressure refers to MAX(observations.VALUE WHERE observations.DESCRIPTION = 'Systolic Blood Pressure');",
        "error_sql": "SELECT T1.ssn FROM patient AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Systolic Blood Pressure' ORDER BY T2.VALUE DESC LIMIT 1",
        "compiler_hint": "no such table: patients",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the error occurred because the column name in the patients table is actually 'patient', not 'ssn' or any other name. Also, the alias 'T1' and 'T2' should be assigned based on the order of the tables in the FROM and JOIN clauses. In the error SQL query, 'T1' was assigned to 'patients' but in the correct query, 'T1' should be assigned to 'observations' because it is the first table in the FROM clause.",
        "ground_truth_sql": "SELECT T2.ssn FROM observations AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Systolic Blood Pressure' ORDER BY T1.VALUE DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many cities have businesses with active life category? Find the percentage of the city where the review count that is low in total review count.",
        "hint": "category refers to category_name; percentage = MULTIPLY(DIVIDE(SUM(category_name = 'Active Life'), SUM(review_count = 'LOW')), 1.0);",
        "error_sql": "SELECT CAST(SUM(CASE WHEN category_name = 'Active Life' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN review_count = 'Low' THEN 1 ELSE 0 END) FROM Business AS T1 INNER JOIN Review AS T2 ON T1.business_id = T2.business_id",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that the subqueries and the main query are correctly aligned in terms of the columns being referenced. In the provided Error SQL Query and SQL after Reflection, the subqueries were not correctly aligned with the main query, leading to incorrect results. Additionally, verify that the conditions in the CASE statements are correctly specified, including the use of LIKE instead of = for string comparisons. Furthermore, ensure that the subqueries are correctly nested and that the columns being referenced are correctly qualified with the table aliases.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.category_name LIKE 'Active Life' THEN 1 ELSE 0 END) AS \"num\" , CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) * 100 / ( SELECT COUNT(T3.review_count) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE T3.review_count LIKE 'Low' ) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id",
        "difficulty": ""
    },
    {
        "question": "Which two countries share the second highest mountain? Give the country code.",
        "hint": "",
        "error_sql": "SELECT T2.country_code FROM country_mountains AS T1 INNER JOIN countries AS T2 ON T1.country_code = T2.country_code INNER JOIN mountains AS T3 ON T1.mountain_id = T3.mountain_id GROUP BY T2.country_code ORDER BY T3.height DESC LIMIT 2 OFFSET 1",
        "compiler_hint": "no such table: mountains",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and the tables being joined actually exist in the database. In this case, the error was due to a non-existent table 'country_mountains' and incorrect join conditions. To avoid this mistake, carefully review the database schema and ensure that the tables and columns being referenced actually exist and are correctly named. Additionally, verify that the join conditions are logical and correctly relate the tables being joined.",
        "ground_truth_sql": "SELECT T1.Code FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE T2.Mountain = ( SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1, 1 )",
        "difficulty": ""
    },
    {
        "question": "Among the classic movies, how many movies have a rental rate of less than 1?",
        "hint": "classic movie refers to name = 'Classics'; rental rate of less than 1 refers to rental_rate < 1; movie refers to film_id",
        "error_sql": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN category AS T2 ON T1.film_id = T2.film_id INNER JOIN film_category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Classics' AND T1.rental_rate < 1",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and the table aliases are correct. In this case, the error occurred because the join order was incorrect, and the table aliases were not properly assigned. To avoid this mistake, carefully examine the table relationships and the query logic to ensure that the joins are performed in the correct order and that the table aliases are correctly assigned. Additionally, verify that the column names and table names match the actual schema to avoid errors like \"no such table: film\".",
        "ground_truth_sql": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.rental_rate < 1 AND T2.name = 'Classics'",
        "difficulty": ""
    },
    {
        "question": "Which payment method is most comonly used by the schools in the state of Georgia for the payment of donations?",
        "hint": "Georgia refer to school_state = 'GA'\n",
        "error_sql": "SELECT T1.payment_method FROM schools AS T1 INNER JOIN donations AS T2 ON T1.school_id = T2.school_id WHERE T1.school_state = 'GA' GROUP BY T1.payment_method ORDER BY COUNT(T1.payment_method) DESC LIMIT 1",
        "compiler_hint": "no such table: donations",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column used in the GROUP BY clause is from the correct table and is not ambiguous. In this case, the GROUP BY clause should be grouping by the payment_method, not the school_state. Also, verify that the column used in the SELECT statement is from the correct table. In this case, the payment_method should be selected from the donations table (T1), not the projects table (T2).",
        "ground_truth_sql": "SELECT T1.payment_method FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_state = 'GA' GROUP BY T2.school_state ORDER BY COUNT(T1.payment_method) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What ingredients does the longest cooking time recipe have?",
        "hint": "the longest cooking time refers to MAX(cook_min)",
        "error_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T2.ingredient_id = T3.ingredient_id WHERE T1.cook_min = ( SELECT MAX(cook_min) FROM Recipe )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column and then joining it with other tables to get related data, consider using ORDER BY and LIMIT instead of using a subquery to find the maximum or minimum value. This is because the subquery will return the maximum or minimum value, but it will not guarantee that the joined data is from the same row as the maximum or minimum value. In this case, the subquery returns the maximum cooking time, but the joined data may not be from the recipe with the maximum cooking time. Using ORDER BY and LIMIT ensures that the joined data is from the same row as the maximum or minimum value.",
        "ground_truth_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id ORDER BY T1.cook_min DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which supplier can provide the most number of \"hot spring dodger dim light\"? Please give the supplier's phone number.",
        "hint": "the most number refers to max(ps_availqty); \"hot spring dodger dim light\" refers to p_name = 'hot spring dodger dim light'; phone number refers to s_phone",
        "error_sql": "SELECT T1.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T2.ps_availqty DESC LIMIT 1",
        "compiler_hint": "no such table: supplier",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order is correct and logical. The order should typically start with the table that is being filtered (in this case, the 'part' table with the specific 'p_name'), followed by the tables that are being joined to it. This helps to avoid incorrect join orders that can lead to errors. Additionally, double-check the table aliases and column names to ensure they are correct and consistent throughout the query.",
        "ground_truth_sql": "SELECT T3.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T2.ps_availqty DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the name of the organization which most of the students are enlisted in?",
        "hint": "name of the organization refers to organ; organization which most of the students are enlisted in refers to MAX(COUNT(organ));",
        "error_sql": "SELECT organ FROM Enlistments GROUP BY organ ORDER BY COUNT(organ) DESC LIMIT 1",
        "compiler_hint": "no such table: enlist",
        "reflective_cot": "### Tip:\nWhen using aggregate functions like COUNT() in the ORDER BY clause, it's essential to use a subquery or a Common Table Expression (CTE) to calculate the count first, and then order the results. This is because the ORDER BY clause is executed before the aggregate function is calculated, resulting in incorrect ordering. By using a subquery or CTE, you ensure that the count is calculated first, and then the results are ordered correctly.",
        "ground_truth_sql": "SELECT organ FROM ( SELECT organ, COUNT(organ) AS num FROM enlist GROUP BY organ ) T ORDER BY T.num DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the average net profit of bar tools which has ordered quantity exceed 5.",
        "hint": "net profit can be computed as SUBTRACT(Unit Price, Unit Cost); AVG(net profit) where Product Name = 'Bar Tools' and Order Quantity > 5;",
        "error_sql": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.`Unit Price`, 2), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T1.`Unit Cost`, 2), ',', '') AS REAL)) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T1._ProductID = T2.ProductID WHERE T2.`Product Name` = 'Bar Tools' AND T1.`Order Quantity` > 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average of a value, make sure to use the SUM function to add up all the values and then divide by the COUNT of rows, rather than using the AVG function directly on the calculated values. This is because AVG function may not work correctly with calculated values, especially when the values are not numeric. Additionally, be careful when using string manipulation functions like REPLACE, SUBSTR, and CAST, as they can be error-prone and may not work as expected. Always test your queries thoroughly to ensure they produce the correct results.",
        "ground_truth_sql": "SELECT SUM(REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')) / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T2.`Product Name` = 'Bar Tools' AND T1.`Order Quantity` > 5",
        "difficulty": ""
    },
    {
        "question": "How much taller is David Bornhammar than Pauli Levokari in centimeters?",
        "hint": "how much taller = SUBTRACT(SUM(height_in_cm WHERE PlayerName = 'David Bornhammar'), SUM(height_in_cm WHERE PlayerName = 'Pauli Levokari')); height in centimeters refers to height_in_cm;",
        "error_sql": "SELECT (SUM(CASE WHEN PlayerName = 'David Bornhammar' THEN height_in_cm ELSE 0 END) - SUM(CASE WHEN PlayerName = 'Pauli Levokari' THEN height_in_cm ELSE 0 END)) FROM player",
        "compiler_hint": "no such table: players",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you accurately identify the tables involved and their relationships. In this case, the error was due to not joining the correct tables (`PlayerInfo` and `height_info`) and not using the correct column names. To avoid this mistake, carefully review the schema and column descriptions before generating the query. Additionally, consider breaking down complex queries into simpler sub-queries, as seen in the Ground Truth SQL, to improve readability and accuracy.",
        "ground_truth_sql": "SELECT ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'David Bornhammar' ) - ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'Pauli Levokari' )",
        "difficulty": ""
    },
    {
        "question": "Among the menu pages on which the dish \"Paysanne Soup\" had appeared, how many of them had a stable price for the dish?",
        "hint": "Paysanne Soup is a name of dish; stable price refers to highest_price is null;",
        "error_sql": "SELECT COUNT(T2.menu_page_id) FROM dish AS T1 INNER JOIN dish_appearance AS T2 ON T1.dish_id = T2.dish_id INNER JOIN menu_page AS T3 ON T2.menu_page_id = T3.menu_page_id WHERE T1.name = 'Paysanne Soup' AND T2.highest_price IS NULL",
        "compiler_hint": "no such table: menu_page",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order and conditions are correct. In this case, the error occurred because the join order was incorrect, and the conditions were not properly aligned with the table schema. To avoid this mistake, carefully review the table schema and the join conditions to ensure that they are correct and logically consistent. Additionally, when using table aliases, ensure that they are consistently used throughout the query to avoid confusion. In this case, the correct join order is to start with the Dish table, then join with MenuItem, and the condition should be on the Dish table's name and the MenuItem's highest_price.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.name = 'Paysanne Soup' THEN 1 ELSE 0 END) FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.highest_price IS NULL",
        "difficulty": ""
    },
    {
        "question": "Calculate the average number of disabled female students enrolled in UCI.",
        "hint": "average = DIVIDE(SUM(disabled.name who are not in male.name WHERE school = 'uci'), COUNT(enrolled.name)); female students refers to disabled.name who are NOT in male.name; UCI refers to school = 'uci';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.name NOT IN (SELECT name FROM male) THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.name) FROM Enrollments AS T1 INNER JOIN Disabled AS T2 ON T1.name = T2.name WHERE T1.school = 'uci'",
        "compiler_hint": "no such table: enrolled",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join conditions are correct and consider all relevant tables that may affect the result. In this case, the `person` table was missing, which contains the gender information, and a `LEFT JOIN` with the `male` table was necessary to correctly identify female students. Additionally, the `IIF` function is more suitable for this scenario than `CASE WHEN` because it allows for more complex conditions.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.school = 'uci' AND T4.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN person AS T3 ON T1.name = T3.name LEFT JOIN male AS T4 ON T3.name = T4.name",
        "difficulty": ""
    },
    {
        "question": "List down the author ID of authors with a name of \"Peter\".",
        "hint": "\"Peter\" is the name of author",
        "error_sql": "SELECT Id FROM Author WHERE Name = 'Peter'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, it's essential to consider the relationships between tables and the specific table that contains the desired information. In this case, the `Author` table contains the author's name, but the `PaperAuthor` table contains the author's ID in relation to a specific paper. However, the `PaperAuthor` table also contains the author's name, which is not necessarily the same as the author's name in the `Author` table. To get the correct author ID, we should query the `Author` table directly, not the `PaperAuthor` table. The correct query should be `SELECT Id FROM Author WHERE Name = 'Peter'`. The mistake was made by querying the `PaperAuthor` table instead of the `Author` table. To avoid this mistake in the future, always carefully consider the relationships between tables and the specific table that contains the desired information.",
        "ground_truth_sql": "SELECT AuthorId FROM PaperAuthor WHERE Name = 'Peter'",
        "difficulty": ""
    },
    {
        "question": "State the name of menu with the longest full height.",
        "hint": "longest full height refers to MAX(full_height);",
        "error_sql": "SELECT T1.name FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id ORDER BY T2.full_height DESC LIMIT 1",
        "compiler_hint": "no such table: menu",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you accurately identify the relevant tables and their relationships. In this case, the error occurred because the initial query referenced a non-existent table 'menu' and the second query, although referencing the correct tables, did not accurately represent the relationship between 'MenuPage' and 'Menu'. To avoid this mistake, carefully review the schema to identify the correct tables and their relationships, and ensure that the query accurately reflects these relationships.",
        "ground_truth_sql": "SELECT T2.name FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id ORDER BY T1.full_height DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the patients with viral sinusitis condition, which patient's gender is most affected? Provide the number for each respectively.",
        "hint": "viral sinusitis condition refers to conditions.DESCRIPTION = 'Viral sinusitis (disorder)'; gender that is most affected refers to MAX(COUNT(gender WHERE conditions.DESCRIPTION = 'Viral sinusitis (disorder)'));",
        "error_sql": "SELECT T3.gender, COUNT(T3.gender) FROM observations AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN conditions AS T3 ON T2.patient = T3.PATIENT WHERE T1.DESCRIPTION = 'Viral sinusitis (disorder)' GROUP BY T3.gender",
        "compiler_hint": "no such table: conditions",
        "reflective_cot": "### Tip: \nWhen writing SQL queries, especially when dealing with aggregate functions and conditional counting, consider the exact requirements of the query. In this case, the goal was to count the number of patients by gender, but the initial queries did not accurately achieve this. The first query was incorrect due to a table aliasing issue, and the second query, although corrected the aliasing, still did not provide the desired output format. The ground truth SQL query uses conditional counting with SUM and CASE statements to accurately count the number of patients by gender. To avoid similar mistakes, take the time to carefully review the query requirements and consider alternative approaches, such as using conditional counting or pivoting, to achieve the desired output format.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END), SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "Which flight carrier operator flies from Atlantic City to Fort Lauderdale?",
        "hint": "flight carrier operator refers to OP_CARRIER_AIRLINE_ID; from Atlantic City refers to ORIGIN = 'ACY'; to Fort Lauderdale refers to DEST = 'FLL';",
        "error_sql": "SELECT OP_CARRIER_AIRLINE_ID FROM ontime WHERE ORIGIN = 'ACY' AND DEST = 'FLL'",
        "compiler_hint": "no such table: flights",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns used in the WHERE clause are from the correct table. Additionally, consider the need for aggregation (e.g., GROUP BY) when retrieving data from multiple tables, especially if the query is expected to return a single value or a distinct set of values. In this case, the initial query was incorrect because it did not join the Airlines table with the Air Carriers table, and the second query was incorrect because it did not include the GROUP BY clause to ensure that only distinct carrier descriptions were returned.",
        "ground_truth_sql": "SELECT T2.Description FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T1.ORIGIN = 'ACY' AND T1.DEST = 'FLL' GROUP BY T2.Description",
        "difficulty": ""
    },
    {
        "question": "What is the first name of the driver who transported shipment id 1028?",
        "hint": "shipment id 1028 refers to ship_id = 1028",
        "error_sql": "SELECT T1.first_name FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id WHERE T2.ship_id = 1028",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and selecting columns, ensure that the table alias used in the SELECT statement matches the table alias used in the JOIN clause. In this case, the error occurred because the SELECT statement used T1 for the driver table, but the JOIN clause used T2 for the driver table. To avoid this mistake, double-check that the table aliases are consistent throughout the query. Additionally, when selecting columns, consider selecting all relevant columns (e.g., first_name and last_name) to provide more complete information.",
        "ground_truth_sql": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = 1028",
        "difficulty": ""
    },
    {
        "question": "How many awards had been held in 2009?",
        "hint": "had been held in 2009 refers to year = 2009",
        "error_sql": "SELECT COUNT(*) FROM award WHERE year = 2009",
        "compiler_hint": "no such table: awards",
        "reflective_cot": "### Tip: \nAlways verify the exact table and column names from the schema before generating SQL queries, and ensure that the data type of the column matches the operation being performed. In this case, the correct table name is 'Award' (with a capital 'A'), and the 'year' column seems to be a string, so using SUBSTR to extract the year is correct.",
        "ground_truth_sql": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009';",
        "difficulty": ""
    },
    {
        "question": "How many trains are running west?",
        "hint": "west is a direction",
        "error_sql": "SELECT COUNT(*) FROM train_direction AS T1 INNER JOIN train AS T2 ON T1.train_id = T2.train_id WHERE T1.direction = 'west'",
        "compiler_hint": "no such table: train",
        "reflective_cot": "### Tip: \nAlways verify the table and column names in the database schema before generating SQL queries. In this case, the correct table name is 'trains' (plural) instead of 'train', and the correct column name is 'direction' which exists in the 'trains' table.",
        "ground_truth_sql": "SELECT COUNT(id) FROM trains WHERE direction = 'west'",
        "difficulty": ""
    },
    {
        "question": "What is the release title of the single that was released by Ron Hunt in 1979 that was downloaded 239 times?",
        "hint": "release title refers to groupName; Ron Hunt is an artist; groupYear = 1979; releaseType = 'single'; downloaded 239 times refer to totalSnatched = 239;",
        "error_sql": "SELECT T1.groupName FROM releases AS T1 INNER JOIN artists AS T2 ON T1.artistId = T2.artistId WHERE T2.artistName = 'Ron Hunt' AND T1.groupYear = 1979 AND T1.releaseType = 'single' AND T1.totalSnatched = 239",
        "compiler_hint": "no such table: groups",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the column names are accurate. In this case, the error was due to joining the 'torrents' table with 'artists' and 'releases' tables, but 'releases' is not a valid table. Also, the join condition should be based on the correct column names. Additionally, the 'LIKE' operator should be used instead of '=' when comparing strings with potential variations in case or punctuation. Furthermore, the 'artistName' should be compared with the exact string 'ron hunt & ronnie g & the sm crew' instead of just 'Ron Hunt'.",
        "ground_truth_sql": "SELECT groupName FROM torrents WHERE artist LIKE 'ron hunt & ronnie g & the sm crew' AND groupYear = 1979 AND releaseType LIKE 'single' AND totalSnatched = 239",
        "difficulty": ""
    },
    {
        "question": "How many trips which subscription types were Subscriber and ended in San Jose city?",
        "hint": "ended in refers to end_station_name;",
        "error_sql": "SELECT COUNT(T1.id) FROM trip AS T1 INNER JOIN station AS T2 ON T1.end_station_id = T2.id WHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is based on the correct columns. In this case, the error was due to joining on `end_station_id` instead of `end_station_name`. To avoid this mistake, carefully review the schema and the relationships between tables to ensure that the join conditions are correct. Additionally, consider using foreign keys to establish relationships between tables, which can help prevent such errors.",
        "ground_truth_sql": "SELECT COUNT(T1.subscription_type) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'",
        "difficulty": ""
    },
    {
        "question": "For each donation not from a teacher, state the donor account id and calculate the percentage of donation given for optional support.",
        "hint": "not from a teacher refers to is_teacher_acct = 'f'; donor account id refers to donor_acctid; percentage of donation = divide(donation_optional_support, donation_total)*100%",
        "error_sql": "SELECT T1.donor_acctid, CAST(T1.donation_optional_support AS REAL) * 100 / T1.donation_total FROM Donation AS T1 INNER JOIN Donor AS T2 ON T1.donor_acctid = T2.donor_acctid WHERE T2.is_teacher_acct = 'f'",
        "compiler_hint": "no such table: donations",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names and table names match exactly with those in the schema, and avoid unnecessary joins or casts. In this case, the error was due to an unnecessary join and cast, and the column 'is_teacher_acct' was assumed to be in the 'donations' table, when in fact it was not necessary to join with the 'donors' table. Also, the division operation in SQL will automatically return a decimal result if the database system supports it, so the explicit cast to REAL is not necessary.",
        "ground_truth_sql": "SELECT donor_acctid, donation_optional_support / donation_total FROM donations WHERE is_teacher_acct = 'f'",
        "difficulty": ""
    },
    {
        "question": "Is the oldest device user male or female?",
        "hint": "MAX(Age) AND gender = 'M' means that the oldest device user is male; MAX(Age) AND gender = 'F' means that the oldest device user is female;",
        "error_sql": "SELECT CASE WHEN MAX(CASE WHEN T2.gender = 'M' THEN T1.Age END) > MAX(CASE WHEN T2.gender = 'F' THEN T1.Age END) THEN 'M' ELSE 'F' END FROM device AS T1 INNER JOIN user AS T2 ON T1.user_id = T2.user_id",
        "compiler_hint": "no such table: device_user",
        "reflective_cot": "### Tip:\nWhen writing SQL queries, it's essential to carefully examine the schema and understand the relationships between tables. In this case, the error occurred because the query was trying to access a non-existent table 'device' and also because it was trying to find the maximum age from the 'device_user' table which does not have an 'Age' column. The correct approach is to join the relevant tables ('user' and 'device_user') and then find the maximum age from the 'user' table. Additionally, the 'gender_age' table seems to be a more straightforward table to query for this problem, making the join unnecessary. Always take a moment to review the schema and consider the simplest solution.",
        "ground_truth_sql": "SELECT gender FROM gender_age WHERE age = ( SELECT MAX(age) FROM gender_age )",
        "difficulty": ""
    },
    {
        "question": "Among the states with a public school count of 20 and below, list their race.",
        "hint": "public refers to control = 'Public'; school_count < 20;",
        "error_sql": "SELECT race FROM public_schools WHERE school_count <= 20",
        "compiler_hint": "no such table: schools",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names and column names match the actual schema of the database. In this case, the error occurred because the table name 'schools' was incorrect, and the correct tables 'state_sector_details' and 'state_sector_grads' needed to be joined to access the required columns. Always verify the schema before generating a query to avoid such mistakes.",
        "ground_truth_sql": "SELECT DISTINCT T2.race FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T1.schools_count <= 20 AND T1.control = 'Public'",
        "difficulty": ""
    },
    {
        "question": "What is the average rating of inactive businesses?",
        "hint": "rating refers to stars; inactive refers to active = 'False'; average rating of inactive businesses = DIVIDE(SUM(stars), COUNT(business_id));",
        "error_sql": "SELECT CAST(SUM(T1.stars) AS REAL) / COUNT(T1.business_id) FROM Business_Categories AS T2 INNER JOIN Business AS T1 ON T2.business_id = T1.business_id WHERE T1.active = 'False'",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nWhen working with boolean values in SQL, it's essential to use the correct syntax. In this case, the 'active' column is a boolean field, and the correct way to filter inactive businesses is by using 'active = FALSE' or 'active = 0' instead of 'active LIKE 'FALSE''. The 'LIKE' operator is used for pattern matching in strings, not for comparing boolean values.",
        "ground_truth_sql": "SELECT CAST(SUM(stars) AS REAL) / COUNT(business_id) AS \"average\" FROM Business WHERE active LIKE 'FALSE'",
        "difficulty": ""
    },
    {
        "question": "What are the names of the students who joined the Marines?",
        "hint": "Marines refers to organ = 'marines';",
        "error_sql": "SELECT name FROM Enlistments WHERE organ = 'marines'",
        "compiler_hint": "no such table: enlist",
        "reflective_cot": "### Tip: \nAlways verify the table name in the database schema before generating SQL queries. In this case, the correct table name is 'enlistments' (plural), not 'enlist'. The correct SQL query should be: SELECT name FROM enlistments WHERE organ = 'marines'.",
        "ground_truth_sql": "SELECT name FROM enlist WHERE organ = 'marines'",
        "difficulty": ""
    },
    {
        "question": "Has the product Chainring Bolts been on any of the sales?",
        "hint": "a product that's been on sale refers to SellStartDate NOT null and vice versa;",
        "error_sql": "SELECT CASE WHEN SellStartDate IS NOT NULL THEN 'Yes' ELSE 'No' END FROM Product WHERE Name = 'Chainring Bolts'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen checking if a product has been on sale, consider the relationships between the Product table and other tables that store sales information, such as SpecialOffer and SpecialOfferProduct. A product being on sale is not solely determined by its SellStartDate, but also by its association with special offers. Therefore, join the Product table with SpecialOffer and SpecialOfferProduct tables to accurately determine if a product has been on sale.",
        "ground_truth_sql": "SELECT CASE WHEN COUNT(T1.Description) >= 1 THEN 'Yes' ELSE 'No' END FROM SpecialOffer AS T1 INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE T3.Name = 'Chainring Bolts'",
        "difficulty": ""
    },
    {
        "question": "Compare the total number of orders between customer \"Apollo Ltd\" and \"Pacific Ltd\".",
        "hint": "\"Apollo Ltd\" and \"Pacific Ltd\" are both Customer Names; total number of orders refers to COUNT(OrderNumber)",
        "error_sql": "SELECT COUNT(CASE WHEN T1.`Customer Names` = 'Apollo Ltd' THEN T2.OrderNumber END) - COUNT(CASE WHEN T1.`Customer Names` = 'Pacific Ltd' THEN T2.OrderNumber END) FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T1.CustomerID = T2._CustomerID",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen comparing the counts of two groups, it's generally better to use separate COUNT() or SUM() functions for each group, rather than trying to subtract the counts directly. This is because the COUNT() function ignores NULL values, so if one of the conditions doesn't match any rows, the COUNT() will return 0, but the subtraction will still work correctly. However, in this case, using separate SUM() functions with CASE statements is a more elegant and flexible solution, as it allows for easy extension to more than two groups. Additionally, using SUM() instead of COUNT() allows for more flexibility in the future, if the query needs to be modified to count something other than rows.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.`Customer Names` = 'Apollo Ltd' THEN 1 ELSE 0 END), SUM(CASE WHEN T2.`Customer Names` = 'Pacific Ltd' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "difficulty": ""
    },
    {
        "question": "How many flights were there on 2018/8/1?",
        "hint": "on 2018/8/1 refers to FL_DATE = '2018/8/1';",
        "error_sql": "SELECT COUNT(*) FROM flights WHERE FL_DATE = '2018/8/1'",
        "compiler_hint": "no such table: ontime",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table name in the FROM clause matches the actual table name in the database schema. In this case, the correct table name is 'ontime', not 'flights' or 'Airlines'. Always verify the table name against the provided schema to avoid such errors.",
        "ground_truth_sql": "SELECT COUNT(*) FROM Airlines WHERE FL_DATE = '2018/8/1'",
        "difficulty": ""
    },
    {
        "question": "Among the students from the navy department, how many of them have payment due?",
        "hint": "from the navy department refers to organ = 'navy'; have payment due refers to bool = 'pos';",
        "error_sql": "SELECT COUNT(T1.name) FROM enlistments AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name WHERE T1.organ = 'navy' AND T2.bool = 'pos'",
        "compiler_hint": "no such table: enlist",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the table names and column names match exactly with the actual schema. In this case, the error was due to incorrect table names ('enrolled' instead of 'no_payment_due') and missing backticks around column names ('name' is a reserved keyword in SQL and should be enclosed in backticks). Always double-check the schema and use exact table and column names to avoid such errors.",
        "ground_truth_sql": "SELECT COUNT(T1.name) FROM enlist AS T1 INNER JOIN no_payment_due AS T2 ON T1.`name` = T2.`name` WHERE T1.organ = 'navy' AND T2.bool = 'pos'",
        "difficulty": ""
    },
    {
        "question": "Provide the number of events participated by the device users at coordinates of (80,37).",
        "hint": "coordinates of (80,37) refers to longitude = 80 and latitude = 37;",
        "error_sql": "SELECT COUNT(T1.event_id) FROM event_user AS T1 INNER JOIN device_user AS T2 ON T1.user_id = T2.user_id INNER JOIN user AS T3 ON T2.user_id = T3.user_id WHERE T3.longitude = 80 AND T3.latitude = 37",
        "compiler_hint": "no such table: event",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions are correct and the tables being joined actually exist in the database. In this case, the error was due to a non-existent table 'event' and incorrect join conditions. Additionally, analyze the schema carefully to avoid unnecessary joins. In this case, the 'events' table already contains the required columns 'longitude' and 'latitude', making the joins with 'user' and 'device_user' tables unnecessary.",
        "ground_truth_sql": "SELECT COUNT(event_id) FROM events WHERE longitude = 80 AND latitude = 37",
        "difficulty": ""
    },
    {
        "question": "In year 2000, who are the coaches with more than 50 games won. List the coachID, team name and number of game won at home game.",
        "hint": "more than 50 games won refers to won > 50",
        "error_sql": "SELECT T1.coachID, T2.team_name, T1.won \nFROM coach AS T1 \nINNER JOIN team AS T2 \nON T1.teamID = T2.teamID \nWHERE T1.year = 2000 AND T1.won > 50",
        "compiler_hint": "no such table: coach_season",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition includes all relevant columns to avoid incorrect results. In this case, the join condition should include both the team ID and the year to accurately match coaches with their respective teams and seasons. Additionally, verify that the column names and table names are correct, and that the correct table is being used to retrieve the desired information (e.g., won > 50 refers to the won column in the teams table, not the coaches table).",
        "ground_truth_sql": "SELECT T1.coachID, T2.name, T2.won FROM coaches AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = 2000 AND T2.won > 50",
        "difficulty": ""
    },
    {
        "question": "Name the neighborhood of the community area in crime with report number 23843?",
        "hint": "neighborhood refers to neighborhood_name; '23778' is the report_no",
        "error_sql": "SELECT T2.neighborhood_name FROM Community_Area AS T2 INNER JOIN Crime_Data AS T1 ON T1.community_area_number = T2.area_number WHERE T1.report_no = '23843'",
        "compiler_hint": "no such table: Crime",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names and column names match exactly with the actual schema. In this case, the error was due to incorrect table names ('Community_Area' instead of 'Community_Areas' and 'Neighborhood' instead of 'Neighborhoods') and incorrect column names ('community_area_number' instead of 'community_area_no'). To avoid this mistake, double-check the schema before writing the SQL query.",
        "ground_truth_sql": "SELECT T3.neighborhood_name FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T3 ON T2.community_area_no = T3.community_area_no WHERE T2.report_no = 23778",
        "difficulty": ""
    },
    {
        "question": "Identify the user who has been yelping since 2004. Is he or she an Yelp Elite member?",
        "hint": "has been yelping since 2004 refers to user_yelping_since_year = 2004",
        "error_sql": "SELECT elite FROM yelp_user WHERE yelping_since_year = 2004",
        "compiler_hint": "no such table: User",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the correct table names are used and that the join conditions are accurate. In this case, the error was due to the incorrect table name 'User' instead of 'Users', and the failure to join the 'Elite' table to correctly identify the Yelp Elite member. To avoid this mistake, carefully review the schema and ensure that all table names and join conditions are correct before executing the query. Additionally, consider the relationships between tables and the specific columns required to answer the question, in this case, the 'Elite' table is necessary to determine if the user is a Yelp Elite member.",
        "ground_truth_sql": "SELECT DISTINCT T2.user_id FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2004",
        "difficulty": ""
    },
    {
        "question": "How many inspection points with serious point level that have no fine?",
        "hint": "serious point level refers to point_level = 'Serious '; have no fine refers to fine = 0",
        "error_sql": "SELECT COUNT(point_id) FROM inspection_point WHERE point_level = 'Serious' AND fine = 0",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, consider the potential for duplicate rows and use DISTINCT when counting to avoid overcounting. Also, ensure that the join is necessary and that the correct columns are being compared. In this case, the join with the violation table was necessary to filter for inspection points with no fine, but the DISTINCT keyword was needed to avoid counting duplicate point_ids. Additionally, the correct spelling of 'Serious ' (with a space) was necessary to match the point_level.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.point_id) FROM inspection_point AS T1 INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE T1.point_level = 'Serious ' AND T2.fine = 0",
        "difficulty": ""
    },
    {
        "question": "Which organization does student 313 belong to?",
        "hint": "organization refers to organ",
        "error_sql": "SELECT organ FROM enlistments WHERE name = 313",
        "compiler_hint": "no such table: enlist",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column values are correctly formatted and matched with the actual data in the table. In this case, the error occurred because the name was not correctly formatted as 'student313' and later as 'studenT113'. To avoid this mistake, carefully review the table data and ensure that the values used in the WHERE clause are accurate and correctly formatted, including case sensitivity and exact string matching.",
        "ground_truth_sql": "SELECT organ FROM enlist WHERE name = 'studenT113'",
        "difficulty": ""
    },
    {
        "question": "Please list the titles of all the films in the category of \"Horror\".",
        "hint": "\"Horror\" is the name of category",
        "error_sql": "SELECT T3.title FROM category AS T1 INNER JOIN film_category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.name = 'Horror'",
        "compiler_hint": "no such table: film_category",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the order of the tables in the FROM and JOIN clauses matches the order of the tables in the ON clause. In this case, the correct order is to start with the 'film' table, then join 'film_category', and finally join 'category'. This is because we are selecting the title from the 'film' table, and we need to join the 'film_category' table first to get the category_id, and then join the 'category' table to filter by the 'Horror' category.",
        "ground_truth_sql": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Horror'",
        "difficulty": ""
    },
    {
        "question": "At what latitude is the Thomas Kemper brand beer consumed the most?",
        "hint": "Thomas Kemper refers to BrandName = 'Thomas Kemper';\u00a0 latitude the beer is consumed the most refers to MAX(COUNT(Latitude));",
        "error_sql": "SELECT Latitude FROM ( SELECT Latitude, COUNT(*) as count FROM beer_data WHERE BrandName = 'Thomas Kemper' GROUP BY Latitude ORDER BY count DESC LIMIT 1 )",
        "compiler_hint": "no such table: beer",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names and column names match the actual schema of the database. In this case, the error occurred because the table name 'beer' was used instead of the actual table names 'rootbeer', 'rootbeerbrand', and 'geolocation'. Additionally, the join conditions and column names should be carefully checked to ensure they match the schema. To avoid this mistake, it's essential to carefully review the database schema before generating SQL queries.",
        "ground_truth_sql": "SELECT T3.Latitude FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID INNER JOIN geolocation AS T3 ON T1.LocationID = T3.LocationID WHERE T2.BrandName = 'Thomas Kemper' GROUP BY T3.Latitude ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among students registered for the most difficult course, list the students' full names who got grade A.",
        "hint": "difficulty refers to diff; most difficult course refers to MAX(diff); student's full names = f_name, l_name;",
        "error_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.diff = (SELECT MAX(diff) FROM course) AND T2.grade = 'A'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with queries that involve finding the maximum or minimum value of a certain column, consider whether the query should return multiple rows or just one row. In this case, the original query was trying to find students who got grade A in the most difficult course, but it was using a subquery to find the maximum difficulty and then joining the tables to find the students. However, this approach would return all students who got grade A in any course with the maximum difficulty, not just the students in the single most difficult course. To avoid this mistake, consider using ORDER BY and LIMIT to ensure that only one row (or a limited number of rows) is returned, as in the Ground Truth SQL.",
        "ground_truth_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T2.grade = 'A' ORDER BY T3.diff DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "In the state with the highest number of schools, how many institutions have a percentage of no less than 90 of undergraduates who attend full-time? List all of the institutions' names.",
        "hint": "highest number of schools refers to MAX(schools_count); percentage of no less than 90 of undergraduates who attend full-time refers to ft_pct > 90; institutions' names refers to chronname;",
        "error_sql": "SELECT T2.chronname FROM state_sector_grads AS T2 INNER JOIN state_sector_details AS T1 ON T2.stateid = T1.stateid WHERE T1.schools_count = (SELECT MAX(schools_count) FROM state_sector_details) AND T2.ft_pct > 90",
        "compiler_hint": "no such table: state_sector_details",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the tables being joined actually exist in the database. Also, carefully consider the logic of the query, including the use of aggregate functions, filtering, and sorting, to ensure it aligns with the desired outcome. In this case, the error was due to a non-existent table and incorrect logic. To avoid this, take the time to thoroughly review the database schema and the query logic before executing it. Additionally, break down complex queries into smaller parts to test and validate each component before combining them.",
        "ground_truth_sql": "SELECT COUNT(t1.unitid), t1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON t1.state = t2.state WHERE t1.ft_pct > 90 ORDER BY t2.schools_count DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Provide the zip code, city, and congress representative's full names of the area which has highest population in 2020.",
        "hint": "representative's full names refer to first_name, last_name; area which has highest population in 2020 refers to MAX(population_2020);",
        "error_sql": "SELECT T1.zip, T1.city, T2.first_name, T2.last_name FROM zip_city_state AS T1 INNER JOIN congress_representative AS T2 ON T1.congress_district = T2.congress_district ORDER BY T1.population_2020 DESC LIMIT 1",
        "compiler_hint": "no such table: area",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being referenced and that the join conditions are accurate. In this case, the error was due to referencing the wrong table name ('area' instead of 'zip_data') and incorrect join conditions. To avoid this mistake, carefully review the schema and ensure that the table names and join conditions match the actual schema. Additionally, verify that the correct columns are being referenced, especially when there are similar column names across different tables (e.g., 'congress_district' vs 'district', 'congress_rep_id' vs 'cognress_rep_id').",
        "ground_truth_sql": "SELECT T1.zip_code, T1.city, T3.first_name, T3.last_name FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id GROUP BY T2.district ORDER BY T1.population_2020 DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the average value of the sales order?",
        "hint": "calculation = DIVIDE(SUM(UnitPrice * Quantity * SUBTRACT(1, Discount)), COUNT(OrderID))",
        "error_sql": "SELECT SUM(UnitPrice * Quantity * (1 - Discount)) / COUNT(OrderID) FROM SalesOrders",
        "compiler_hint": "no such table: Sales Orders",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table name in the FROM clause matches the actual table name in the database schema. In this case, the correct table name is `Order Details`, not `Sales Orders`. Always verify the table name to avoid this common mistake.",
        "ground_truth_sql": "SELECT SUM(UnitPrice * Quantity * (1 - Discount)) / COUNT(OrderID) FROM `Order Details`",
        "difficulty": ""
    },
    {
        "question": "Does student348 have a due payment?",
        "hint": "payment due refers to bool = 'pos' means the student has payment due , bool = 'neg' means the student does not have payment due;",
        "error_sql": "SELECT bool FROM no_payment_due WHERE name = 'student348'",
        "compiler_hint": "no such table: no_payment_due",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table name in the query matches the actual table name in the database schema. In this case, the correct table name is not provided, but the error message indicates that the table 'no_payment_due' does not exist. To avoid this mistake, carefully review the database schema before generating the SQL query, and verify that the table name is correct.",
        "ground_truth_sql": "SELECT bool FROM no_payment_due WHERE name = 'student348'",
        "difficulty": ""
    },
    {
        "question": "To which user group do most of the users who uses a vivo device belong?",
        "hint": "user group where most of the users belong refers to MAX(COUNT(group)); vivo device refers to phone_brand = 'vivo';",
        "error_sql": "SELECT T2.group FROM device_user AS T1 INNER JOIN user AS T2 ON T1.user_id = T2.user_id WHERE T1.phone_brand = 'vivo' GROUP BY T2.group ORDER BY COUNT(T2.group) DESC LIMIT 1",
        "compiler_hint": "near \"group\": syntax error",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema, and be aware of the potential for keyword conflicts (e.g., 'group' is a reserved keyword in SQL). Always verify the schema and use backticks or square brackets to escape reserved keywords if necessary. Additionally, double-check the table and column names to avoid typos and incorrect references.",
        "ground_truth_sql": "SELECT T.`group` FROM ( SELECT T2.`group`, COUNT(`group`) AS num FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'vivo' GROUP BY T2.`group` ) AS T ORDER BY T.num DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many games were published by Activision?",
        "hint": "Activision refers to publisher_name = 'Activision';",
        "error_sql": "SELECT COUNT(T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Activision'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen counting the number of games published by a specific publisher, it's essential to join the game table to ensure that each game is only counted once. The initial error SQL query only joined the game_publisher and publisher tables, which could lead to counting the same game multiple times if it has multiple publishers. The SQL after reflection corrected this by joining the game table and using COUNT(DISTINCT T3.id) to ensure each game is only counted once. However, the initial error SQL query and the SQL after reflection both missed the fact that the game_publisher table is a many-to-many relationship table and does not directly relate to the game table. The correct approach is to join the game_publisher table with the game table through the game_id, and then join the publisher table through the publisher_id. The Ground Truth SQL query correctly implements this approach.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T3.id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN game AS T3 ON T1.game_id = T3.id WHERE T2.publisher_name = 'Activision'",
        "difficulty": ""
    },
    {
        "question": "Please name three cities that belong to Algeria.",
        "hint": "Algeria is a country",
        "error_sql": "SELECT T1.city FROM geo_city AS T1 INNER JOIN geo_country AS T2 ON T1.Country = T2.Code WHERE T2.Name = 'Algeria'",
        "compiler_hint": "no such table: city",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the Error SQL Query used 'country_code' and 'code', while the correct columns were 'country_id'. Additionally, verify the table names and aliases to avoid confusion. Always double-check the schema and table relationships to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.city FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id WHERE T1.country = 'Algeria'",
        "difficulty": ""
    },
    {
        "question": "What is the Asian population in the city with the alias Leeds?",
        "hint": "",
        "error_sql": "SELECT T1.asian FROM cities AS T1 INNER JOIN alias AS T2 ON T1.city_id = T2.city_id WHERE T2.alias = 'Leeds'",
        "compiler_hint": "no such table: city",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names and column names match the actual schema. In this case, the error occurred because the table name was incorrect ('city' instead of 'zip_data') and the column name was incorrect ('city_id' instead of 'zip_code'). Additionally, the column 'asian' does not exist in the 'city' table, but 'asian_population' exists in the 'zip_data' table. Always double-check the schema before writing SQL queries.",
        "ground_truth_sql": "SELECT SUM(T2.asian_population) FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.alias = 'Leeds'",
        "difficulty": ""
    },
    {
        "question": "Among the seafoods, how many of them have an order quantity of more than 50?",
        "hint": "\"Seafood\" is the CategoryName; order quantity of more than 50 refers to Quantity > 50",
        "error_sql": "SELECT COUNT(T1.ProductID) FROM Product AS T1 INNER JOIN `Order Details` AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Category AS T3 ON T1.CategoryID = T3.CategoryID WHERE T3.CategoryName = 'Seafood' AND T2.Quantity > 50",
        "compiler_hint": "no such table: Products",
        "reflective_cot": "### Tip:\nThe issue here is that the table name 'Products' is correct, but the error message 'no such table: Product' suggests that the actual table name might be 'Product' instead of 'Products'. To avoid this mistake in the future, double-check the table names in the database schema to ensure they match the names used in the SQL query.",
        "ground_truth_sql": "SELECT COUNT(T1.ProductID) FROM Products AS T1 INNER JOIN `Order Details` AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Categories AS T3 ON T1.CategoryID = T3.CategoryID WHERE T3.CategoryName = 'Seafood' AND T2.Quantity > 50",
        "difficulty": ""
    },
    {
        "question": "How many horror movies were made by the worst directors?",
        "hint": "d_quality = 5 refers to direct the best, d_quality = 0 refers to direct the worst",
        "error_sql": "SELECT COUNT(T1.film_id) FROM film_director AS T1 INNER JOIN director AS T2 ON T1.director_id = T2.director_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN film_category AS T4 ON T3.film_id = T4.film_id INNER JOIN category AS T5 ON T4.category_id = T5.category_id WHERE T5.name = 'Horror' AND T2.d_quality = 0",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema. In this case, the error occurred due to the non-existent 'film_director' table. To avoid this mistake, carefully review the schema before generating the query. Additionally, pay attention to the column names and their corresponding tables. In the provided schema, the correct table for linking movies and directors is 'movies2directors', not 'film_director'. Also, the correct column names are 'movieid', 'genre', and 'directorid', not 'film_id', 'name', and 'director_id'.",
        "ground_truth_sql": "SELECT COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T1.directorid = T3.directorid WHERE T1.genre = 'horror' AND T3.d_quality = 0",
        "difficulty": ""
    },
    {
        "question": "List out the star scores of episode which has title of \"How the Test Was Won\".",
        "hint": "star scores refers to stars",
        "error_sql": "SELECT stars FROM episodes WHERE title = \"How the Test Was Won\"",
        "compiler_hint": "no such table: episode",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names match exactly with the actual table names in the database schema, including case sensitivity and pluralization. In this case, the correct table name is \"Episode\" (singular) instead of \"episodes\" (plural). Additionally, consider the relationships between tables and perform necessary joins to retrieve the desired information.",
        "ground_truth_sql": "SELECT T2.stars FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.title = 'How the Test Was Won';",
        "difficulty": ""
    },
    {
        "question": "Please list the country of the movie that stars an actress who acts the worse.",
        "hint": "a_quality = 5 refers to act the best, a_quality = 0 refers to act the worst",
        "error_sql": "SELECT T4.country FROM actor AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid INNER JOIN countries AS T4 ON T3.countryid = T4.countryid WHERE T1.a_gender = 'F' AND T1.a_quality = 0",
        "compiler_hint": "no such table: actors",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the column you are selecting (in this case, the country) is from the correct table. In the Error SQL Query and SQL after Reflection, the country was being selected from the 'countries' table (T4), but the correct table is the 'movies' table (T3) as it directly contains the country information for each movie. Always verify the schema and table relationships to avoid such mistakes.",
        "ground_truth_sql": "SELECT T3.country FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T1.a_gender = 'F' AND T1.a_quality = 0",
        "difficulty": ""
    },
    {
        "question": "Does the length of the tip influence the number of likes for hotel and travel business category?",
        "hint": "the longer the tip_length, the lesser the likes OR the longer the tip length the higher the likes; hotel and travel business category refers to category_name = 'Hotels & Travel';",
        "error_sql": "SELECT COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Tip AS T3 ON T1.business_id = T3.business_id WHERE T2.category_name = 'Hotels & Travel'",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that the table names and column names match the actual schema. In this case, the error was due to incorrect table names ('Business' instead of 'Categories' and 'Business_Categories', and 'Tip' instead of 'Tips'). To avoid this mistake, carefully review the schema before generating the query, and double-check the table and column names to ensure accuracy. Additionally, consider using the actual schema to inform the query generation process, rather than relying on assumptions or incomplete information.",
        "ground_truth_sql": "SELECT T3.tip_length, SUM(T3.likes) AS likes FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name = 'Hotels & Travel' GROUP BY T3.tip_length",
        "difficulty": ""
    },
    {
        "question": "How many times was \"Blanket Beverly\" rented?",
        "hint": "\"BLANKET BEVERLY\" is the title of film; rented times refers to count(rental_id)",
        "error_sql": "SELECT COUNT(T3.rental_id) FROM inventory AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T1.inventory_id = T3.inventory_id WHERE T2.title = 'BLANKET BEVERLY'",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table names are correct and consistent with the actual database schema. In this case, the error was not due to the SQL query itself, but rather the case sensitivity of the title 'BLANKET BEVERLY' vs 'Blanket Beverly'. The database schema is case sensitive, and the correct title is 'Blanket Beverly'. To avoid this mistake, double-check the column names, table names, and data values for consistency and accuracy.",
        "ground_truth_sql": "SELECT COUNT(T3.rental_id) FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE T1.title = 'Blanket Beverly'",
        "difficulty": ""
    },
    {
        "question": "What is the average height of people from USA?",
        "hint": "people from USA refers to birth_country = 'USA'; average height = AVG(height_meters)",
        "error_sql": "SELECT AVG(T2.height_meters) FROM athlete_info AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.birth_country = 'USA'",
        "compiler_hint": "no such table: athlete",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you carefully examine the schema to identify the correct table and column names. In this case, the height information is stored directly in the 'Person' table, eliminating the need for a join operation. Always verify the schema before generating a query to avoid unnecessary complexity and incorrect table references.",
        "ground_truth_sql": "SELECT AVG(height_meters) FROM Person WHERE birth_country = 'USA';",
        "difficulty": ""
    },
    {
        "question": "What is the total ordered quantity for products under the 'Touring' line?",
        "hint": "The Touring line refers to the product line, therefore ProductLine = 'T'",
        "error_sql": "SELECT SUM(OrderQty) FROM SalesOrderDetail AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.ProductLine = 'T'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined based on the query's requirements. In this case, the error was due to joining `SalesOrderDetail` instead of `PurchaseOrderDetail` to get the total ordered quantity for products under the 'Touring' line. Always verify the table names and their relationships to avoid such mistakes.",
        "ground_truth_sql": "SELECT SUM(T2.OrderQty) FROM Product AS T1 INNER JOIN PurchaseOrderDetail AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductLine = 'T'",
        "difficulty": ""
    },
    {
        "question": "List all the customer company names and cities located in Canada.",
        "hint": "located in Canada refers to Country = 'Canada'",
        "error_sql": "SELECT CompanyName, City FROM Customer WHERE Country = 'Canada'",
        "compiler_hint": "no such table: Customers",
        "reflective_cot": "### Tip: \nAlways verify the table name in the database schema to ensure it matches the table name used in the SQL query. In this case, the correct table name should be verified to avoid the mistake of using 'Customers' instead of the actual table name, which might be 'Customer' or something else.",
        "ground_truth_sql": "SELECT CompanyName, City FROM Customers WHERE Country = 'Canada'",
        "difficulty": ""
    },
    {
        "question": "Please provide the full name of the conference where one of the papers of Jean-luc Hainaut were published.",
        "hint": "papers of Jean-luc Hainaut refers to Name = 'Jean-luc Hainaut'",
        "error_sql": "SELECT T1.FullName FROM Conference AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId INNER JOIN PaperAuthor AS T3 ON T2.Id = T3.PaperId WHERE T3.Name = 'Jean-luc Hainaut'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order makes sense in the context of the query. In this case, the initial error was due to joining Conference with Paper before joining Paper with PaperAuthor, which led to a mismatch in the join order. The corrected query joins Paper with PaperAuthor first, and then joins the result with Conference, which is the correct order to retrieve the conference name for a specific author's papers. To avoid this mistake, always consider the logical flow of the query and ensure that the join order follows the relationships between the tables in a way that makes sense for the query being asked.",
        "ground_truth_sql": "SELECT DISTINCT T3.FullName FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE T2.Name = 'Jean-luc Hainaut' LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "List down the ID of movies with running time of 3 and average revenue of 1?",
        "hint": "",
        "error_sql": "SELECT movieid FROM movies2actors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.runtime = 3 AND T2.avg_revenue = 1",
        "compiler_hint": "no such table: movies",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names and table names match exactly with the provided schema. In this case, the error occurred because the column name was 'runningtime' instead of 'runtime', and 'avg_revenue' was in the 'directors' table, not the 'movies' table. Additionally, the query required joining multiple tables, which was not considered in the initial attempt. To avoid such mistakes, carefully review the schema and verify the column and table names before generating the SQL query.",
        "ground_truth_sql": "SELECT T1.movieid FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T2.directorid = T3.directorid WHERE T1.runningtime = 3 AND T3.avg_revenue = 1",
        "difficulty": ""
    },
    {
        "question": "Which nations have a 100% Spanish-speaking population?",
        "hint": "",
        "error_sql": "SELECT nation FROM language_data WHERE spanish_speakers = 100",
        "compiler_hint": "no such table: language",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema exactly, including case sensitivity. In this case, the correct table name is 'language' (not 'language_data'), and the correct column names are 'Country', 'Name', and 'Percentage' (not 'nation', 'spanish', or 'percentage'). Always double-check the schema before generating a query to avoid such mistakes.",
        "ground_truth_sql": "SELECT Country FROM language WHERE Name = 'Spanish' AND Percentage = 100",
        "difficulty": ""
    },
    {
        "question": "How old was Mr. Stacy Morar at the time of his first emergency room admission due to a drug overdose?",
        "hint": "how old = SUBTRACT(MIN(encounters.DATE), patients.birthdate); his first emergency room admission refers to MIN(encounters.DATE); drug overdose refers to encounters.REASONDESCRIPTION = 'Drug overdose' ;",
        "error_sql": "SELECT (strftime('%J', MIN(T1.ENCOUNTER_DATE)) - strftime('%J', T2.BIRTHDATE)) / 365.25 FROM Encounter AS T1 INNER JOIN Patient AS T2 ON T1.PATID = T2.PATID WHERE T1.REASONDESCRIPTION = 'Drug overdose' AND T2.FIRSTNAME = 'Stacy' AND T2.LASTNAME = 'Morar'",
        "compiler_hint": "no such table: encounters",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that column names and table aliases match the actual schema. In this case, the error was due to incorrect column names (e.g., 'DATE' instead of 'ENCOUNTER_DATE', 'PATID' instead of 'PATIENT', 'FIRSTNAME' and 'LASTNAME' instead of 'first' and 'last', 'DESCRIPTION' was missing) and incorrect table aliases (e.g., 'T1' and 'T2' were swapped). Additionally, the query logic was incorrect, as it did not account for the 'Emergency Room Admission' condition and did not use the correct method to calculate the age. To avoid this mistake, carefully review the schema and ensure that the query logic accurately reflects the problem statement.",
        "ground_truth_sql": "SELECT T2.DATE - T1.birthdate AS age FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Stacy' AND T1.last = 'Morar' AND T2.DESCRIPTION = 'Emergency Room Admission' AND T2.REASONDESCRIPTION = 'Drug overdose' ORDER BY T2.DATE LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What kind of expression correlation occurs in physical type interacting gene pairs and what percentage of these are negatively correlated?",
        "hint": "If the Expression_Corr value is negative then it's negatively correlated. Percentage of Negative Correlation = count(negative Expression_Corr physical type) / count(Expression_Corr physical type) * 100%",
        "error_sql": "SELECT \n    CASE \n        WHEN T2.Expression_Corr < 0 THEN 'negatively correlated'\n        ELSE 'positively correlated'\n    END AS correlation_type,\n    CAST(SUM(CASE WHEN T2.Expression_Corr < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.Expression_Corr) AS percentage_negative_correlation\nFROM \n    gene_pair AS T1\nINNER JOIN \n    gene_pair_expression AS T2\nON \n    T1.id = T2.gene_pair_id\nWHERE \n    T1.physical_type = 'interacting'",
        "compiler_hint": "no such table: gene_pairs",
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that you accurately identify the relevant table(s) and column(s) based on the provided schema. In this case, the error occurred because the query referenced a non-existent table 'gene_pairs' and incorrectly joined the 'Interactions' table. To avoid this mistake, carefully review the schema to confirm the correct table and column names, and ensure that the query logic aligns with the problem requirements. Additionally, consider breaking down complex queries into simpler components to verify the accuracy of each part before combining them.",
        "ground_truth_sql": "SELECT Expression_Corr FROM Interactions WHERE Type = 'Physical' UNION ALL SELECT CAST(SUM(Expression_Corr < 0) AS REAL) * 100 / COUNT(*) FROM Interactions WHERE Type = 'Physical'",
        "difficulty": ""
    },
    {
        "question": "Among the orders placed by Ei, how many orders have quantity greater than 4?",
        "hint": "Ei is the name of the customer; orders have quantity greater than 4 refer to OrderNumber WHERE Order Quantity > 4;",
        "error_sql": "SELECT COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE T2.`Customer Names` = 'Ei' AND T1.`Order Quantity` > 4",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and applying conditions, ensure that the conditions are correctly applied to the joined tables. In this case, the initial error was not actually an error, but the reflection SQL was also provided as incorrect. However, the actual issue here is that the initial SQL query was correct and should have worked as intended. The reflection SQL was unnecessary and added complexity. The tip is to trust the initial query and only revise it if there's actual error information or a logical flaw.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.`Order Quantity` > 4 AND T2.`Customer Names` = 'Ei ' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "difficulty": ""
    },
    {
        "question": "Please list the names of all the players with a height of over 6'2\" inches.",
        "hint": "name of the players refers to PlayerName; height of over 6'2\" inches refers to height_in_inch > '6''2\"' ;",
        "error_sql": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch > '6''2\"'",
        "compiler_hint": "no such table: PlayerInfo",
        "reflective_cot": "### Tip:\nWhen generating SQL queries, ensure that the table names used in the query match the actual table names in the database schema. In this case, the error occurred because the table name was incorrectly assumed to be 'PlayerInfo' instead of 'Player' and also 'PlayerInfo' instead of 'PlayerInfo' in the second attempt. The correct table name should be used consistently throughout the query. Additionally, verify that the table and column names are correctly referenced in the query to avoid errors.",
        "ground_truth_sql": "SELECT DISTINCT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch > '6''2\"'",
        "difficulty": ""
    },
    {
        "question": "How many events were held at coordinate 97,40?",
        "hint": "coordinate 97,40 refers to longitude = 97 AND latitude = 40;",
        "error_sql": "SELECT COUNT(event_id) FROM event WHERE longitude = 97 AND latitude = 40",
        "compiler_hint": "no such table: events",
        "reflective_cot": "### Tip:\nWhen dealing with table names that are also SQL keywords or contain special characters, it's essential to enclose them in backticks (``) to avoid conflicts and ensure the query is executed correctly. In this case, the table name \"events\" should be enclosed in backticks as it's a reserved keyword in SQL.",
        "ground_truth_sql": "SELECT COUNT(event_id) FROM `events` WHERE latitude = 40 AND longitude = 97",
        "difficulty": ""
    },
    {
        "question": "Which employee is in charge of the sales in Hollis? Please give the employee's full name.",
        "hint": "Hollis refers to TerritoryDescription = 'Hollis'; full name = FirstName, LastName;",
        "error_sql": "SELECT T1.FirstName, T1.LastName FROM EmployeeTerritories AS T2 INNER JOIN Employees AS T1 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Territories AS T3 ON T3.TerritoryID = T2.TerritoryID WHERE T3.TerritoryDescription = 'Hollis'",
        "compiler_hint": "no such table: Employees",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order is correct and logical. In this case, the correct order is to join Employees with EmployeeTerritories first, and then join the result with Territories. This is because an employee is associated with multiple territories through the EmployeeTerritories table, and then each territory is associated with a description. Joining in the correct order helps to avoid errors and ensures that the query returns the correct results.",
        "ground_truth_sql": "SELECT T1.FirstName, T1.LastName FROM Employees AS T1 INNER JOIN EmployeeTerritories AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Territories AS T3 ON T2.TerritoryID = T3.TerritoryID WHERE T3.TerritoryDescription = 'Hollis'",
        "difficulty": ""
    },
    {
        "question": "For all transactions for WRAP in August 2016, list the time to achieve highest price and the time to achieve the lowest price.",
        "hint": "in May 2013 refers to month(date) = 5 AND year(date) = 2013; time to achieve the highest price refers to time_high; time to achieve the lowest price refers to time_low; WRAP refers to name = 'WARP'",
        "error_sql": "SELECT MAX(time_high), MIN(time_low) FROM WRAP WHERE STRFTIME('%Y-%m', date) = '2016-08'",
        "compiler_hint": "no such table: transactions",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the schema exactly, including case sensitivity. In this case, the error was due to a typo in the name 'WRAP' instead of 'WARP'. Always double-check the schema and query to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.time_high, T2.time_low, T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND STRFTIME('%Y-%m', T2.date) = '2016-08'",
        "difficulty": ""
    },
    {
        "question": "How many domestic violence cases were brought in the ward that uses \"ward13@cityofchicago.org\"?",
        "hint": "domestic violence refers to domestic = 'TRUE'; uses \"ward13@cityofchicago.org\" refers to ward_email = 'ward13@cityofchicago.org'",
        "error_sql": "SELECT COUNT(T2.report_no) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward = T2.community_area_no INNER JOIN Community_Areas AS T3 ON T2.community_area_no = T3.area_number WHERE T1.ward_email = 'ward13@cityofchicago.org' AND T2.domestic = 'TRUE'",
        "compiler_hint": "no such table: Wards",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the tables are joined in the correct order. In this case, the error occurred because the join was not done directly between the Ward and Crime tables, but rather through the Community_Areas table. However, the correct join is directly between Ward and Crime on the ward_no column. To avoid this mistake, carefully examine the schema and ensure that the join conditions are correct and the tables are joined in the most direct and logical way.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.domestic = 'TRUE' THEN 1 ELSE 0 END) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no WHERE T1.ward_email = 'ward13@cityofchicago.org'",
        "difficulty": ""
    },
    {
        "question": "How many of the businesses are in Surprise?",
        "hint": "Surprise is a city",
        "error_sql": "SELECT COUNT(business_id) FROM Businesses WHERE city = 'Surprise'",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nAlways verify the exact table name from the schema before writing the SQL query. In this case, the correct table name is not provided, but the error message suggests that the table name might be different from 'Business'. It's essential to check the schema for the correct table name to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(business_id) FROM Business WHERE city = 'Surprise'",
        "difficulty": ""
    },
    {
        "question": "Among the students that have been absent from school for more than 5 months, how many of them are male?",
        "hint": "absent from school for more than 5 months refers to `month`\u00a0 > = 5;",
        "error_sql": "SELECT COUNT(T1.name) FROM absent AS T1 INNER JOIN person AS T2 ON T1.name = T2.name WHERE T2.gender = 'M' AND T1.month >= 5",
        "compiler_hint": "no such table: absent",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join is performed with the correct table that contains the required information. In this case, the error occurred because the join was performed with the 'person' table instead of the 'male' table, which is the correct table to filter for male students. Always verify the schema and table relationships to avoid such mistakes. Additionally, be cautious when using table aliases and ensure that the correct columns are being referenced.",
        "ground_truth_sql": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN male AS T2 ON T1.`name` = T2.`name` WHERE T1.`month` >= 5",
        "difficulty": ""
    },
    {
        "question": "For how many times had the dish \"Chicken gumbo\" appeared on a menu page?",
        "hint": "Chicken gumbo is a name of dish;",
        "error_sql": "SELECT COUNT(T2.menu_page_id) FROM MenuItem AS T1 INNER JOIN MenuItem AS T2 ON T1.dish_id = T2.dish_id WHERE T1.name = 'Chicken gumbo'",
        "compiler_hint": "no such table: dish",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the Error SQL Query used 'dish_id' which does not exist in the Dish table, and the SQL after Reflection used 'id' but did not verify if it's the correct column to join on. Additionally, verify the logic of the query, in this case, the COUNT function is not the best approach as it counts all rows, whereas the SUM function with a CASE statement is more suitable for counting specific conditions. Always double-check the schema and the logic of the query to avoid such mistakes.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.name = 'Chicken gumbo' THEN 1 ELSE 0 END) FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id",
        "difficulty": ""
    },
    {
        "question": "Give the full name of legislators who have accounts on OpenSecrets.org.",
        "hint": "full name refers to first_name, last_name; have accounts on OpenSecrets.org refers to opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "error_sql": "SELECT first_name, last_name FROM current WHERE opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the query aligns with the question's requirements. In this case, the question asks for the \"full name\" of legislators, but the provided Ground Truth SQL query only counts the number of legislators with OpenSecrets.org accounts. To answer the question correctly, the query should select the full names (first_name and last_name) of the legislators, not count them.",
        "ground_truth_sql": "SELECT COUNT(*) FROM current WHERE opensecrets_id IS NOT NULL AND opensecrets_id <> ''",
        "difficulty": ""
    },
    {
        "question": "How much more expensive in percentage is the product with the highest selling price from the product with the lowest selling price in the Clothing category?",
        "hint": "selling price refers to ListPrice; highest selling price refers to MAX(ListPrice); lowest selling price refers to MIN(ListPrice);",
        "error_sql": "SELECT CAST(((MAX(T1.ListPrice) - MIN(T1.ListPrice)) * 100.0) / MIN(T1.ListPrice), REAL) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE T3.Name = 'Clothing'",
        "compiler_hint": "near \",\": syntax error",
        "reflective_cot": "### Tip: \nWhen performing calculations involving multiple tables, ensure that the tables are properly joined and that the columns are correctly referenced. In this case, the error was due to the incorrect use of the CAST function and the lack of proper table joins. To avoid this mistake, always verify that the tables are correctly joined and that the columns are properly referenced. Additionally, be mindful of the order of operations and the use of parentheses to ensure that the calculations are performed correctly.",
        "ground_truth_sql": "SELECT (MAX(T1.ListPrice) - MIN(T1.ListPrice)) * 100 / MIN(T1.ListPrice) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE T3.Name = 'Clothing'",
        "difficulty": ""
    },
    {
        "question": "What is the average heights of crew members from Animation Department?",
        "hint": "from Animation Department refers to category = 'Animation Department';\u00a0AVG(height_meters) where category = 'Animation Department'",
        "error_sql": "SELECT AVG(T2.height_meters) FROM crew AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.category = 'Animation Department'",
        "compiler_hint": "no such table: crew_info",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being joined is present in both tables and that the correct table alias is used to reference the column. In this case, the error occurred because the column 'height_meters' was referenced from the wrong table alias in the SQL after Reflection. Additionally, the correct join order and table aliases should be used to avoid confusion. Always verify the schema and table relationships before writing the SQL query.",
        "ground_truth_sql": "SELECT AVG(T1.height_meters) FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T2.category = 'Animation Department';",
        "difficulty": ""
    },
    {
        "question": "How many turnovers per game did the assist champion had in the 2003 NBA season?",
        "hint": "turnovers per game = avg(turnovers); 2003 refers to year = 2003; NBA refers to lgID = 'NBA'",
        "error_sql": "SELECT AVG(T1.turnovers) FROM Season_Stats AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 2003 AND T1.lgID = 'NBA'",
        "compiler_hint": "no such table: season",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct table is being referenced for the desired column. In this case, the 'lgID' column is in the 'players_teams' table, not the 'season' table. Also, when filtering for a specific league, consider whether the filter is necessary if the question only asks for a specific year and the league is already implied by the context (NBA season). Additionally, be cautious when using aggregate functions with GROUP BY, as the grouping columns should be relevant to the query's requirements.",
        "ground_truth_sql": "SELECT AVG(T2.turnovers) FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 2003 GROUP BY T1.playerID, T2.assists ORDER BY T2.assists DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the independent countries, how many of them has a GDP per capita of over 5000?",
        "hint": "",
        "error_sql": "SELECT COUNT(name) FROM countries WHERE independent = 'TRUE' AND gdp_per_capita > 5000",
        "compiler_hint": "no such table: country",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the column names and table names match the actual schema. In this case, the error was due to incorrect column names ('gdp_per_capita' instead of 'GDP') and incorrect table names ('country' instead of joining 'country', 'politics', and 'economy' tables). Always verify the schema before generating the query to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE T2.Independence IS NOT NULL AND T3.GDP > 5000",
        "difficulty": ""
    },
    {
        "question": "What are the coordinates of the school where project 'Look, Look, We Need a Nook!' Was donated to and what resource type is it?",
        "hint": "Coordinates of the school refer to school_latitude, school_longitude); Look, Look, We Need a Nook! Refer to title;",
        "error_sql": "SELECT T1.lat, T1.long, T2.resource_type FROM schools AS T1 INNER JOIN projects AS T2 ON T1.id = T2.school_id WHERE T2.title = 'Look, Look, We Need a Nook!'",
        "compiler_hint": "no such table: schools",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table aliases used in the SELECT and WHERE clauses match the actual column names and table aliases in the database schema. Also, verify that the join conditions are correct and that the tables are joined in the correct order. In this case, the error was due to incorrect table aliases and column names, as well as incorrect join conditions. To avoid this mistake, carefully review the database schema and double-check the SQL query before execution. Additionally, consider using table aliases that are descriptive and consistent with the table names to reduce confusion.",
        "ground_truth_sql": "SELECT T2.school_latitude, T2.school_longitude, T2.resource_type FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.title LIKE 'Look, Look, We Need a Nook!'",
        "difficulty": ""
    },
    {
        "question": "Which order have the highest unit cost?",
        "hint": "order have the highest unit cost refers to OrderNumber where MAX(Unit Cost);",
        "error_sql": "SELECT OrderNumber FROM `Sales Orders` ORDER BY CAST(REPLACE(`Unit Cost`, ',', '') AS REAL) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the maximum or minimum value in a column, avoid using ORDER BY and LIMIT. Instead, use a subquery to find the maximum or minimum value and then use that value to select the corresponding rows. This is because ORDER BY and LIMIT can return multiple rows if there are ties for the maximum or minimum value, whereas the subquery approach will return all rows that have the maximum or minimum value.",
        "ground_truth_sql": "SELECT OrderNumber FROM `Sales Orders` WHERE REPLACE(`Unit Cost`, ',', '') = ( SELECT REPLACE(`Unit Cost`, ',', '') FROM `Sales Orders` ORDER BY REPLACE(`Unit Cost`, ',', '') DESC LIMIT 1 )",
        "difficulty": ""
    },
    {
        "question": "List the names and business certificates of the eateries which got inspection score under 50.",
        "hint": "eateries which got inspection score under 50 refer to business_id where score < 50;",
        "error_sql": "SELECT T1.name, T1.business_certificate FROM businesses AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id WHERE T2.score < 50",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names in the SELECT statement match the table alias used in the JOIN clause. In this case, the correct table alias for the businesses table is T2, and the correct column name to retrieve is business_id, not business_certificate. Always double-check the column names and table aliases to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.name, T2.business_id FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score < 50",
        "difficulty": ""
    },
    {
        "question": "What is the average number of less severe crimes reported a day in February of 2018?",
        "hint": "day in February of 2018 refers to date LIKE '2/%/2018'; less severe crime refers to index_code = 'N'; average = Divide (Count(case_number), 28)",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN T2.index_code = 'N' THEN T2.case_number END) AS REAL) / 28 FROM Community_Areas AS T1 INNER JOIN Crime_Data AS T2 ON T1.area_number = T2.community_area_number WHERE T2.date LIKE '2/%/2018'",
        "compiler_hint": "no such table: Crime",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join is based on the correct columns and that all necessary tables are included. In this case, the first two attempts failed because they did not join the IUCR table, which contains the index_code column necessary for filtering less severe crimes. Additionally, the join condition in the second attempt was incorrect, as it joined on community_area_no instead of iucr_no. To avoid this mistake, carefully review the schema and ensure that all necessary tables and columns are included in the query.",
        "ground_truth_sql": "SELECT CAST(COUNT(T2.case_number) AS REAL) / 28 FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no WHERE T2.date LIKE '2/%/2018%' AND T1.index_code = 'N'",
        "difficulty": ""
    },
    {
        "question": "List ther users who gave the worst rating for movie 'Love Will Tear Us Apart'.",
        "hint": "worst rating refers to rating_score = 1;",
        "error_sql": "SELECT T4.user_id FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T2.user_id = T3.user_id INNER JOIN lists_users AS T4 ON T3.user_id = T4.user_id WHERE T1.movie_title = 'Love Will Tear Us Apart' AND T2.rating_score = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and the table aliases are consistent with the query's logic. In this case, the error was caused by joining the tables in the wrong order and using incorrect aliases. To avoid this mistake, carefully plan the join order and use meaningful table aliases that reflect the query's logic. Additionally, verify that the join conditions and the WHERE clause are correctly referencing the table aliases.",
        "ground_truth_sql": "SELECT T1.user_id FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Love Will Tear Us Apart' AND T1.rating_score = 1",
        "difficulty": ""
    },
    {
        "question": "What brand of beer has been the worst rated most times?",
        "hint": "brand of beer refers to BrandName; worst rated most times refers to MAX(COUNT(StarRating = 1));",
        "error_sql": "SELECT T2.BrandName FROM beer AS T1 INNER JOIN beerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T1.StarRating = 1 GROUP BY T2.BrandName ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "compiler_hint": "no such table: rootbeer",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join is performed between the correct tables and that the join condition is based on the correct columns. In this case, the error occurred because the join was performed between `rootbeer` and `rootbeerbrand`, but the `StarRating` column is actually in the `rootbeerreview` table. To avoid this mistake, carefully examine the schema and ensure that the joins are performed between the correct tables and that the join conditions are based on the correct columns. Additionally, verify that the columns used in the WHERE, GROUP BY, and ORDER BY clauses exist in the tables being queried.",
        "ground_truth_sql": "SELECT T1.BrandName FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T2.BrandID = T1.BrandID WHERE T2.StarRating = 1 GROUP BY T1.BrandName ORDER BY COUNT(T1.BrandName) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How did Kyran Muller submit his complaint?",
        "hint": "how it was submitted refers to \"Submitted via\";",
        "error_sql": "SELECT T2.`Submitted via` FROM complaint AS T1 INNER JOIN complaint_info AS T2 ON T1.complaint_id = T2.complaint_id WHERE T1.first_name = 'Kyran' AND T1.last_name = 'Muller'",
        "compiler_hint": "no such table: complaints",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the WHERE clause match the actual column names in the tables. In this case, the error occurred because the columns 'first_name' and 'last_name' do not exist in the 'client' table; instead, they are named 'first' and 'last'. Additionally, when retrieving distinct values, use the DISTINCT keyword to avoid duplicate results.",
        "ground_truth_sql": "SELECT DISTINCT T2.`Submitted via` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Kyran' AND T1.last = 'Muller'",
        "difficulty": ""
    },
    {
        "question": "List the active business ID and its stars of the businesses fall under the category of Pets.",
        "hint": "active business refers to active = 'true'; 'Pets' is the category_name",
        "error_sql": "SELECT T2.business_id, T2.stars FROM Categories AS T1 INNER JOIN Business_Categories AS T3 ON T1.category_id = T3.category_id INNER JOIN Business AS T2 ON T3.business_id = T2.business_id WHERE T1.category_name = 'Pets' AND T2.active = 'true'",
        "compiler_hint": "no such table: Business_Categories",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table aliases (e.g., T1, T2, T3) are consistently used throughout the query. In the Error SQL Query and SQL after Reflection, the aliases were not correctly assigned to the tables, leading to incorrect table references. To avoid this mistake, carefully review the table aliases and ensure they match the correct tables in the FROM and JOIN clauses. Additionally, verify that the table names and column names match the actual schema to prevent errors like \"no such table.\"",
        "ground_truth_sql": "SELECT T1.business_id, T1.stars FROM Business AS T1 INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE T1.active LIKE 'TRUE' AND T3.category_name LIKE 'Pets'",
        "difficulty": ""
    },
    {
        "question": "What is the total number of fans or followers who received most likes of their comments in the business?",
        "hint": "fans and followers refers to user_fans; most likes of their comments refer to Max(likes)",
        "error_sql": "SELECT COUNT(user_fans) FROM Review WHERE likes = (SELECT MAX(likes) FROM Review)",
        "compiler_hint": "no such table: Users",
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully analyze the relationships between tables and the conditions specified in the problem. In this case, the error was due to not considering the relationship between the Users table and the Tips table, and also not aggregating the likes before ordering. To avoid similar mistakes, always make sure to identify the relevant tables and their relationships, and consider the aggregation requirements for the problem at hand. Additionally, be cautious when using ORDER BY and LIMIT, as they can significantly impact the result, and ensure that the columns used in these clauses are correctly aggregated if necessary.",
        "ground_truth_sql": "SELECT COUNT(T1.user_fans) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id ORDER BY COUNT(T2.likes) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the difference between the number of children's films and action films?",
        "hint": "'children' AND 'action' are names of a category; Calculation = SUBTRACT(AVG('children'), AVG('action'))",
        "error_sql": "SELECT SUM(IIF(T4.name = 'Children', 1, -1)) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN category AS T4 ON T2.name = T4.name",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen writing SQL queries, ensure that the logic and conditions are correctly implemented to achieve the desired outcome. In this case, the first two attempts were incorrect because they did not accurately represent the calculation of the difference between the number of children's films and action films. The first query had incorrect table names and the second query only counted the children's films but did not subtract the action films. To avoid this mistake, carefully review the query logic and conditions to ensure they align with the desired outcome, and consider breaking down complex calculations into smaller, manageable parts.",
        "ground_truth_sql": "SELECT SUM(IIF(T2.name = 'Children', 1, 0)) - SUM(IIF(T2.name = 'Action', 1, 0)) AS diff FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "difficulty": ""
    },
    {
        "question": "Among the patients who were immunized with meningococcal MCV4P, how many have viral sinusitis disorder after getting the immunization?",
        "hint": "immunized with meningococcal MCV4P refers to DESCRIPTION = 'meningococcal MCV4P' from immunizations; viral sinusitis disorder refers to DESCRIPTION = 'Viral sinusitis (disorder)' from conditions;",
        "error_sql": "SELECT COUNT(T1.PATIENT) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT INNER JOIN immunizations AS T3 ON T1.patient = T3.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)' AND T3.DESCRIPTION = 'meningococcal MCV4P'",
        "compiler_hint": "no such table: conditions",
        "reflective_cot": "### Tip:\nWhen joining two tables, ensure that the join order and the conditions in the WHERE clause are correctly aligned with the problem statement. In this case, the problem asks for patients who were immunized with meningococcal MCV4P and then developed viral sinusitis disorder. Therefore, the immunizations table should be the primary table, and the conditions table should be joined to it. Additionally, using DISTINCT in the COUNT function is necessary to avoid counting duplicate patients.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.patient) FROM immunizations AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.DESCRIPTION = 'meningococcal MCV4P' AND T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "What is the category and itune url of the title \"Scaling Global\"?",
        "hint": "",
        "error_sql": "SELECT T3.category, T1.itunes_url FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T1.podcast_id = T2.podcast_id INNER JOIN categories AS T3 ON T1.podcast_id = T3.podcast_id WHERE T2.title = 'Scaling Global'",
        "compiler_hint": "no such column: T2.itunes_url",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that you are referencing the correct table alias for the column you want to select. In this case, the error occurred because the `itunes_url` column is in the `podcasts` table, not the `reviews` table. Similarly, the `title` column used in the WHERE clause should also be from the `podcasts` table, not the `reviews` table. Always double-check the table aliases and column names to avoid such mistakes. Additionally, the join order and conditions should be carefully considered to ensure that the correct data is being retrieved.",
        "ground_truth_sql": "SELECT T1.category, T2.itunes_url FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.title = 'Scaling Global'",
        "difficulty": ""
    },
    {
        "question": "For the event which happened at 14:09:49 on 2016/5/6, in the location coordinate(116, 40), how many apps were active?",
        "hint": "at 14:09:49 on 2016/5/6 refers to timestamp = '2016/5/6 14:09:49'; location coordinate(116, 40) refers to longitude = '116' AND latitude = '40'; active refers to is_active = '1';",
        "error_sql": "SELECT COUNT(T1.app_id) FROM event AS T1 WHERE T1.longitude = 116 AND T1.latitude = 40 AND T1.timestamp = '2016/5/6 14:09:49' AND T1.is_active = 1",
        "compiler_hint": "no such table: app",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names used in the query match the actual table names in the database schema. In this case, the error occurred because the table name 'event' was used instead of 'events' and 'app_events' was not used. To avoid this mistake, carefully review the database schema before generating the query, and double-check that the table names are correct. Additionally, pay attention to the exact column names and data types to avoid any potential errors.",
        "ground_truth_sql": "SELECT COUNT(T1.app_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE T2.timestamp = '2016-05-06 14:09:49' AND T1.is_active = '1' AND T2.longitude = '116' AND T2.latitude = '40'",
        "difficulty": ""
    },
    {
        "question": "Please list any three community areas with a population of more than 50,000.",
        "hint": "population of more than 50000 refers to Population > 50000; community area refers to community_area_name",
        "error_sql": "SELECT community_area_name FROM Community_Area WHERE Population > 50000 LIMIT 3",
        "compiler_hint": "no such table: Community_Areas",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match exactly with the provided schema, including case sensitivity. In this case, the correct table name is \"Community_Area\" (singular), not \"Community_Areas\" (plural).",
        "ground_truth_sql": "SELECT community_area_name FROM Community_Area WHERE population > 50000 LIMIT 3",
        "difficulty": ""
    },
    {
        "question": "How many releases by the artist michael jackson are tagged \"pop\"?",
        "hint": "tag = 'pop';",
        "error_sql": "SELECT COUNT(T1.groupName) FROM releases AS T1 INNER JOIN artists AS T2 ON T1.artistId = T2.artistId WHERE T2.artistName = 'Michael Jackson' AND T1.tag LIKE '%pop%'",
        "compiler_hint": "no such table: torrents",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined based on the correct keys. In this case, the error was due to joining the 'artists' table instead of the 'tags' table, and also using 'LIKE' instead of '=' for exact matching. Additionally, the 'releases' table was not used in the query, but the error message mentioned it, indicating a possible misunderstanding of the schema. To avoid this, carefully review the schema and the relationships between tables before writing the query.",
        "ground_truth_sql": "SELECT COUNT(T1.groupName) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'pop' AND T1.artist = 'michael jackson'",
        "difficulty": ""
    },
    {
        "question": "For how many consecutive years did Aruba get a footnote on the series code BX.KLT.DINV.CD.WD?",
        "hint": "Aruba is the name of country where ShortName = 'Aruba'",
        "error_sql": "SELECT COUNT(DISTINCT T1.year) FROM footnote AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id INNER JOIN series AS T3 ON T1.series_id = T3.id WHERE T2.ShortName = 'Aruba' AND T3.code = 'BX.KLT.DINV.CD.WD'",
        "compiler_hint": "no such table: footnote",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and the column names match exactly, including case sensitivity. In this case, the error was due to incorrect table and column names. The correct table name is 'FootNotes' instead of 'footnote', and the correct join conditions are 'Countrycode' and 'CountryCode' instead of 'country_id' and 'id'. Additionally, the correct column to count is 'Year' instead of 'id' or 'year'. To avoid this mistake, double-check the schema and table names before writing the query.",
        "ground_truth_sql": "SELECT COUNT(T2.Year) FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.ShortName = 'Aruba' AND T2.Seriescode = 'BX.KLT.DINV.CD.WD'",
        "difficulty": ""
    },
    {
        "question": "On 8/29/2013, who took the longest to arrive in California Ave Caltrain Station from University and Emerson? Indicate the bike id.",
        "hint": "start_date = '8/29/2013'; end_date = '8/29/2013'; end_station_name = 'California Ave Caltrain Station'; start_station_name = 'University and Emerson'; who took the longest to arrive refers to MAX(duration);",
        "error_sql": "SELECT bike_id FROM trip WHERE start_date = '8/29/2013' AND end_date = '8/29/2013' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' ORDER BY duration DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column based on certain conditions, using `ORDER BY` and `LIMIT` may not always be the correct approach, especially if there are multiple rows with the same maximum or minimum value. Instead, use a subquery to find the maximum or minimum value first, and then use that value to filter the results. This ensures that all rows with the maximum or minimum value are included, not just the first one encountered.",
        "ground_truth_sql": "SELECT bike_id FROM trip WHERE start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' AND duration = ( SELECT MAX(duration) FROM trip WHERE start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%' AND end_station_name = 'California Ave Caltrain Station' AND start_station_name = 'University and Emerson' )",
        "difficulty": ""
    },
    {
        "question": "Which are the years that character Mr. Burns won an award?",
        "hint": "",
        "error_sql": "SELECT T1.year FROM award AS T1 INNER JOIN winner AS T2 ON T1.award_id = T2.award_id INNER JOIN character AS T3 ON T2.character_id = T3.character_id WHERE T3.character_name = 'Mr. Burns'",
        "compiler_hint": "no such table: Award",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct table names and column names are used. In this case, the error occurred because the table name 'Winner' was incorrect, and the correct table name was 'Character_Award'. Additionally, the column name 'character_id' was incorrect, and the correct column name was 'character'. To avoid this mistake, double-check the schema of the database to ensure that the correct table and column names are used.",
        "ground_truth_sql": "SELECT DISTINCT T1.year FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T2.character = 'Mr. Burns';",
        "difficulty": ""
    },
    {
        "question": "Describe the specific description and case locations under IUCR 142.",
        "hint": "specific description refers to secondary_description; location refers to latitude, longitude; IUCR 142 refers to iucr_no = 142",
        "error_sql": "SELECT T2.secondary_description, T1.latitude, T1.longitude FROM Crime_Data AS T1 INNER JOIN Crime AS T2 ON T1.report_no = T2.report_no WHERE T2.iucr_no = 142",
        "compiler_hint": "no such table: Crime",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table with the column being filtered (in this case, iucr_no = 142) is the same table that contains the column being filtered. Also, verify that the column being selected (secondary_description) is from the correct table. In this case, the correct table for secondary_description is IUCR, not Crime_Data or Crime. Always double-check the schema to ensure the correct table and column relationships are being used.",
        "ground_truth_sql": "SELECT T1.secondary_description, T2.latitude, T2.longitude FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T2.iucr_no = 142",
        "difficulty": ""
    },
    {
        "question": "What is the height in centimeter of the tallest player born in Edmonton, Alberta, Canada?",
        "hint": "height in centimeter refers to height_in_cm; tallest player refers to MAX(height_in_cm); born in Edmonton, Alberta, Canada refers to birthplace = 'Edmonton, AB, CAN';",
        "error_sql": "SELECT MAX(T2.height_in_cm) FROM Player AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.birthplace = 'Edmonton, AB, CAN'",
        "compiler_hint": "no such table: PlayerInfo",
        "reflective_cot": "### Tip:\nWhen using aggregate functions like MAX, MIN, AVG, etc., consider whether you need to retrieve additional information about the row that corresponds to the aggregated value. In this case, using MAX alone would only return the maximum height, but not the corresponding height_in_cm value. To avoid this mistake, think about whether you need to use a subquery or an ORDER BY with LIMIT to retrieve the entire row that corresponds to the aggregated value.",
        "ground_truth_sql": "SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.birthplace = 'Edmonton, AB, CAN' ORDER BY T2.height_in_cm DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Where is the school that needs a \"Viewscreen LCD from Texas Instruments, TI-84 Plus\"? Provide the latitude and longitude of that school.",
        "hint": "needs a \"Viewscreen LCD from Texas Instruments, TI-84 Plus\" refers to item_name = 'Viewscreen LCD from Texas Instruments, TI-84 Plus'; where is the school refers to school_city; latitude refers to school_latitude; longtitude refers to school_longitude",
        "error_sql": "SELECT T2.school_latitude, T2.school_longitude, T2.school_city FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.item_name = 'Viewscreen LCD from Texas Instruments, TI-84 Plus'",
        "compiler_hint": "no such table: essays",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct table is being referenced for the desired columns. In this case, the error occurred because the 'essays' table was referenced instead of the 'resources' table, and 'school_city' was missing in the SELECT statement. To avoid this mistake, double-check the schema to confirm the correct table and column names, and make sure to include all required columns in the SELECT statement.",
        "ground_truth_sql": "SELECT T2.school_city, T2.school_latitude, T2.school_longitude FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.item_name = 'Viewscreen LCD FROM Texas Instruments, TI-84 Plus'",
        "difficulty": ""
    },
    {
        "question": "In the state where Lisa Murkowski is the representative, how many cities have zero employees?",
        "hint": "zero employee refers to employees = 0",
        "error_sql": "SELECT COUNT(T1.city) FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.congress_rep_id WHERE T3.first_name = 'Lisa' AND T3.last_name = 'Murkowski' AND T1.employees = 0",
        "compiler_hint": "no such table: zip_city_state",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being referenced and that the join conditions are accurate. In this case, the error was due to referencing the wrong table (zip_city_state instead of zip_data) and incorrect join conditions. Additionally, pay attention to the order of the first_name and last_name in the WHERE clause, as it should match the actual order in the congress table. To avoid this mistake, double-check the schema and the relationships between tables before writing the query.",
        "ground_truth_sql": "SELECT COUNT(T3.city) FROM congress AS T1 INNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE T1.first_name = 'Murkowski' AND T1.last_name = 'Lisa' AND T3.employees = 0",
        "difficulty": ""
    },
    {
        "question": "Provide the supplier company name in Sydney and its homepage address if available.",
        "hint": "in Sydney refers to City = 'Sydney';",
        "error_sql": "SELECT CompanyName, HomePage FROM Suppliers WHERE City = 'Sydney'",
        "compiler_hint": "no such table: Supplier",
        "reflective_cot": "### Tip:\nAlways double-check the table name in the database schema to ensure it matches the table name used in the SQL query. In this case, the correct table name is 'Suppliers' (with an 's'), not 'Supplier'.",
        "ground_truth_sql": "SELECT CompanyName, HomePage FROM Suppliers WHERE City = 'Sydney'",
        "difficulty": ""
    },
    {
        "question": "What is the newest established organization where Singapore is a member of?",
        "hint": "",
        "error_sql": "SELECT organ FROM ( SELECT organ, MAX(year) AS max_year FROM member GROUP BY organ ) T ORDER BY T.max_year DESC LIMIT 1",
        "compiler_hint": "no such table: members",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct columns are used for matching, especially when there are multiple columns with similar names. In this case, the mistake was made by joining organization table with isMember table on OrgCode and Country, but the correct join should be on Country. Always double-check the schema and the relationships between tables to avoid such errors.",
        "ground_truth_sql": "SELECT T3.Name FROM country AS T1 INNER JOIN isMember AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country WHERE T1.Name = 'Singapore' ORDER BY T3.Established DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Name the teams played in a match which resulted in a tie in 2015.",
        "hint": "resulted in a tie refers to Win_Type = 'Tie'; in 2015 refers to SUBSTR(Match_Date, 1, 4) = 2015",
        "error_sql": "SELECT T1.Team_Name, T2.Team_Name FROM Team AS T1 INNER JOIN Team AS T2 ON T1.Team_Id = T3.Team_1 INNER JOIN Match AS T3 ON T2.Team_Id = T3.Team_2 WHERE T3.Win_Type = 'Tie' AND SUBSTR(T3.Match_Date, 1, 4) = '2015'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join conditions are correct and that the correct columns are being referenced. In the Error SQL Query, the join condition `T1.Team_Id = T3.Team_1` is incorrect because it is trying to join `Team` with `Match` on `Team_Id` with `Team_1`, but `Team_1` is not a foreign key referencing `Team_Id`. \n\nAdditionally, when using `OR` conditions in joins, use parentheses to ensure the correct order of operations. In the Error SQL Query, the join condition `T1.Team_Id = T3.Team_1 INNER JOIN Match AS T3 ON T2.Team_Id = T3.Team_2` is incorrect because it is trying to join `Team` with `Match` on two different conditions, but the conditions are not correctly grouped.\n\nIn the SQL after Reflection, the query is still incorrect because it is trying to join `Team` with `Match` on two different conditions, but the conditions are not correctly grouped.\n\nThe Ground Truth SQL query correctly joins `Team` with `Match` on the condition that `Team_Id` is either `Team_1` or `Team_2`, and then joins `Match` with `Win_By` on the condition that `Win_Type` is `Tie`. The `LIMIT 1` clause is used to return only one row, assuming that there is only one match that resulted in a tie in 2015.",
        "ground_truth_sql": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Win_By AS T3 ON T2.Win_Type = T3.Win_Id WHERE SUBSTR(T2.Match_Date, 1, 4) = '2015' AND T3.Win_Type = 'Tie' LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Please indicate the business id have the closing time with the category of Arts & Entertainment on Sunday.",
        "hint": "Sunday refers to day_of_week = 'Sunday' where day_id = 1; category of Arts & Entertainment refers to category_name = 'Arts & Entertainment';",
        "error_sql": "SELECT T1.business_id FROM Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business_Categories AS T3 ON T1.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T2.day_of_week = 'Sunday' AND T4.category_name = 'Arts & Entertainment'",
        "compiler_hint": "no such table: Business_Hours",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the columns used for joining are correct. In this case, the error occurred because the join order was incorrect, and the columns used for joining were not properly aligned with the query's requirements. To avoid this mistake, carefully analyze the query's requirements, identify the primary table, and then join the other tables in a logical order that aligns with the query's conditions. Additionally, double-check the column names and table aliases to ensure they are correct and consistent throughout the query.",
        "ground_truth_sql": "SELECT T1.business_id, T3.closing_time FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE T2.category_name = 'Arts & Entertainment' AND T4.day_of_week = 'Sunday'",
        "difficulty": ""
    },
    {
        "question": "How many female users use ZenFone 5 devices?",
        "hint": "female refers to gender = 'F'; ZenFone 5 refers to device_model = 'ZenFone 5';",
        "error_sql": "SELECT COUNT(T1.device_id) FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T2.gender = 'F' AND T1.device_model = 'ZenFone 5'",
        "compiler_hint": "no such table: device_user",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the tables are joined in the correct order. In this case, the error occurred because the join was done in the wrong order, and the wrong table was used for the join. To avoid this mistake, carefully examine the schema and the relationships between the tables, and make sure to join the tables in the correct order based on the foreign key relationships. Additionally, double-check the table names and column names to ensure they are correct.",
        "ground_truth_sql": "SELECT COUNT(T1.gender) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T2.device_id = T1.device_id WHERE T1.gender = 'F' AND T2.device_model = 'ZenFone 5'",
        "difficulty": ""
    },
    {
        "question": "What is the position coordinate on the page menu of the \"Small Hominy\" dish and how long did it appear?",
        "hint": "position coordinate = xpos, ypos; Small Hominy is a name of dish; how long it appear = SUBTRACT(last_appeared, first_appeared);",
        "error_sql": "SELECT T2.xpos, T2.ypos, T2.last_appeared - T2.first_appeared FROM MenuItem AS T1 INNER JOIN MenuItem AS T2 ON T1.dish_id = T2.dish_id WHERE T1.name = 'Small Hominy'",
        "compiler_hint": "no such table: Dish",
        "reflective_cot": "### Tip: \nWhen joining two tables, carefully examine the column names in the SELECT statement to ensure they are being retrieved from the correct table. In this case, the 'last_appeared' and 'first_appeared' columns should be retrieved from the 'Dish' table (T1), not the 'MenuItem' table (T2), as the 'Dish' table is the one that contains the information about the dish's appearance.",
        "ground_truth_sql": "SELECT T2.xpos, T2.ypos, T1.last_appeared - T1.first_appeared FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Small Hominy'",
        "difficulty": ""
    },
    {
        "question": "What is the full name of client whose email address is emily.garcia43@outlook.com?",
        "hint": "full name refers to first middle last",
        "error_sql": "SELECT first, middle, last FROM ClientInformation WHERE email = 'emily.garcia43@outlook.com'",
        "compiler_hint": "no such table: client",
        "reflective_cot": "### Tip: \nAlways verify the table name in the database schema before writing a SQL query. In this case, the correct table name is not provided, but the error message suggests that the correct table name might be 'ClientInformation' instead of 'client'. The correct query should be written as: SELECT first, middle, last FROM ClientInformation WHERE email = 'emily.garcia43@outlook.com'.",
        "ground_truth_sql": "SELECT first, middle, last FROM client WHERE email = 'emily.garcia43@outlook.com'",
        "difficulty": ""
    },
    {
        "question": "How many rainy days were recorded in Mountain View?",
        "hint": "rainy days refers to events = 'rain'; Mountain View refers to zip_code = 94041;",
        "error_sql": "SELECT COUNT(date) FROM weather WHERE events = 'rain' AND zip_code = '94041'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with data that may have varying cases or formats, it's essential to ensure consistency in the query. In this case, the error SQL query and SQL after reflection were incorrect because they assumed the 'events' column would always be in lowercase or title case, respectively. However, the correct approach is to use a case-insensitive comparison or to standardize the data before querying. Additionally, using the SUM and IIF functions provides a more robust way to count the occurrences of a specific condition, as it allows for more flexibility and accuracy in the query.",
        "ground_truth_sql": "SELECT SUM(IIF(zip_code = 94041 AND events = 'Rain', 1, 0)) FROM weather",
        "difficulty": ""
    },
    {
        "question": "For the Yelp business which had the most number of \"short\" tips, which category does it belong to?",
        "hint": "short tips refers to tip_length = 'short'; most number of short tips refers to MAX(COUNT(tip_length = 'short')); category refers to category_name;",
        "error_sql": "SELECT T3.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE T3.tip_length = 'short' GROUP BY T3.category_name ORDER BY COUNT(T3.tip_length) DESC LIMIT 1",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order is correct and logical. In this case, the correct order is to start with the Categories table, then join Business_Categories, followed by Business, and finally Tips. This order makes sense because we are trying to find the category of a business, so we start with the category and work our way down to the business and its tips. Additionally, when using the COUNT function with a condition, it's better to use the COUNT function with a CASE statement or the SUM function with an IF statement, but in this case, using the COUNT function directly with the WHERE clause is sufficient. However, using the DISTINCT keyword is necessary to avoid duplicate category names in case a business belongs to multiple categories.",
        "ground_truth_sql": "SELECT DISTINCT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Tips AS T4 ON T3.business_id = T4.business_id WHERE T4.tip_length LIKE 'short'",
        "difficulty": ""
    },
    {
        "question": "How many authors drafted the paper \"Subcellular localization of nuclease in barley aleurone\"?",
        "hint": "'Subcellular localization of nuclease in barley aleurone' is the title of paper",
        "error_sql": "SELECT COUNT(T2.AuthorId) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen counting the number of authors for a specific paper, it's essential to consider that multiple authors might have the same name. Therefore, counting distinct names might not provide the accurate count of unique authors. Instead, count the distinct AuthorId, which uniquely identifies each author. The corrected SQL query should be: SELECT COUNT(DISTINCT T2.AuthorId) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.Name) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'",
        "difficulty": ""
    },
    {
        "question": "Give the number of followers for the user who posted the most lists.",
        "hint": "number of followers refers to user_subscriber; posted the most lists refers to MAX(COUNT(list_id))",
        "error_sql": "SELECT MAX(T1.user_subscriber) FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id GROUP BY T1.user_id ORDER BY COUNT(T2.list_id) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, it's essential to carefully read and understand the question, especially the column names and their meanings. In this case, the question asks for the \"number of followers\" which refers to the column \"list_followers\" in the \"lists\" table, not \"user_subscriber\" in the \"lists_users\" table. Additionally, the question asks for the \"user who posted the most lists,\" which means we need to count the number of lists each user has, not the number of movies. Therefore, we should group by the user_id and count the list_id, then order by this count in descending order and limit the result to 1.",
        "ground_truth_sql": "SELECT SUM(T1.list_followers) FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id GROUP BY T1.user_id ORDER BY COUNT(T1.list_id) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the ratio of active and inactive app users of the event ID \"58\"?",
        "hint": "ratio = DIVIDE(SUM(is_active = 1), SUM(is_active = 0)); active refers to is_active = 1; inactive refers to is_active = 0;",
        "error_sql": "SELECT CAST(SUM(IIF(is_active = 1, 1, 0)) AS REAL) / SUM(IIF(is_active = 0, 1, 0)) FROM events AS T1 INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE T1.event_id = \"58\"",
        "compiler_hint": "no such table: app_events",
        "reflective_cot": "### Tip: \nWhen writing SQL queries, be mindful of the data types of the columns. In this case, the event_id column is likely an integer, not a string. Therefore, the value \"58\" should not be enclosed in quotes. Additionally, the CAST to REAL is unnecessary in this case, as the division operation will automatically return a floating-point number.",
        "ground_truth_sql": "SELECT SUM(IIF(is_active = 1, 1, 0)) / SUM(IIF(is_active = 0, 1, 0)) AS per FROM app_events WHERE event_id = 58",
        "difficulty": ""
    },
    {
        "question": "List the student's first and last name that got a C in the course named \"Applied Deep Learning\".",
        "hint": "student's first name refers to f_name; student's last name refers to l_name; got a C refers to grade = 'C';",
        "error_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Applied Deep Learning' AND T2.grade = 'C'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables and filtering data, ensure that the column values used in the WHERE clause are exact matches. In this case, the error was due to a trailing space in the course name 'Applied Deep Learning '. Always verify the data and column values to avoid such mistakes. Additionally, consider using the TRIM() function to remove leading and trailing spaces from column values to prevent similar errors in the future.",
        "ground_truth_sql": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Applied Deep Learning ' AND T2.grade = 'C'",
        "difficulty": ""
    },
    {
        "question": "How many 4-year public institutions are there in the state of Florida? Give all of their names.",
        "hint": "4-year refers to level = '4-year'; public refers to control = 'Public'; names refers to chronname;",
        "error_sql": "SELECT COUNT(T1.unitid), T1.chronname FROM institution AS T1 INNER JOIN state_sector AS T2 ON T1.state = T2.state WHERE T1.level = '4-year' AND T1.control = 'Public' AND T2.state = 'FL'",
        "compiler_hint": "no such table: institution_details",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join condition is correct and that the columns being joined are from the correct tables. In this case, the error was due to joining on the 'state' column which is present in both tables, but the condition for 'level' and 'control' should be applied to the 'state_sector_details' table, not the 'institution_details' table. Additionally, the 'COUNT' function is not necessary when the goal is to retrieve the names of institutions, not the count.",
        "ground_truth_sql": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 WHERE T2.level = '4-year' AND T2.control = 'Public' AND T2.state = 'Florida'",
        "difficulty": ""
    },
    {
        "question": "What is the age of the youngest female user of the app?",
        "hint": "youngest user refers to MIN(age); female refers to gender = 'F';",
        "error_sql": "SELECT MIN(T1.age) FROM user AS T1 INNER JOIN device_user AS T2 ON T1.user_id = T2.user_id WHERE T1.gender = 'F'",
        "compiler_hint": "no such table: gender_age",
        "reflective_cot": "### Tip: \nAlways ensure that the table name in the SQL query matches the actual table name in the database schema. In this case, the correct table name is not provided, but the error message suggests that the table name should be 'user' instead of 'gender_age'. The correct query should be: SELECT MIN(age) FROM user WHERE gender = 'F'.",
        "ground_truth_sql": "SELECT MIN(age) FROM gender_age WHERE gender = 'F'",
        "difficulty": ""
    },
    {
        "question": "Indicate the quantity of Blade products sold.",
        "hint": "Blade' is name of product;",
        "error_sql": "SELECT SUM(T1.Quantity) FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'Blade'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and selecting a column, ensure that the column name and table alias match. In this case, the error was due to selecting `T2.Quantity` instead of `T1.Quantity` in the first query, and then incorrectly changing `SUM(T1.Quantity)` to `SUM(T2.Quantity)` in the second query. The correct approach is to use `SUM(T1.Quantity)` and keep the table alias consistent. Additionally, since we want the total quantity of 'Blade' products sold, we should use `SUM` aggregation function instead of `DISTINCT` which would return multiple rows if there are multiple sales of 'Blade' products.",
        "ground_truth_sql": "SELECT DISTINCT T2.Quantity FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Blade'",
        "difficulty": ""
    },
    {
        "question": "What is the ratio of female users to male users who uses a vivo device?",
        "hint": "ratio = DIVIDE(SUM(gender = 'M' WHERE phone_brand = 'vivo'), SUM(gender = 'F' WHERE phone_brand = 'vivo')); female refers to gender = 'F'; male refers to gender = 'M'; vivo device refers to phone_brand = 'vivo';",
        "error_sql": "SELECT CAST(SUM(IIF(T2.gender = 'M', 1, 0)) AS REAL) / SUM(IIF(T2.gender = 'F', 1, 0)) FROM gender_age AS T2 INNER JOIN phone_brand_device_model2 AS T1 ON T1.device_id = T2.device_id WHERE T1.phone_brand = 'vivo'",
        "compiler_hint": "no such table: phone_brand_device_model2",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the join condition is correct and the tables are joined in the correct order. In this case, the error was due to the incorrect join condition (T2.device_id = T1.device_id instead of T1.device_id = T2.device_id) and the tables were joined in the wrong order (phone_brand_device_model2 was joined with gender_age instead of the other way around). To avoid this mistake, carefully examine the schema of the tables and the join condition to ensure that they are correct. Additionally, consider the logical relationship between the tables and the columns being joined to ensure that the join is performed in the correct order.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "difficulty": ""
    },
    {
        "question": "In which group of islands is Rinjani Mountain located?",
        "hint": "",
        "error_sql": "SELECT T2.Islands FROM mountain AS T1 INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain WHERE T1.Name = 'Rinjani'",
        "compiler_hint": "near \"Group\": syntax error",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names and their aliases are correct and consistent with the actual schema. In this case, the initial error was due to a non-existent table 'mountain AS T1'. The corrected query used the correct table names 'island AS T1', 'mountainOnIsland AS T2', and 'mountain AS T3'. To avoid this mistake, double-check the schema and table names before writing the SQL query.",
        "ground_truth_sql": "SELECT T1.Islands FROM island AS T1 INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Island INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE T3.Name = 'Rinjani'",
        "difficulty": ""
    },
    {
        "question": "How many businesses are with high review count?",
        "hint": "high review count refers to review_count = 'High'",
        "error_sql": "SELECT COUNT(business_id) FROM Businesses WHERE review_count = 'High'",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nAlways verify the exact table and column names from the schema before writing the SQL query. In this case, the correct table name is not provided, but the error message suggests it might be 'Businesses' instead of 'Business'. The correct query should be written as `SELECT COUNT(business_id) FROM Businesses WHERE review_count = 'High'`.",
        "ground_truth_sql": "SELECT COUNT(business_id) FROM Business WHERE review_count LIKE 'High'",
        "difficulty": ""
    },
    {
        "question": "How many disabled students have zero absences?",
        "hint": "zero absences refers to month = 0;",
        "error_sql": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN person AS T2 ON T1.name = T2.name INNER JOIN disabled AS T3 ON T2.name = T3.name WHERE T1.month = 0",
        "compiler_hint": "no such table: disabled",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names are correct and consistent with the actual table names in the database schema. In this case, the correct table name is \"longest_absence_from_school\" (with an \"e\" in \"absence\"), not \"longest_absense_from_school\" (without an \"e\" in \"absense\"). Double-check the table names to avoid such typos.",
        "ground_truth_sql": "SELECT COUNT(T1.name) FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name WHERE T2.month = 0",
        "difficulty": ""
    },
    {
        "question": "Which low income country has a series code of DT.DOD.DECT.CD? Name the country code of it.",
        "hint": "IncomeGroup = 'Low income';",
        "error_sql": "SELECT T1.Code FROM Country AS T1 INNER JOIN Economy AS T2 ON T1.Code = T2.Country INNER JOIN Series AS T3 ON T2.SeriesCode = T3.SeriesCode WHERE T2.IncomeGroup = 'Low income' AND T3.SeriesCode = 'DT.DOD.DECT.CD'",
        "compiler_hint": "no such table: country",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the error was due to using 'Code' instead of 'CountryCode' in the Country table and 'Country' instead of 'Countrycode' in the CountryNotes table. Additionally, verify that the table names and column names are correct and match the schema of the database.",
        "ground_truth_sql": "SELECT T1.CountryCode FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.IncomeGroup = 'Low income' AND T2.Seriescode = 'DT.DOD.DECT.CD'",
        "difficulty": ""
    },
    {
        "question": "What is the inventory ID of Karen Jackson?",
        "hint": "",
        "error_sql": "SELECT inventory_id FROM client WHERE first = 'Karen' AND last = 'Jackson'",
        "compiler_hint": "no such table: ClientInformation",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema. In this case, the error occurred because the table name was incorrect ('ClientInformation' instead of 'customer') and the column names were also incorrect ('first' and 'last' instead of 'first_name' and 'last_name'). Additionally, the query required a join with the 'rental' table to access the 'inventory_id' column. To avoid this mistake, carefully review the schema and verify the table and column names before generating the query.",
        "ground_truth_sql": "SELECT T2.inventory_id FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'KAREN' AND T1.last_name = 'JACKSON'",
        "difficulty": ""
    },
    {
        "question": "How many teams did the team with the most victories in 1915 play against?\nIndicate the name of the team who won the most games in 1915, as well as the names of the opposing team.",
        "hint": "team playing refers to tmID; oppositng team refers to oppID; victories' and 'wins' are synonyms; most victories refers to max(w)",
        "error_sql": "SELECT T1.name, T2.name FROM Teams AS T1 INNER JOIN TeamVsTeam AS T2 ON T1.tmID = T2.tmID INNER JOIN Teams AS T3 ON T2.oppID = T3.tmID WHERE T1.year = 1915 AND T1.W = (SELECT MAX(W) FROM Teams WHERE year = 1915)",
        "compiler_hint": "no such column: T2.name",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that you are joining on the correct columns and that the columns you are selecting exist in the tables you are joining. In this case, the error occurred because the `TeamVsTeam` table does not have a `name` column, but rather `oppID` which is the ID of the opposing team. Additionally, when trying to find the team with the most victories, it's better to use a subquery to find the team ID with the most wins and then join this result with the `TeamVsTeam` table to find the number of teams they played against.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT oppID), T2.tmID, T2.oppID FROM Teams AS T1 INNER JOIN TeamVsTeam AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID WHERE T2.year = 1915 GROUP BY T2.tmID, T2.oppID ORDER BY SUM(T2.W) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Under the category name of \"Coffee & Tea\", mention any 5 business ID , their state and city.",
        "hint": "",
        "error_sql": "SELECT T1.business_id, T1.state, T1.city FROM Businesses AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T3.category_name = 'Coffee & Tea' LIMIT 5",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the order of the tables in the FROM and JOIN clauses matches the order of the joins in the query logic. In this case, the query starts with the Categories table, then joins Business_Categories, and finally joins Business. The original queries started with the Business table, which is incorrect. Always follow the logical order of the joins to avoid mistakes.",
        "ground_truth_sql": "SELECT T2.business_id, T3.state, T3.city FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name = 'Coffee & Tea' LIMIT 5",
        "difficulty": ""
    },
    {
        "question": "List out the phone number of the shipping company of order id 10296.",
        "hint": "shipping company refers to Shippers; phone number refers to Phone",
        "error_sql": "SELECT T2.Phone FROM `Order` AS T1 INNER JOIN Shippers AS T2 ON T1.ShipVia = T2.ShipperID WHERE T1.OrderID = 10296",
        "compiler_hint": "no such table: Orders",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema, and double-check the data values used in the WHERE clause to avoid incorrect results. In this case, the error was due to using the wrong OrderID (10296 instead of 10260). Always verify the data values against the provided schema or sample data to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.Phone FROM Orders AS T1 INNER JOIN Shippers AS T2 ON T1.ShipVia = T2.ShipperID WHERE T1.OrderID = 10260",
        "difficulty": ""
    },
    {
        "question": "Among the cars from Asia, list the IDs of cars that were introduced in 1979.",
        "hint": "from Asia refers to country = 'Japan'; introduced in 1979 refers to model_year = 1979",
        "error_sql": "SELECT car_id FROM Car WHERE country = 'Japan' AND model_year = 1979",
        "compiler_hint": "no such table: Cars",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema. In this case, the error occurred because the table name was incorrect ('Cars' instead of 'production') and the country was not directly compared to 'Japan' but rather to 'Asia' which was then joined with the 'country' table to get the correct origin. Also, the column name for the car ID was incorrect ('car_id' instead of 'ID'). To avoid this mistake, carefully review the schema and ensure that all table and column names are accurate.",
        "ground_truth_sql": "SELECT T1.ID FROM production AS T1 INNER JOIN country AS T2 ON T1.country = T2.origin WHERE T2.country = 'Japan' AND T1.model_year = 1979",
        "difficulty": ""
    },
    {
        "question": "Which different vendor has the most amount of orders? Calculate the total estimated earnings.",
        "hint": "amount of order refers to quantityOrdered; most amount of orders refers to SUM(QuantityOrdered); estimated earnings refers to expected profits; expected profits = SUBTRACT(msrp, buyPrice);",
        "error_sql": "SELECT T1.productVendor, SUM(T1.quantityInStock * T1.MSRP - T1.buyPrice * T1.quantityInStock) FROM products AS T1 INNER JOIN `orderdetails` AS T2 ON T1.productCode = T2.productCode GROUP BY T1.productVendor ORDER BY SUM(T2.quantityOrdered) DESC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the total estimated earnings, avoid multiplying the sum of quantityInStock or MSRP/buyPrice with the sum of quantityOrdered. Instead, calculate the profit per unit (MSRP - buyPrice) and multiply it with the sum of quantityOrdered for each product. Also, use COUNT(T2.quantityOrdered) or COUNT(T2.orderNumber) to get the total number of orders, not SUM(T2.quantityOrdered) which gives the total quantity ordered.",
        "ground_truth_sql": "SELECT DISTINCT T1.productVendor, T1.MSRP - T1.buyPrice FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode GROUP BY T1.productVendor, T1.MSRP, T1.buyPrice ORDER BY COUNT(T2.quantityOrdered) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the players who played 72 games, how many are left-shooters?",
        "hint": "played 72 games refers to GP = 72; left-shooters refers to shoots = 'L';",
        "error_sql": "SELECT COUNT(T1.playerID) FROM players_teams AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T1.GP = 72 AND T2.shoots = 'L'",
        "compiler_hint": "no such table: players",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you accurately identify the relevant tables and their corresponding columns based on the provided schema. In this case, the error occurred because the query referenced a non-existent table 'players' and did not account for the correct table names 'SeasonStatus' and 'PlayerInfo' and their respective columns. To avoid this mistake, carefully review the schema and verify the table and column names before generating the query.",
        "ground_truth_sql": "SELECT COUNT(T2.ELITEID) FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.GP = 72 AND T2.shoots = 'L'",
        "difficulty": ""
    },
    {
        "question": "How many items did Customer#000021159 order? Calculate those items total charges.",
        "hint": "items Customer#000021159 order refer to l_linenumber where c_name = 'Customer#000021159'; SUM(MULTIPLY(MULTIPLY(l_extendedprice, SUBTRACT(1, l_discount)), SUM(1, l_tax))) where c_name = 'Customer#000021159';",
        "error_sql": "SELECT COUNT(T2.l_linenumber), SUM(T2.l_extendedprice * (1 - T2.l_discount) * (1 + T2.l_tax)) FROM customers AS T1 INNER JOIN lineitem AS T2 ON T1.c_custkey = T2.l_custkey WHERE T1.c_name = 'Customer#000021159'",
        "compiler_hint": "no such table: customer",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order and conditions are correct. In this case, the error was due to missing the 'orders' table in the join sequence. To avoid this mistake, carefully analyze the relationships between tables and verify the join conditions. Additionally, when aggregating data, ensure that the GROUP BY clause is correctly applied to the relevant columns, and the COUNT function is applied to the correct column. In this case, the COUNT function should be applied to 'o_orderkey' instead of 'l_linenumber', and the GROUP BY clause should be removed or applied to a different column if not necessary.",
        "ground_truth_sql": "SELECT COUNT(T2.o_orderkey), SUM(T3.l_extendedprice * (1 - T3.l_discount) * (1 + T3.l_tax)) FROM customer AS T1 INNER JOIN orders AS T2 ON T1.c_custkey = T2.o_custkey INNER JOIN lineitem AS T3 ON T2.o_orderkey = T3.l_orderkey WHERE T1.c_name = 'Customer#000021159' GROUP BY T3.l_linenumber",
        "difficulty": ""
    },
    {
        "question": "Indicate the name of the country where Leka Trading supplies Ipoh Coffee product.",
        "hint": "'Leka Trading' is a CompanyName; 'Ipoh Coffee' is a ProductName",
        "error_sql": "SELECT T3.Country FROM Suppliers AS T1 INNER JOIN Products AS T2 ON T1.SupplierID = T2.SupplierID INNER JOIN Countries AS T3 ON T1.CountryID = T3.CountryID WHERE T2.ProductName = 'Ipoh Coffee' AND T1.CompanyName = 'Leka Trading'",
        "compiler_hint": "no such table: Products",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being referenced exists in the joined table. In this case, the error occurred because the 'Country' column was being referenced from the 'Countries' table (T3) instead of the 'Suppliers' table (T2), which already contains the 'Country' information. Always verify the schema and column names to avoid unnecessary joins and incorrect column references.",
        "ground_truth_sql": "SELECT T2.Country FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.ProductName = 'Ipoh Coffee' AND T2.CompanyName = 'Leka Trading'",
        "difficulty": ""
    },
    {
        "question": "How many menus were created for lunch?",
        "hint": "created for lunch refers to event = 'LUNCH';",
        "error_sql": "SELECT COUNT(T1.id) FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE T2.event = 'LUNCH'",
        "compiler_hint": "no such table: Menu",
        "reflective_cot": "### Tip: \nAlways verify the table name in the database schema before writing a SQL query. In this case, the correct table name is 'Menu' but the error message 'no such table: MenuPage' suggests that the query was trying to access a non-existent table 'MenuPage'. However, the actual mistake was in the SQL query itself, not the table name. The correct table name 'Menu' was used in the query, but the query was still incorrect. The mistake was not in the table name, but rather the query was missing the correct join or subquery to get the correct count of menus created for lunch. The correct query is indeed 'SELECT COUNT(*) FROM Menu WHERE event = 'LUNCH'', but the error message was misleading. To avoid this mistake, always verify the table name and the query logic before executing the query.",
        "ground_truth_sql": "SELECT COUNT(*) FROM Menu WHERE event = 'LUNCH'",
        "difficulty": ""
    },
    {
        "question": "What is the active and inactive ratio of the business with the review count of low.",
        "hint": "DIVIDE(COUNT(business_id where review_count = 'Low' and active = 'true'), COUNT(business_id where review_count = 'Low' and active = 'false'));",
        "error_sql": "SELECT CAST(SUM(IIF(review_count = 'Low' AND active = 1, 1, 0)) AS REAL) / SUM(IIF(review_count = 'Low' AND active = 0, 1, 0)) FROM Business",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table name and column names match the actual schema, and the data types of the columns are correctly handled. In this case, the error was due to the incorrect table name 'Business' instead of 'Businesses', and incorrect handling of the 'active' column which is of integer type (0/1) instead of string type ('true'/'false'). Additionally, the WHERE clause should be used to filter the rows before applying the aggregation functions, and the CASE statement should be used instead of IIF for better readability and compatibility with different SQL dialects.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN active = 'true' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN active = 'false' THEN 1 ELSE 0 END) AS radio FROM Business WHERE review_count = 'Low'",
        "difficulty": ""
    },
    {
        "question": "How many American cars have an acceleration time of less than 12 seconds?",
        "hint": "American car refers to country = 'USA'; an acceleration time of less than 12 seconds refers to acceleration < 12",
        "error_sql": "SELECT COUNT(ID) FROM cars WHERE country = 'USA' AND acceleration < 12",
        "compiler_hint": "no such table: production",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the column names used in the SELECT, WHERE, and JOIN clauses match the actual column names in the tables. In this case, the error occurred because the column 'acceleration' is in the 'data' table (T1), not the 'production' table. Also, use COUNT(*) instead of COUNT(T1.ID) to count all rows that match the condition, regardless of whether the ID is NULL or not.",
        "ground_truth_sql": "SELECT COUNT(*) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'USA' AND T1.acceleration < 12",
        "difficulty": ""
    },
    {
        "question": "Provide the price and country origin of the car named Ford Maverick.",
        "hint": "country origin refers to country; Ford Maverick refers to car_name = 'ford maverick'",
        "error_sql": "SELECT T1.price, T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T2.car_name = 'ford maverick'",
        "compiler_hint": "no such table: production",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names and column names match the actual schema. In this case, the error occurred because the table name 'production' was used instead of 'data' for the car_name filter, and the join with 'price' table was missing. To avoid this mistake, carefully review the schema and verify the table and column names before generating the query. Additionally, consider the relationships between tables and ensure that the joins are correct to retrieve the desired information.",
        "ground_truth_sql": "SELECT DISTINCT T1.price, T3.country FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE T4.car_name = 'ford maverick'",
        "difficulty": ""
    },
    {
        "question": "How many of the movies rated 5 are rated by a user between the ages of 25 and 35?",
        "hint": "",
        "error_sql": "SELECT COUNT(T1.movie_id) FROM movie_rating AS T1 INNER JOIN user AS T2 ON T1.user_id = T2.user_id WHERE T1.rating = 5 AND T2.age BETWEEN 25 AND 35",
        "compiler_hint": "no such table: ratings",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema. In this case, the error occurred due to incorrect table and column names. To avoid this mistake, carefully review the schema and verify the table and column names before generating the query. Additionally, pay attention to the error messages, as they often provide valuable information about the incorrect table or column names.",
        "ground_truth_sql": "SELECT COUNT(T1.movieid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 5 AND T2.age BETWEEN 25 AND 35",
        "difficulty": ""
    },
    {
        "question": "What are the titles and genres of the one-act works of Shakespeare?",
        "hint": "one-act works refers to count(Act) = 1; genre refers to GenreType\n",
        "error_sql": "SELECT T1.Title, T1.GenreType FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id GROUP BY T1.Title, T1.GenreType HAVING COUNT(T2.Act) = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen dealing with aggregate functions like COUNT() in SQL, it's essential to consider the context in which they are applied. In this case, the initial query attempted to use COUNT(T2.Act) to identify one-act works, but this approach is incorrect because it counts the number of rows in the chapters table where the Act is present, not the number of distinct Acts per work. The corrected query uses a simple WHERE clause to filter works with only one Act, which is a more accurate approach. To avoid similar mistakes, always carefully evaluate the logic behind your queries and consider the relationships between tables and the data they contain.",
        "ground_truth_sql": "SELECT DISTINCT T1.Title, T1.GenreType FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = 1",
        "difficulty": ""
    },
    {
        "question": "How many of the unemployed students are disabled?",
        "hint": "",
        "error_sql": "SELECT COUNT(T1.name) FROM no_job AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name",
        "compiler_hint": "no such table: unemployed",
        "reflective_cot": "### Tip: \nAlways verify the table names in the database schema before writing SQL queries. In this case, the table name is actually 'no_job' instead of 'unemployed'. The correct SQL query should be: SELECT COUNT(T1.name) FROM no_job AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name",
        "ground_truth_sql": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name",
        "difficulty": ""
    },
    {
        "question": "How many images have less than 15 object samples?",
        "hint": "images refer to IMG_ID; less than 15 object samples refer to COUNT(OBJ_SAMPLE_ID) < 15;",
        "error_sql": "SELECT COUNT(IMG_ID) FROM ( SELECT IMG_ID, COUNT(OBJ_SAMPLE_ID) AS OBJ_SAMPLE_COUNT FROM IMG_OBJ GROUP BY IMG_ID ) WHERE OBJ_SAMPLE_COUNT < 15",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen solving SQL problems, carefully consider the question being asked and the structure of the database. In this case, the question asks for the number of images with less than 15 object samples, but the object samples are not directly comparable to 15. Instead, the question is asking for the count of images where the count of object samples is less than 15. The correct approach is to use the HAVING clause to filter the results after grouping, but in this case, the subquery is unnecessary. The correct solution is to use the COUNT(DISTINCT) function to count the number of images with less than 15 object samples. However, the provided Ground Truth SQL is incorrect as it is comparing OBJ_SAMPLE_ID directly to 15, which is not the correct interpretation of the question. The correct solution would be to use a subquery or a join to count the number of object samples for each image and then filter the results.",
        "ground_truth_sql": "SELECT COUNT(IMG_ID) FROM IMG_OBJ WHERE OBJ_SAMPLE_ID < 15",
        "difficulty": ""
    },
    {
        "question": "How much time do businesses in El Mirage City, AZ State operate in average daily?",
        "hint": "how much time does this business open refers to SUBTRACT(closing_time, opening_time); DIVIDE(SUM(SUBTRACT(closing_time, opening_time)), SUM(Business.business_id))",
        "error_sql": "SELECT CAST(SUM(STRFTIME('%H', T1.closing_time) - STRFTIME('%H', T1.opening_time)) AS REAL) / COUNT(T1.business_id) FROM Business_Categories AS T2 INNER JOIN Business AS T1 ON T2.business_id = T1.business_id WHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip: \nWhen performing date and time operations, be aware of the data types and the specific SQL functions used. In this case, the error was due to incorrect usage of STRFTIME and subtraction of time values. To avoid this mistake, ensure that you understand the data types of the columns involved (e.g., datetime, time, etc.) and use the correct functions for date and time operations. Additionally, verify that the columns are in the correct table, as the initial error was due to referencing a non-existent table. In this case, the correct approach was to simply subtract the opening_time from the closing_time, without using STRFTIME, and to join the Business and Business_Hours tables correctly.",
        "ground_truth_sql": "SELECT SUM(T2.closing_time - T2.opening_time) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of device users in the F27-28 age group who experienced an event on the 3rd of May 2016?",
        "hint": "percentage = MULTIPLY(DIVIDE(SUM(`group` = 'F27-28'), COUNT(device_id)), 1.0); on the 3rd of May 2016 refers to timestamp = '2016-05-03%';",
        "error_sql": "SELECT CAST(SUM(IIF(T2.`group` = 'F27-28', 1, 0)) AS REAL) / COUNT(T1.device_id) * 100 FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE T2.timestamp LIKE '2016-05-03%'",
        "compiler_hint": "no such table: device_user",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined and the correct columns are being used for the join operation. In this case, the error occurred because the 'group' column is in the 'gender_age' table, not the 'user' table, and the 'device_id' column should be joined with the 'events_relevant' table, not the 'events' table. Additionally, the 'timestamp' column should be filtered using the SUBSTR function to extract the date part, rather than using the LIKE operator. Always carefully review the schema and the query to ensure that the correct tables and columns are being used.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.`group` = 'F27-28', 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE SUBSTR(T2.timestamp, 1, 10) = '2016-05-03'",
        "difficulty": ""
    },
    {
        "question": "What is the salary rate per hour that the company paid to the first 5 employees that they hired?",
        "hint": "salary rate per hour refers to Rate; first 5 employees that were hired refers to 5 oldest HireDate;",
        "error_sql": "SELECT Rate FROM EmployeePayHistory ORDER BY RateChangeDate ASC LIMIT 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the salary rate per hour for the first 5 employees hired, it's crucial to join the EmployeePayHistory table with the Employee table to access the HireDate column, which indicates the hiring order. However, the initial query only ordered by RateChangeDate, which doesn't necessarily reflect the hiring order. The corrected query joins the necessary tables and orders by HireDate to accurately retrieve the salary rates for the first 5 employees hired. Additionally, the LIMIT clause should be used with an OFFSET of 0 to ensure the correct results are returned.",
        "ground_truth_sql": "SELECT T1.Rate FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID ORDER BY T2.HireDate ASC LIMIT 0, 5",
        "difficulty": ""
    },
    {
        "question": "What is the full address of the office where the employee who is a sales representative for the customer whose business is located in the city of New York works?",
        "hint": "full address = addressLine1 + addressLine2; NYC is a shortname of New York City.",
        "error_sql": "SELECT T1.addressLine1, T1.addressLine2 FROM offices AS T1 INNER JOIN employees AS T2 ON T1.officeCode = T2.officeCode INNER JOIN customers AS T3 ON T2.employeeNumber = T3.salesRepEmployeeNumber WHERE T3.city = 'New York'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join conditions are correct and the tables are joined in the correct order. Also, verify that the column names and table aliases are correctly referenced in the SELECT and WHERE clauses. In this case, the error was due to incorrect table aliases and join order. Additionally, the city name in the WHERE clause should match the actual value in the database, which is 'NYC' instead of 'New York'. Furthermore, the job title filter 'Sales Rep' was missing in the initial query. To avoid such mistakes, it's essential to carefully review the database schema, table relationships, and data values before writing the SQL query.",
        "ground_truth_sql": "SELECT T2.addressLine1, T2.addressLine2 FROM employees AS T1 INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber INNER JOIN offices AS T3 ON T1.officeCode = T3.officeCode WHERE T2.city = 'NYC' AND T1.jobTitle = 'Sales Rep'",
        "difficulty": ""
    },
    {
        "question": "Which distinct state makes beer that has the least amount of bitterness?",
        "hint": "",
        "error_sql": "SELECT DISTINCT T1.state FROM breweries AS T1 INNER JOIN beers AS T2 ON T1.id = T2.brewery_id ORDER BY T2.ibu ASC LIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen solving SQL problems, especially those involving aggregate functions or subqueries, it's essential to consider the entire query, not just the individual parts. In this case, the initial query and the revised query both failed to correctly identify the state with the least bitter beer because they relied solely on the ORDER BY and LIMIT clauses, which can return incorrect results if there are multiple beers with the same minimum IBU value. To avoid this mistake, use a subquery to find the minimum IBU value and then join this result with the main query to find the corresponding state(s). This approach ensures that all states with the least bitter beer are correctly identified.",
        "ground_truth_sql": "SELECT DISTINCT T2.state, T1.ibu FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T1.ibu IS NOT NULL AND T1.ibu = ( SELECT MIN(ibu) FROM beers )",
        "difficulty": ""
    },
    {
        "question": "When did the earliest complaint start on 2017/3/22?",
        "hint": "earliest complaint refers to oldest ser_start; on 2017/3/22 refers to \"Date received\" = '2017-03-22';",
        "error_sql": "SELECT MIN(T2.ser_start) FROM complaint AS T1 INNER JOIN events AS T2 ON T1.complaint_id = T2.complaint_id WHERE T1.`Date received` = '2017-03-22'",
        "compiler_hint": "no such table: client",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table names and column names match the actual schema of the database. In this case, the error occurred because the query was referencing tables 'client' and 'events', but the correct table name is 'callcenterlogs'. Additionally, the column name 'ser_start' was used instead of 'ser_time'. To avoid this mistake, carefully review the database schema before generating SQL queries.",
        "ground_truth_sql": "SELECT MIN(ser_time) FROM callcenterlogs WHERE `Date received` = '2017-03-22'",
        "difficulty": ""
    },
    {
        "question": "Calculate the percentage of male patients with viral sinusitis condition.",
        "hint": "percentage = MULTIPLY(DIVIDE(COUNT(patients.patient WHERE gender = 'M'), COUNT(patients.patient) WHERE conditions.DESCRIPTION = 'Viral sinusitis (disorder))), 100); male patients refers to gender = 'M'; viral sinusitis condition refers to conditions.DESCRIPTION = 'Viral sinusitis (disorder)';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patient AS T1 INNER JOIN condition AS T2 ON T1.patient_id = T2.patient_id WHERE T2.description = 'Viral sinusitis (disorder)'",
        "compiler_hint": "no such table: patients",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the error message \"no such table: patient\" suggests that the column name in the patients table is not \"patient\", but rather something else (e.g., \"id\", \"patient_id\", etc.). Always verify the column names in the schema before writing the SQL query.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "How many elite users have reviewed Yelp_Business no.1?",
        "hint": "Yelp_Business no.1 refers to business_id = 1",
        "error_sql": "SELECT COUNT(T1.user_id) FROM User AS T1 INNER JOIN Review AS T2 ON T1.user_id = T2.user_id INNER JOIN Elite AS T3 ON T1.user_id = T3.user_id WHERE T2.business_id = 1",
        "compiler_hint": "no such table: Users",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names match exactly with the actual table names in the database schema, including case sensitivity and pluralization. In this case, the error occurred because the table name was 'Reviews' instead of 'Review', and 'Users' instead of 'User'. Always double-check the table names to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T1.user_id) FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id INNER JOIN Reviews AS T3 ON T1.user_id = T3.user_id WHERE T3.business_id = 1",
        "difficulty": ""
    },
    {
        "question": "What is the country location of the employee who handled order id 10257?",
        "hint": "",
        "error_sql": "SELECT T3.Country FROM `Order` AS T1 INNER JOIN Employees AS T2 ON T1.EmployeeID = T2.EmployeeID INNER JOIN Customers AS T3 ON T2.EmployeeID = T3.SalesRepEmployeeNumber WHERE T1.OrderID = 10257",
        "compiler_hint": "no such table: Orders",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being selected (in this case, Country) is from the correct table. Also, verify that the join conditions are correct and that the correct table is being referenced for the filter condition (in this case, OrderID). In this scenario, the Country column is in the Employees table, and the OrderID filter should be applied to the Orders table.",
        "ground_truth_sql": "SELECT T1.Country FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE T2.OrderID = 10257",
        "difficulty": ""
    },
    {
        "question": "Identify the customer, which placed the largest order in terms of value.",
        "hint": "value refers to SUM(UnitPrice * Quantity * SUBTRACT(1, Discount)); the largest order in value refers to MAX(value)",
        "error_sql": "SELECT T1.CustomerID, T1.CompanyName FROM `Customers` AS T1 INNER JOIN `Order Details` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.UnitPrice * T2.Quantity * (1 - T2.Discount) = ( SELECT MAX(T2.UnitPrice * T2.Quantity * (1 - T2.Discount)) FROM `Customers` AS T1 INNER JOIN `Order Details` AS T2 ON T1.CustomerID = T2.CustomerID )",
        "compiler_hint": "no such table: customers",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order and the tables being joined are correct. In this case, the error was due to missing the 'Orders' table in the join, which is necessary to link 'Customers' with 'Order Details'. Additionally, when using aggregate functions like SUM, MAX, etc., ensure that the GROUP BY clause is correctly defined to group the results by the desired column(s), in this case, the CustomerID.",
        "ground_truth_sql": "SELECT T1.CompanyName FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN `Order Details` AS T3 ON T2.OrderID = T3.OrderID GROUP BY T2.CustomerID ORDER BY SUM(T3.UnitPrice * T3.Quantity * (1 - T3.Discount)) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among professors with the highest teachability, how many of their students have high salary?",
        "hint": "highest teachability refers to MAX(teachability); high salary refers to salary = 'high';",
        "error_sql": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.teachingability = (SELECT MAX(teachingability) FROM prof) AND T1.salary = 'high'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen dealing with aggregate functions like MAX, MIN, or AVG, consider whether you need to filter the results based on the aggregate value or if you need to order the results based on the aggregate value. In this case, the goal is to find the count of students with high salary among professors with the highest teachability, which requires ordering the results by teachability in descending order and then limiting the result to the top one, rather than filtering the results based on the maximum teachability value. This is because there could be multiple professors with the same maximum teachability value, and we want to consider all of them.",
        "ground_truth_sql": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T1.salary = 'high' ORDER BY T2.teachingability DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What percentage of sell orders on 04/04/2020 were for the state of New York?",
        "hint": "sales order on 04/04/2020 refers to OrderDate = '4/4/20'; 'New York' is\u00a0 the City Name; percentage = Divide (Sum(OrderNumber where City Name = 'New York'), Count (OrderNumber)) * 100",
        "error_sql": "SELECT CAST(SUM(IIF(T2.`City Name` = 'New York', 1, 0)) AS REAL) * 100 / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T1._StoreID = T2.StoreID WHERE T1.OrderDate = '4/4/20'",
        "compiler_hint": "no such column: T1.City Name",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names referenced in the SELECT, WHERE, and CASE statements match the actual column names in the joined tables. In this case, the error occurred because 'City Name' is not a column in the 'Sales Orders' table, but rather in the 'Store Locations' table. Additionally, when using conditional aggregation, use the standard SQL CASE expression instead of the IIF function, which is specific to certain databases.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.State = 'New York' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T1.OrderDate = '4/4/20'",
        "difficulty": ""
    },
    {
        "question": "How many employees have salary greater than 70000 but fail the inspection?",
        "hint": "salary greater than 70000 refers to salary > 70000; fail the inspection refers to results = 'Fail'",
        "error_sql": "SELECT COUNT(T1.employee_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T1.salary > 70000 AND T2.results = 'Fail'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and counting the number of rows that meet certain conditions, use the DISTINCT keyword to avoid counting duplicate rows. In this case, the error SQL query and SQL after reflection were incorrect because they did not use the DISTINCT keyword, which could lead to incorrect counts if an employee has multiple failed inspections.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.employee_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.results = 'Fail' AND T1.salary > 70000",
        "difficulty": ""
    },
    {
        "question": "How many users, who were a paying subscriber when they rated the movie, gave the movie that was released in 1924 and directed by Erich von Stroheim a rating score of 5?",
        "hint": "Directed by Buster Keaton refers to director_name; released in 1924 refers to movie_release_year = 1924; paying subscriber refers to user_has_payment_method = 1\n\n",
        "error_sql": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T1.user_id = T3.user_id WHERE T2.movie_release_year = 1924 AND T2.director_name = 'Erich von Stroheim' AND T1.rating_score = 5 AND T3.user_has_payment_method = 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the correct table is being referenced for each column. In this case, the `user_has_payment_method` column is being referenced from the wrong table. It should be referenced from the `ratings` table, not the `ratings_users` table. Additionally, the `COUNT` function should be counting the `user_id` from the correct table, which is the `ratings` table. Always double-check the table and column references to avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T2.user_id) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T1.movie_release_year = 1924 AND T1.director_name = 'Erich von Stroheim' AND T2.rating_score = 5 AND T2.user_has_payment_method = 1",
        "difficulty": ""
    },
    {
        "question": "Which supplier supplies the most amount of products?",
        "hint": "supplier refers to SupplierID; most amount refers to max(count(ProductID))",
        "error_sql": "SELECT SupplierID FROM ProductInformation GROUP BY SupplierID ORDER BY COUNT(ProductID) DESC LIMIT 1",
        "compiler_hint": "no such table: Products",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you are referencing the correct table and column names. In this case, the error occurred because the query was referencing 'ProductInformation' which does not exist, and also because it was only returning the SupplierID instead of the CompanyName. To avoid this mistake, carefully review the schema and question to ensure that all referenced tables and columns exist and are correctly named. Additionally, make sure to return the desired information, in this case, the CompanyName of the supplier, not just the SupplierID.",
        "ground_truth_sql": "SELECT T2.CompanyName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID GROUP BY T2.SupplierID, T2.CompanyName ORDER BY COUNT(T1.ProductName) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What are the keywords of the episode which has title as Dangerous Curves?",
        "hint": "",
        "error_sql": "SELECT T2.keywords FROM episodes AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Dangerous Curves'",
        "compiler_hint": "no such table: Episode",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names and column names match the actual schema. In this case, the error was due to joining with the 'Vote' table instead of the 'Keyword' table, and also selecting 'keywords' instead of 'keyword'. To avoid this mistake, double-check the schema and verify the table and column names before generating the SQL query.",
        "ground_truth_sql": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Dangerous Curves';",
        "difficulty": ""
    },
    {
        "question": "Who directed the movie with the most voice actors?",
        "hint": "who directed refers director;",
        "error_sql": "SELECT T1.director FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid INNER JOIN movies2actors AS T3 ON T2.movieid = T3.actor_type = 'voice' GROUP BY T1.director ORDER BY COUNT(T3.actorid) DESC LIMIT 1",
        "compiler_hint": "no such table: movies",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema, and the join conditions are correct. In this case, the mistake was due to incorrect table names (movies2directors) and incorrect join conditions. Additionally, the query should focus on the specific type of actors ('voice') and use the correct table for voice actors. To avoid this mistake, carefully review the schema and ensure that the query accurately reflects the relationships between tables and the specific data being queried.",
        "ground_truth_sql": "SELECT T2.director, COUNT(DISTINCT T1.`voice-actor`) FROM `voice-actors` AS T1 INNER JOIN director AS T2 ON T1.movie = T2.name GROUP BY T2.director ORDER BY COUNT(DISTINCT T1.`voice-actor`) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many right-shooted players have a height of 5'7''?",
        "hint": "right-shooted players refers to shoots = 'R'; height of 5'7'' refers to height_in_inch = '5''7\"';",
        "error_sql": "SELECT COUNT(T1.ELITEID) FROM Player AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch = '5''7\"' AND T1.shoots = 'R'",
        "compiler_hint": "no such table: PlayerInfo",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the error occurred because the column name 'height' in the PlayerInfo table does not exist, it should be 'height_id' instead. Always verify the column names in the schema before writing the SQL query.",
        "ground_truth_sql": "SELECT COUNT(T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch = '5''7\"' AND T1.shoots = 'R'",
        "difficulty": ""
    },
    {
        "question": "Please list the titles of the films that are released in 2006 and have a rental rate of $2.99.",
        "hint": "released in 2006 refers to release_year = 2006; rental rate of $2.99 refers to rental_rate = 2.99",
        "error_sql": "SELECT T1.title FROM film_category AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id WHERE T2.release_year = 2006 AND T2.rental_rate = 2.99",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the joined tables actually exist in the database schema. In this case, the error message \"no such table: film_category\" indicates that the table does not exist, and therefore, the join operation is unnecessary. Always verify the database schema before writing SQL queries to avoid such mistakes.",
        "ground_truth_sql": "SELECT title FROM film WHERE release_year = 2006 AND rental_rate = 2.99",
        "difficulty": ""
    },
    {
        "question": "Give the model year of the heaviest car.",
        "hint": "the heaviest refers to max(weight)",
        "error_sql": "SELECT model_year FROM data ORDER BY weight DESC LIMIT 1",
        "compiler_hint": "no such table: production",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column being ordered or selected is from the correct table. In this case, the weight column is in the 'data' table (T1), not the 'production' table (T2). Always verify the schema and table aliases to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY T1.weight DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What percentage of students are highly satisfied with the Intro to Database 2 course?",
        "hint": "percentage = MULTIPLY(DIVIDE(COUNT(MAX(sat)), (COUNT(student_id))), 1.0); highly satisfied refers to MAX(sat);",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN T2.sat = (SELECT MAX(sat) FROM registration WHERE course_id = T1.course_id) THEN T2.student_id END) AS REAL) / COUNT(T2.student_id) * 1.0 FROM course AS T1 INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE T1.name = 'Intro to Database 2'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that the denominator is the total number of relevant records, not just a count of records in the joined table. In this case, the denominator should be the total number of students who took the 'Intro to Database 2' course, not just the count of student IDs in the joined table. Additionally, consider using subqueries to accurately calculate the total number of relevant records, rather than relying on the joined table.",
        "ground_truth_sql": "SELECT CAST(( SELECT COUNT(*) FROM course WHERE name = 'Intro to Database 2' AND course_id IN ( SELECT course_id FROM registration WHERE sat = ( SELECT MAX(sat) FROM registration ) ) ) AS REAL) * 100  / COUNT(T1.student_id) FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.name = 'Intro to Database 2'",
        "difficulty": ""
    },
    {
        "question": "What kind of preparation is needed for apple juice to make a raspberry-pear couscous cake?",
        "hint": "apple juice is a name of an ingredient; raspberry-pear couscous cake refers to title",
        "error_sql": "SELECT T4.preparation FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T2.ingredient_id = T3.ingredient_id INNER JOIN Quantity AS T4 ON T1.recipe_id = T4.recipe_id WHERE T1.title = 'Raspberry-Pear Couscous Cake' AND T3.name = 'apple juice'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and consistent. In this case, the error was in the join condition between Ingredient and Quantity tables. The correct join condition should be `T3.ingredient_id = T2.ingredient_id` instead of `T2.ingredient_id = T3.ingredient_id`. Additionally, joining Quantity table twice is unnecessary and can lead to incorrect results. Always review the join conditions and table relationships to ensure accuracy.",
        "ground_truth_sql": "SELECT T2.preparation FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.title = 'Raspberry-Pear Couscous Cake' AND T3.name = 'apple juice'",
        "difficulty": ""
    },
    {
        "question": "State the male population for all zip code which were under the Berlin, NH CBSA.",
        "hint": "\"Berlin, NH\" is the CBSA_name",
        "error_sql": "SELECT T1.zip_code, T1.male_population FROM zip_cbsa AS T1 INNER JOIN cbsa AS T2 ON T1.cbsa_name = T2.cbsa_name WHERE T2.cbsa_name = 'Berlin, NH'",
        "compiler_hint": "no such table: zip_data",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and the tables are joined in the correct order. In this case, the error was due to incorrect table names and join conditions. To avoid this mistake, carefully review the schema and ensure that the table names and join conditions match the schema. Additionally, when selecting columns, ensure that only the required columns are selected, and if aggregation is required, use the correct aggregation functions and group by the correct columns. In this case, the correct query only required the male_population column and a group by clause to aggregate the results.",
        "ground_truth_sql": "SELECT T2.male_population FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Berlin, NH' GROUP BY T2.male_population",
        "difficulty": ""
    },
    {
        "question": "What is the total number of game played for players from USA?",
        "hint": "game played refers to GP; from USA refers to birthCountry = 'USA';",
        "error_sql": "SELECT SUM(T1.GP) FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T2.birthCountry = 'USA'",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and performing aggregation operations, ensure that the column being aggregated is from the correct table. In this case, the `GP` column is from the `Scoring` table, not the `Master` table. Additionally, the question asks for the total number of games played, but the correct interpretation is the count of games played, not the sum. Therefore, the correct aggregation function to use is `COUNT`, not `SUM`.",
        "ground_truth_sql": "SELECT COUNT(T2.GP) FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCountry = 'USA'",
        "difficulty": ""
    },
    {
        "question": "Among the countries with more than 3% population growth rate, state the country name in full along with its GDP.",
        "hint": "Population_growth = 3 means 3% population growth rate",
        "error_sql": "SELECT T1.Name, T3.GDP FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE T3.Population_growth > 3",
        "compiler_hint": "no such table: country",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the correct tables are being joined based on the required information. In this case, the error occurred because the 'population' table was not initially joined, and the 'population_growth' column was incorrectly referenced from the 'economy' table. To avoid this mistake, carefully review the schema and required information to ensure that the correct tables are being joined and the correct columns are being referenced.",
        "ground_truth_sql": "SELECT T1.Name, T3.GDP FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE T2.Population_Growth > 3",
        "difficulty": ""
    },
    {
        "question": "How many crimes against society happened in the Wentworth district according to the FBI?",
        "hint": "\"Wentworth\" is the district_name; crime against society refers to crime_against = 'Society\"",
        "error_sql": "SELECT COUNT(T2.report_no) FROM Districts AS T1 INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no WHERE T1.district_name = 'Wentworth' AND T2.crime_against = 'Society'",
        "compiler_hint": "no such table: District",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table names match exactly with the actual table names in the database schema. In this case, the error message \"no such table: Districts\" indicates that the table name should be \"District\" instead of \"Districts\". Additionally, verify that the join conditions and column references are correct to avoid incorrect results. Always double-check the database schema before generating SQL queries.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.crime_against = 'Society' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no WHERE T3.district_name = 'Wentworth'",
        "difficulty": ""
    },
    {
        "question": "List all the order numbers along with its product name for each order under the sales team of 'Douglas Tucker'.",
        "hint": "",
        "error_sql": "SELECT T1.OrderNumber, T4.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T1._SalesTeamID = T2.SalesTeamID INNER JOIN Products AS T4 ON T1._ProductID = T4.ProductID WHERE T2.`Sales Team` = 'Douglas Tucker'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join order and the tables being joined are correct. In this case, the error was due to the incorrect join order and the fact that the Products table was not the primary table being queried. The correct approach is to start with the Products table and then join the Sales Orders and Sales Team tables to it, rather than starting with the Sales Orders table. Additionally, the query should select distinct ProductID and Product Name to avoid duplicates.",
        "ground_truth_sql": "SELECT DISTINCT T1.ProductID, T1.`Product Name` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T3.`Sales Team` = 'Douglas Tucker'",
        "difficulty": ""
    },
    {
        "question": "List all the cities in Sumatra and state the population of each city.",
        "hint": "Sumatra is an island",
        "error_sql": "SELECT T1.city, T2.population FROM island_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN island AS T3 ON T1.island_id = T3.island_id WHERE T3.island_name = 'Sumatra'",
        "compiler_hint": "no such table: city",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join order and aliasing are correct. In this case, the initial error was due to incorrect aliasing and join order. The correct join order should start with the city table, then join with the locatedOn table, and finally with the island table. Additionally, the aliasing should be consistent, with the city table aliased as T1 and the locatedOn and island tables aliased as T2 and T3, respectively. To avoid this mistake, carefully review the schema and ensure that the join order and aliasing are correct before executing the query.",
        "ground_truth_sql": "SELECT T1.Name, T1.Population FROM city AS T1 INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T3.Name = 'Sumatra'",
        "difficulty": ""
    },
    {
        "question": "What is the percentage of historical works that have not fewer than five scenes in the 1500s?",
        "hint": "historical works refers to GenreType = 'history'; have not fewer than five scenes in the 1500s refers to count(Scene) > = 5 and DATE > = 1500 AND DATE < = 1599; percentage = divide(count(works.id) where GenreType = 'history' and count(Scene) > = 5, count(works.id) ) as percentage",
        "error_sql": "SELECT CAST(SUM(IIF(T1.GenreType = 'history' AND T2.Scene >= 5, 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Date >= 1500 AND T1.Date <= 1599",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages or ratios involving aggregate functions (like COUNT, SUM, etc.) across multiple tables, ensure that the aggregation is performed at the correct level. In this case, the error occurred because the COUNT(T2.Scene) was not properly aggregated per work_id before being compared to 5. To avoid this mistake, use subqueries or GROUP BY statements to ensure that aggregations are performed at the correct level, and then use the results of these aggregations in the outer query. Additionally, be mindful of the order of operations and ensure that filters (WHERE clauses) are applied before aggregations to avoid incorrect results.",
        "ground_truth_sql": "SELECT CAST(( SELECT COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.GenreType = 'History' AND T1.DATE BETWEEN 1500 AND 1599 GROUP BY T1.id HAVING COUNT(T2.Scene) >= 5 ) AS REAL) * 100 / COUNT(id) FROM works WHERE GenreType = 'History' AND DATE BETWEEN 1500 AND 1599",
        "difficulty": ""
    },
    {
        "question": "Give the time stamp for event No.887711.",
        "hint": "event no. refers to event_id; event_id = '887711';",
        "error_sql": "SELECT timestamp FROM `events` WHERE event_id = '887711'",
        "compiler_hint": "no such table: events",
        "reflective_cot": "### Tip: \nAlways verify the exact table name from the schema before generating SQL queries. In this case, the correct table name is 'events', not 'event'. The error message 'no such table: events' was misleading, but it should have prompted a double-check of the table name in the schema.",
        "ground_truth_sql": "SELECT timestamp FROM events WHERE event_id = '887711'",
        "difficulty": ""
    },
    {
        "question": "List at least 3 categories with the lowest number of users.",
        "hint": "lowest number of users refers to MIN(COUNT(label_id));",
        "error_sql": "SELECT T1.label_name FROM user_labels AS T1 INNER JOIN labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.label_name ORDER BY COUNT(T1.label_id) ASC LIMIT 3",
        "compiler_hint": "no such table: labels",
        "reflective_cot": "### Tip: \nWhen writing SQL queries, it's essential to carefully consider the relationships between tables and the specific columns being joined. In this case, the error occurred because the query was trying to join `labels` with `user_labels` (which doesn't exist) and then with `app_labels` without considering the correct relationships between the tables. Additionally, the query was grouping by `label_name` or `category` but not considering the actual count of users for each category. To avoid this mistake, take the time to thoroughly review the schema, understand the relationships between tables, and ensure that the query accurately reflects the desired outcome. In this case, the correct query simply joins `label_categories` with `app_labels` and orders by the count of `label_id` without grouping, as the goal is to find the categories with the lowest number of users.",
        "ground_truth_sql": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id ORDER BY T2.label_id LIMIT 3",
        "difficulty": ""
    },
    {
        "question": "Please list the business IDs of all the Yelp_Businesses that are good for kids.",
        "hint": "good for kids refers to attribute_name = 'Good for Kids' and attribute_value = 'true'\n",
        "error_sql": "SELECT T2.business_id FROM Attribute AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name = 'Good for Kids' AND T2.attribute_value = 'true'",
        "compiler_hint": "no such table: Attributes",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that all tables exist and are correctly referenced in the query. In this case, the error message 'no such table: Attribute' indicates that the table name is incorrect. The correct table name is 'Attributes'. Additionally, verify that the join conditions and where clause conditions are correct and necessary. In the Error SQL Query, the join with the 'Business' table (T3) is unnecessary and can be removed.",
        "ground_truth_sql": "SELECT T2.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name LIKE 'Good for Kids' AND T2.attribute_value LIKE 'TRUE'",
        "difficulty": ""
    },
    {
        "question": "Name the suppliers that supply products under the category 'cheeses.'",
        "hint": "suppliers refers to CompanyName; 'cheeses' is a Description",
        "error_sql": "SELECT T2.CompanyName FROM ProductInformation AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID INNER JOIN Category AS T3 ON T1.CategoryID = T3.CategoryID WHERE T3.Description = 'Cheeses'",
        "compiler_hint": "no such table: Products",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the table order in the SQL query matches the logical order of the query. In this case, the query starts by selecting suppliers, so Suppliers should be the first table (T1) in the FROM clause. Additionally, use DISTINCT to avoid duplicate results when selecting non-unique columns like CompanyName.",
        "ground_truth_sql": "SELECT DISTINCT T1.CompanyName FROM Suppliers AS T1 INNER JOIN Products AS T2 ON T1.SupplierID = T2.SupplierID INNER JOIN Categories AS T3 ON T2.CategoryID = T3.CategoryID WHERE T3.Description = 'Cheeses'",
        "difficulty": ""
    },
    {
        "question": "List out student names that enrolled in two schools and two organizations?",
        "hint": "enrolled in two schools refers to COUNT(school) = 2; two organizations refers to COUNT(organ) = 2;",
        "error_sql": "SELECT name FROM (SELECT name, school, organ FROM Enrollments) GROUP BY name HAVING COUNT(DISTINCT school) = 2 AND COUNT(DISTINCT organ) = 2",
        "compiler_hint": "no such table: Student",
        "reflective_cot": "### Tip:\nWhen dealing with complex queries involving multiple tables, ensure that you accurately identify the relationships between tables and use the correct join operations. In this case, the error was due to incorrect use of UNION ALL and GROUP BY, which did not accurately capture the relationships between Enrolled and Enlist tables. Instead, use INNER JOIN to combine the tables based on a common column (name) and then apply the GROUP BY and HAVING clauses to filter the results. Additionally, use COUNT(DISTINCT) to avoid counting duplicate values.",
        "ground_truth_sql": "SELECT T.name FROM ( SELECT T1.name, COUNT(T1.organ) AS num FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name ) T WHERE T.num = 2",
        "difficulty": ""
    },
    {
        "question": "Among all the users with the average ratings of at least 4 and above of all reviews, calculate the percent that have no fans or followers.",
        "hint": "average ratings of at least 4 refers to user_average_stars > = 4; no fans or followers refers to user_fans = 'None'; percentage = divide(count(user_id where user_average_stars > = 4 and user_fans = 'None'), sum(user_id where user_average_stars > = 4))*100%",
        "error_sql": "SELECT CAST(SUM(IIF(user_average_stars >= 4 AND user_fans = 'None', 1, 0)) AS REAL) * 100 / COUNT(user_id) FROM Review WHERE user_average_stars >= 4",
        "compiler_hint": "no such table: Users",
        "reflective_cot": "### Tip: \nWhen using conditional aggregation, it's essential to use the correct syntax. In this case, the initial query used `IIF` which is not a standard SQL function, whereas the correct syntax is `CASE WHEN` as shown in the Ground Truth SQL. Additionally, the condition `user_average_stars >= 4` should be applied in the `WHERE` clause, not within the `CASE` statement. To avoid similar mistakes, always verify the SQL dialect being used and ensure that the syntax is correct for that dialect.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN user_fans = 'None' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(user_id) FROM Users WHERE user_average_stars >= 4",
        "difficulty": ""
    },
    {
        "question": "How many distinct movies in English stars a male actor who acts the best?",
        "hint": "Male actors mean that a_gender = 'M'; isEnglish = 'T' means movies in English",
        "error_sql": "SELECT COUNT(DISTINCT T1.movie_id) FROM actor AS T1 INNER JOIN movie AS T2 ON T1.movie_id = T2.movie_id WHERE T1.a_gender = 'M' AND T2.isEnglish = 'T'",
        "compiler_hint": "no such table: acting",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being counted is from the correct table. In this case, the question asks for the number of distinct movies, but the correct query should count the distinct actorid, not movieid, because the condition \"acts the best\" is related to the actor's quality, not the movie's quality. Additionally, verify the table and column names to avoid errors like \"no such table: actor\".",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T3.isEnglish = 'T' AND T1.a_gender = 'M' AND T1.a_quality = 5",
        "difficulty": ""
    },
    {
        "question": "How many times did Keven Kuhn receive DTaP immunization?",
        "hint": "DTaP immunization refers to immunizations where DESCRIPTION = 'DTaP';",
        "error_sql": "SELECT COUNT DESCRIPTION FROM immunization WHERE DESCRIPTION = 'DTaP' AND PAT_NAME = 'Keven Kuhn'",
        "compiler_hint": "no such table: immunizations",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column being counted is the one that is most relevant to the query's purpose. In this case, counting 'CODE' is more accurate than counting 'DESCRIPTION' because 'CODE' is likely to be unique for each immunization, whereas 'DESCRIPTION' might be the same for multiple immunizations. Additionally, verify the column names and table names to ensure they match the actual schema, and use the correct table alias in the COUNT function.",
        "ground_truth_sql": "SELECT COUNT(T2.CODE) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Keven' AND T1.last = 'Kuhn' AND T2.DESCRIPTION = 'DTaP'",
        "difficulty": ""
    },
    {
        "question": "What is the total amount of tax charged for the order placed by customer 88931 on 7/13/994?",
        "hint": "total amount of tax refers to sum(multiply(multiply(l_extendedprice, subtract(1, l_discount)), add(1, l_tax))); customer 88931 refers to o_custkey = 88931; on 7/13/1994 refers to o_orderdate = '1994-07-13'",
        "error_sql": "SELECT SUM(T1.l_extendedprice * (1 - T1.l_discount) * (1 + T1.l_tax)) FROM orders AS T2 INNER JOIN lineitem AS T1 ON T1.l_orderkey = T2.o_orderkey WHERE T2.o_custkey = 88931 AND T2.o_orderdate = '1994-07-13'",
        "compiler_hint": "no such table: lineitem",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names used in the SELECT, WHERE, and JOIN clauses match the actual column names in the tables. In this case, the error occurred because the column 'l_extendedprice', 'l_discount', and 'l_tax' are from the 'lineitem' table, but in the Error SQL Query, they were referenced from the 'lineitem' table aliased as 'T1', which is incorrect. The correct alias for 'lineitem' is 'T2'. To avoid this mistake, double-check the table aliases and column names to ensure they match the actual table and column names.",
        "ground_truth_sql": "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) * (1 + T2.l_tax)) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_custkey = 88931 AND T1.o_orderdate = '1994-07-13'",
        "difficulty": ""
    },
    {
        "question": "Provide the social security number of the patient with the highest systolic blood pressure.",
        "hint": "social security number refers to ssn; highest systolic blood pressure refers to MAX(observations.VALUE WHERE observations.DESCRIPTION = 'Systolic Blood Pressure');",
        "error_sql": "SELECT T1.ssn FROM patient AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Systolic Blood Pressure' ORDER BY T2.VALUE DESC LIMIT 1",
        "compiler_hint": "no such table: patients",
        "reflective_cot": "### Tip: \nWhen joining two tables, ensure that the column names used in the ON clause match the actual column names in the tables. In this case, the error occurred because the column name in the patients table is actually 'patient', not 'ssn' or any other name. Also, the alias 'T1' and 'T2' should be assigned based on the order of the tables in the FROM and JOIN clauses. In the error SQL query, 'T1' was assigned to 'patients' but in the correct query, 'T1' should be assigned to 'observations' because it is the first table in the FROM clause.",
        "ground_truth_sql": "SELECT T2.ssn FROM observations AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Systolic Blood Pressure' ORDER BY T1.VALUE DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "How many cities have businesses with active life category? Find the percentage of the city where the review count that is low in total review count.",
        "hint": "category refers to category_name; percentage = MULTIPLY(DIVIDE(SUM(category_name = 'Active Life'), SUM(review_count = 'LOW')), 1.0);",
        "error_sql": "SELECT CAST(SUM(CASE WHEN category_name = 'Active Life' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN review_count = 'Low' THEN 1 ELSE 0 END) FROM Business AS T1 INNER JOIN Review AS T2 ON T1.business_id = T2.business_id",
        "compiler_hint": "no such table: Business",
        "reflective_cot": "### Tip:\n\nWhen generating SQL queries, ensure that you accurately interpret the question and understand the relationships between tables. In this case, the error was due to a misunderstanding of the question's requirements and incorrect table joins. To avoid this mistake, carefully read the question and identify the key elements, such as the tables involved, the conditions, and the desired output. Additionally, verify that the joins and conditions are correctly applied to produce the desired results. In this case, the question asked for the number of cities with businesses in the 'Active Life' category and the percentage of cities with a 'Low' review count, which required a more complex query with subqueries and accurate table joins.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.category_name LIKE 'Active Life' THEN 1 ELSE 0 END) AS \"num\" , CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) * 100 / ( SELECT COUNT(T3.review_count) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE T3.review_count LIKE 'Low' ) FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id",
        "difficulty": ""
    },
    {
        "question": "Which two countries share the second highest mountain? Give the country code.",
        "hint": "",
        "error_sql": "SELECT T2.country_code FROM country_mountains AS T1 INNER JOIN countries AS T2 ON T1.country_code = T2.country_code INNER JOIN mountains AS T3 ON T1.mountain_id = T3.mountain_id GROUP BY T2.country_code ORDER BY T3.height DESC LIMIT 2 OFFSET 1",
        "compiler_hint": "no such table: mountains",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join conditions are correct and the tables being joined actually exist in the database. In this case, the error was due to a non-existent table 'country_mountains' and incorrect join conditions. To avoid this mistake, carefully review the database schema and ensure that the tables and columns being referenced actually exist and are correctly named. Additionally, verify that the join conditions are logical and correctly relate the tables being joined.",
        "ground_truth_sql": "SELECT T1.Code FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE T2.Mountain = ( SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1, 1 )",
        "difficulty": ""
    },
    {
        "question": "Among the classic movies, how many movies have a rental rate of less than 1?",
        "hint": "classic movie refers to name = 'Classics'; rental rate of less than 1 refers to rental_rate < 1; movie refers to film_id",
        "error_sql": "SELECT COUNT(T1.film_id) FROM movies AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genres AS T3 ON T2.genre_id = T3.genre_id WHERE T3.name = 'Classics' AND T1.rental_rate < 1",
        "compiler_hint": "no such table: film",
        "reflective_cot": "### Tip: \nWhen joining multiple tables, ensure that the join order and the table aliases are correct. In this case, the error occurred because the join order was incorrect, and the table aliases were not properly assigned. To avoid this mistake, carefully analyze the relationships between the tables and ensure that the join order is logical and consistent with the query's requirements. Additionally, use meaningful table aliases to improve the readability of the query and reduce the likelihood of errors.",
        "ground_truth_sql": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.rental_rate < 1 AND T2.name = 'Classics'",
        "difficulty": ""
    },
    {
        "question": "Which payment method is most comonly used by the schools in the state of Georgia for the payment of donations?",
        "hint": "Georgia refer to school_state = 'GA'\n",
        "error_sql": "SELECT T1.payment_method FROM schools AS T1 INNER JOIN donations AS T2 ON T1.school_id = T2.school_id WHERE T1.school_state = 'GA' GROUP BY T1.payment_method ORDER BY COUNT(T1.payment_method) DESC LIMIT 1",
        "compiler_hint": "no such table: donations",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column used in the WHERE clause is from the correct table. In this case, the error occurred because the WHERE clause was filtering on T1.school_state instead of T2.school_state. Additionally, the GROUP BY clause should group by the column that is being filtered (T2.school_state), not the column being selected (T2.payment_method). Always double-check the table aliases and column references to avoid such mistakes.",
        "ground_truth_sql": "SELECT T1.payment_method FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_state = 'GA' GROUP BY T2.school_state ORDER BY COUNT(T1.payment_method) DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What ingredients does the longest cooking time recipe have?",
        "hint": "the longest cooking time refers to MAX(cook_min)",
        "error_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T2.ingredient_id = T3.ingredient_id WHERE T1.cook_min = ( SELECT MAX(cook_min) FROM Recipe )",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen trying to find the maximum or minimum value of a column and then joining it with other tables to get related data, consider using ORDER BY and LIMIT instead of using a subquery to find the maximum or minimum value. This is because the subquery will return the maximum or minimum value, but it will not guarantee that the joined data is from the same row as the maximum or minimum value. In this case, the subquery returns the maximum cooking time, but the joined data may not be from the recipe with the maximum cooking time. Using ORDER BY and LIMIT ensures that the joined data is from the same row as the maximum or minimum value.",
        "ground_truth_sql": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id ORDER BY T1.cook_min DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Which supplier can provide the most number of \"hot spring dodger dim light\"? Please give the supplier's phone number.",
        "hint": "the most number refers to max(ps_availqty); \"hot spring dodger dim light\" refers to p_name = 'hot spring dodger dim light'; phone number refers to s_phone",
        "error_sql": "SELECT T2.s_phone FROM partsupp AS T1 INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T1.ps_availqty DESC LIMIT 1",
        "compiler_hint": "no such table: part",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that all necessary tables are included in the query. In this case, the initial error was due to missing the 'partsupp' table, which was corrected in the second attempt. However, it's crucial to understand the schema and relationships between tables to avoid such mistakes. Always verify the schema and ensure that the query includes all relevant tables to produce the correct results.",
        "ground_truth_sql": "SELECT T3.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T2.ps_availqty DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "What is the name of the organization which most of the students are enlisted in?",
        "hint": "name of the organization refers to organ; organization which most of the students are enlisted in refers to MAX(COUNT(organ));",
        "error_sql": "SELECT organ FROM Enlistments GROUP BY organ ORDER BY COUNT(organ) DESC LIMIT 1",
        "compiler_hint": "no such table: enlist",
        "reflective_cot": "### Tip:\nWhen using aggregate functions like COUNT() in the ORDER BY clause, it's essential to use a subquery to calculate the count first, and then order the results based on that calculated count. This is because the ORDER BY clause is executed before the aggregate function is calculated, resulting in incorrect ordering. By using a subquery, you ensure that the count is calculated first, and then the results are ordered correctly.",
        "ground_truth_sql": "SELECT organ FROM ( SELECT organ, COUNT(organ) AS num FROM enlist GROUP BY organ ) T ORDER BY T.num DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Calculate the average net profit of bar tools which has ordered quantity exceed 5.",
        "hint": "net profit can be computed as SUBTRACT(Unit Price, Unit Cost); AVG(net profit) where Product Name = 'Bar Tools' and Order Quantity > 5;",
        "error_sql": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.`Unit Price`, 2), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T1.`Unit Cost`, 2), ',', '') AS REAL)) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T1._ProductID = T2.ProductID WHERE T2.`Product Name` = 'Bar Tools' AND T1.`Order Quantity` > 5",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average of a value, make sure to use the SUM function to add up all the values and then divide by the COUNT of rows, rather than using the AVG function directly on the calculated values. This is because AVG function may not work correctly with calculated values, especially when the values are not numeric. Additionally, be careful when using string manipulation functions like REPLACE, SUBSTR, and CAST, as they can be error-prone and may not work as expected. Always test your queries thoroughly to ensure they produce the correct results.",
        "ground_truth_sql": "SELECT SUM(REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')) / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T2.`Product Name` = 'Bar Tools' AND T1.`Order Quantity` > 5",
        "difficulty": ""
    },
    {
        "question": "How much taller is David Bornhammar than Pauli Levokari in centimeters?",
        "hint": "how much taller = SUBTRACT(SUM(height_in_cm WHERE PlayerName = 'David Bornhammar'), SUM(height_in_cm WHERE PlayerName = 'Pauli Levokari')); height in centimeters refers to height_in_cm;",
        "error_sql": "SELECT (SUM(CASE WHEN PlayerName = 'David Bornhammar' THEN height_in_cm ELSE 0 END) - SUM(CASE WHEN PlayerName = 'Pauli Levokari' THEN height_in_cm ELSE 0 END)) FROM player",
        "compiler_hint": "no such table: players",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you accurately identify the tables involved and their relationships. In this case, the error was due to not joining the correct tables (`PlayerInfo` and `height_info`) and not using the correct column names. To avoid this mistake, carefully review the schema and column descriptions before generating the query. Additionally, consider breaking down complex queries into simpler sub-queries, as seen in the Ground Truth SQL, to improve readability and accuracy.",
        "ground_truth_sql": "SELECT ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'David Bornhammar' ) - ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'Pauli Levokari' )",
        "difficulty": ""
    },
    {
        "question": "Among the menu pages on which the dish \"Paysanne Soup\" had appeared, how many of them had a stable price for the dish?",
        "hint": "Paysanne Soup is a name of dish; stable price refers to highest_price is null;",
        "error_sql": "SELECT COUNT(T2.menu_page_id) FROM dishes AS T1 INNER JOIN menu_items AS T2 ON T1.dish_id = T2.dish_id WHERE T1.name = 'Paysanne Soup' AND T2.highest_price IS NULL",
        "compiler_hint": "no such table: menu_pages",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the column names and table names match the actual schema. In this case, the error was due to incorrect table and column names. The correct table names are 'Dish' and 'MenuItem', and the correct column name for the highest price is in the 'Dish' table, not the 'MenuItem' table. Additionally, the COUNT function is not suitable for this query as it counts the number of rows, whereas the SUM function with a CASE statement is needed to count the number of menu pages where the dish 'Paysanne Soup' has a stable price.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.name = 'Paysanne Soup' THEN 1 ELSE 0 END) FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.highest_price IS NULL",
        "difficulty": ""
    },
    {
        "question": "Calculate the average number of disabled female students enrolled in UCI.",
        "hint": "average = DIVIDE(SUM(disabled.name who are not in male.name WHERE school = 'uci'), COUNT(enrolled.name)); female students refers to disabled.name who are NOT in male.name; UCI refers to school = 'uci';",
        "error_sql": "SELECT CAST(SUM(CASE WHEN T1.name NOT IN (SELECT name FROM male) THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.name) FROM Enrollments AS T1 INNER JOIN Disabled AS T2 ON T1.name = T2.name WHERE T1.school = 'uci'",
        "compiler_hint": "no such table: enrolled",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that the join conditions are correct and consider all relevant tables that may affect the result. In this case, the `person` table was missing, which contains the gender information, and a `LEFT JOIN` with the `male` table was necessary to correctly identify female students. Additionally, the `IIF` function is more suitable for this scenario than `CASE WHEN` because it allows for more complex conditions.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.school = 'uci' AND T4.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN person AS T3 ON T1.name = T3.name LEFT JOIN male AS T4 ON T3.name = T4.name",
        "difficulty": ""
    },
    {
        "question": "List down the author ID of authors with a name of \"Peter\".",
        "hint": "\"Peter\" is the name of author",
        "error_sql": "SELECT Id FROM Author WHERE Name = 'Peter'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, it's essential to consider the relationships between tables and the specific table that contains the desired information. In this case, the `Author` table contains the author's name, but the `PaperAuthor` table contains the author's ID in relation to a specific paper. However, the `PaperAuthor` table also contains the author's name, which is not necessarily the same as the author's name in the `Author` table. To get the correct author ID, we should query the `Author` table directly, not the `PaperAuthor` table. The correct query should be `SELECT Id FROM Author WHERE Name = 'Peter'`. The mistake was made by querying the `PaperAuthor` table instead of the `Author` table. To avoid this mistake in the future, always carefully consider the relationships between tables and the specific table that contains the desired information.",
        "ground_truth_sql": "SELECT AuthorId FROM PaperAuthor WHERE Name = 'Peter'",
        "difficulty": ""
    },
    {
        "question": "State the name of menu with the longest full height.",
        "hint": "longest full height refers to MAX(full_height);",
        "error_sql": "SELECT T1.name FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.menu_page_id ORDER BY T2.full_height DESC LIMIT 1",
        "compiler_hint": "no such table: menu",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that you accurately identify the relevant tables and their relationships. In this case, the error occurred because the initial query referenced a non-existent table 'menu' and the second query, although referencing the correct tables, did not accurately represent the relationship between 'MenuPage' and 'Menu'. To avoid this mistake, carefully review the schema to identify the correct tables and their relationships, and ensure that the query accurately reflects these relationships.",
        "ground_truth_sql": "SELECT T2.name FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id ORDER BY T1.full_height DESC LIMIT 1",
        "difficulty": ""
    },
    {
        "question": "Among the patients with viral sinusitis condition, which patient's gender is most affected? Provide the number for each respectively.",
        "hint": "viral sinusitis condition refers to conditions.DESCRIPTION = 'Viral sinusitis (disorder)'; gender that is most affected refers to MAX(COUNT(gender WHERE conditions.DESCRIPTION = 'Viral sinusitis (disorder)'));",
        "error_sql": "SELECT T1.gender, COUNT(T1.gender) FROM patient AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)' GROUP BY T1.gender",
        "compiler_hint": "no such table: patients",
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the column names used in the ON clause match exactly with the column names in the respective tables. In this case, the error message \"no such table: patient\" indicates that the column name in the patients table is not \"patient\" but rather something else (likely \"PATIENT_ID\" or similar). Additionally, when counting occurrences of specific values, consider using SUM with CASE statements instead of COUNT with GROUP BY to get the desired results.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END), SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "difficulty": ""
    },
    {
        "question": "Which flight carrier operator flies from Atlantic City to Fort Lauderdale?",
        "hint": "flight carrier operator refers to OP_CARRIER_AIRLINE_ID; from Atlantic City refers to ORIGIN = 'ACY'; to Fort Lauderdale refers to DEST = 'FLL';",
        "error_sql": "SELECT OP_CARRIER_AIRLINE_ID FROM ontime WHERE ORIGIN = 'ACY' AND DEST = 'FLL'",
        "compiler_hint": "no such table: flights",
        "reflective_cot": "### Tip: \nWhen joining tables, ensure that the join condition is correct and that the columns used in the WHERE clause are from the correct table. Additionally, consider the need for aggregation (e.g., GROUP BY) when retrieving data from multiple tables, especially if the query is expected to return a single value or a distinct set of values. In this case, the initial query was incorrect because it did not join the Airlines table with the Air Carriers table, and the second query was incorrect because it did not include the GROUP BY clause to ensure that only distinct carrier descriptions were returned.",
        "ground_truth_sql": "SELECT T2.Description FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T1.ORIGIN = 'ACY' AND T1.DEST = 'FLL' GROUP BY T2.Description",
        "difficulty": ""
    },
    {
        "question": "What is the first name of the driver who transported shipment id 1028?",
        "hint": "shipment id 1028 refers to ship_id = 1028",
        "error_sql": "SELECT T1.first_name FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id WHERE T2.ship_id = 1028",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen joining two tables and selecting columns, ensure that the table alias used in the SELECT statement matches the table alias used in the JOIN clause. In this case, the error occurred because the SELECT statement used T1 for the driver table, but the JOIN clause used T2 for the driver table. To avoid this mistake, double-check that the table aliases are consistent throughout the query. Additionally, when selecting columns, consider selecting all relevant columns (e.g., first_name and last_name) to provide more complete information.",
        "ground_truth_sql": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = 1028",
        "difficulty": ""
    },
    {
        "question": "How many awards had been held in 2009?",
        "hint": "had been held in 2009 refers to year = 2009",
        "error_sql": "SELECT COUNT(*) FROM award WHERE year = 2009",
        "compiler_hint": "no such table: awards",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema exactly, including case sensitivity. In this case, the correct table name is 'Award' (with a capital 'A'), not 'awards'. Additionally, verify the data type of the columns to use the correct functions, such as SUBSTR for string data types.",
        "ground_truth_sql": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009';",
        "difficulty": ""
    },
    {
        "question": "How many trains are running west?",
        "hint": "west is a direction",
        "error_sql": "SELECT COUNT(*) FROM train_direction AS T1 INNER JOIN train AS T2 ON T1.train_id = T2.train_id WHERE T1.direction = 'west'",
        "compiler_hint": "no such table: train",
        "reflective_cot": "### Tip: \nAlways verify the table and column names in the database schema before generating SQL queries. In this case, the correct table name is 'trains' (plural) instead of 'train', and the correct column name is 'direction' which exists in the 'trains' table.",
        "ground_truth_sql": "SELECT COUNT(id) FROM trains WHERE direction = 'west'",
        "difficulty": ""
    },
    {
        "question": "What is the release title of the single that was released by Ron Hunt in 1979 that was downloaded 239 times?",
        "hint": "release title refers to groupName; Ron Hunt is an artist; groupYear = 1979; releaseType = 'single'; downloaded 239 times refer to totalSnatched = 239;",
        "error_sql": "SELECT T1.groupName FROM artists AS T1 INNER JOIN releases AS T2 ON T1.artist_id = T2.artist_id WHERE T1.artistName = 'Ron Hunt' AND T2.groupYear = 1979 AND T2.releaseType = 'single' AND T2.totalSnatched = 239",
        "compiler_hint": "no such table: groups",
        "reflective_cot": "### Tip: \nWhen generating SQL queries, ensure that the table and column names match the actual schema. In this case, the error occurred because the table 'artists' did not exist, and the correct table was 'torrents'. Additionally, the 'artist' column in the 'torrents' table contains the full artist name, not just the individual artist's name. To avoid this mistake, carefully review the schema and ensure that the query accurately reflects the table and column names, as well as the data they contain.",
        "ground_truth_sql": "SELECT groupName FROM torrents WHERE artist LIKE 'ron hunt & ronnie g & the sm crew' AND groupYear = 1979 AND releaseType LIKE 'single' AND totalSnatched = 239",
        "difficulty": ""
    },
    {
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "hint": "Eligible free rate for K-12 = `Free Meal Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda County'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the correct column names and understand the data types involved in your calculations. Additionally, when calculating percentages or ratios, remember to explicitly check for division by zero by filtering out any rows where the denominator is zero before performing calculations. This helps to prevent runtime errors and ensures accurate results.",
        "ground_truth_sql": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "hint": "Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT `School Name`, (`Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`) AS Eligible_Free_Rate \nFROM frpm \nWHERE `School Type` = 'continuation' \nORDER BY Eligible_Free_Rate \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nMake sure to verify the criteria used for filtering the data. In the first query, check if the condition for the `School Type` was specified correctly, and confirm the calculations used in SELECT statements are valid by explicitly handling any potential division by zero cases. Always compare against ground truth values to ensure logical consistency in criteria and calculations.",
        "ground_truth_sql": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "hint": "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm",
        "error_sql": "SELECT DISTINCT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 AND T2.County = 'Fresno County Office of Education'",
        "compiler_hint": "no such column: T1.Zip",
        "reflective_cot": "### Tip:\nAlways verify the specific column names and their sources in the tables involved in your SQL query. In this case, the Zip code was in the `schools` table, not the `frpm` table, leading to the initial incorrect query. Carefully checking the schema before writing queries can help avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
        "difficulty": "simple"
    },
    {
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "hint": "Charter schools refers to `Charter School (Y/N)` = 1 in the frpm",
        "error_sql": "SELECT T1.Phone FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Charter School (Y/N)` = 1 AND T1.OpenDate > '2000-01-01'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the conditions and relationships specified in your SQL queries, especially when filtering on specific attributes. Ensure that all relevant columns from the correct tables are included in the WHERE clause, and verify you\u2019re using the right columns when performing joins. In this case, it was necessary to filter on the `Charter Funding Type` to identify \"Directly funded\" charter schools, which was overlooked initially. Consider reviewing the data schema and requirements thoroughly before constructing your SQL queries.",
        "ground_truth_sql": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM satscores AS S INNER JOIN schools AS Sch ON S.cds = Sch.CDSCode WHERE S.AvgScrMath > 560 AND Sch.FundingType = 'Charter';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the schema structure and the specific column names for accuracy. In particular, ensure you're checking the correct table for relevant fields, such as funding types and how they are labeled. If you encounter errors during the query process, take extra attention to review field names in related tables and examine any potential types or terms that may differ from expectations (like \"Charter\" vs. \"Charter School\").",
        "ground_truth_sql": "SELECT COUNT(T2.`School Code`) FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath > 560 AND T2.`Charter Funding Type` = 'Directly funded'",
        "difficulty": "simple"
    },
    {
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "hint": "",
        "error_sql": "SELECT F.`FRPM Count (Ages 5-17)` FROM frpm AS F INNER JOIN satscores AS S ON F.CDSCode = S.cds WHERE S.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve records based on a condition that involves finding a maximum or minimum value, ensure that the structure of your query allows for proper alignment of the results. Instead of using equality to match the max value directly, consider using an ordering and limiting approach (e.g., `ORDER BY ... LIMIT 1`). This ensures you get the top result without potential issues of duplicate maximum values.",
        "ground_truth_sql": "SELECT T2.`FRPM Count (Ages 5-17)` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrRead DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "hint": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT MAX((F.`Free Meal Count (Ages 5-17)` / F.`Enrollment (Ages 5-17)`) * 100) \nFROM satscores AS S \nINNER JOIN frpm AS F ON S.cds = F.CDSCode \nWHERE (S.NumGE1500 * 1.0 / S.NumTstTakr) > 0.3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to explicitly cast your columns to the appropriate data type when performing calculations, particularly when dealing with divisions that may lead to integer division. Moreover, check that denominator values are valid (i.e., not zero) to avoid runtime errors or incorrect results. Use `CAST` or `COALESCE` as needed to maintain numerical precision and avoid potential division by zero errors.",
        "ground_truth_sql": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "difficulty": "moderate"
    },
    {
        "question": "Which active district has the highest average score in Reading?",
        "hint": "",
        "error_sql": "SELECT D.District, AVG(S.AvgScrRead) AS AvgReadScore \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nINNER JOIN (SELECT DISTINCT District FROM schools WHERE StatusType = 'Active') AS D ON Sch.District = D.District \nGROUP BY D.District \nORDER BY AvgReadScore DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that you clearly understand what each part of the query is doing. Specifically, when filtering with conditions (like `StatusType = 'Active'`), make sure to include those conditions in the main selection rather than in a nested subquery, unless necessary. Maintaining clarity with direct joins and appropriate conditions ensures that you avoid logical errors in aggregations and grouping. Also, always double-check whether you are referencing the correct tables and columns relevant to the data you want to extract.",
        "ground_truth_sql": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM schools AS Sch INNER JOIN satscores AS S ON Sch.CDSCode = S.cds WHERE Sch.County = 'Alameda' AND S.NumTstTakr < 100;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the specific conditions and attributes required in the query against the schema before executing it. For instance, pay attention to additional filters such as the `StatusType` (in this case, checking for 'Merged') which can significantly influence the result set. Using the correct filtering criteria is essential for obtaining accurate results.",
        "ground_truth_sql": "SELECT COUNT(T1.CDSCode) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Merged' AND T2.NumTstTakr < 100 AND T1.County = 'Lake'",
        "difficulty": "simple"
    },
    {
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "hint": "Valid charter number means the number is not null",
        "error_sql": "SELECT Sch.CharterNum \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE S.AvgScrWrite > 499 AND Sch.CharterNum IS NOT NULL \nORDER BY S.AvgScrWrite DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to select all necessary columns in your final output. In your case, including `AvgScrWrite` and a ranking function would have provided the complete information you needed to satisfy the requirements of the query. Additionally, it\u2019s important to think critically about the context of your query \u2014 if a ranking or specific calculations are required, don't forget those functions in your SELECT statement.",
        "ground_truth_sql": "SELECT CharterNum, AvgScrWrite, RANK() OVER (ORDER BY AvgScrWrite DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrWrite > 499 AND CharterNum is not null",
        "difficulty": "simple"
    },
    {
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM schools AS Sch INNER JOIN satscores AS S ON Sch.CDSCode = S.cds WHERE Sch.County = 'Fresno' AND S.NumTstTakr <= 250;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you fully understand the schema and data constraints before writing your SQL queries. Pay attention to the table that contains the relevant fields for your condition. In this case, you did not use the appropriate table (`frpm`) to check the `Charter Funding Type` and `County Name`, leading to an incomplete query. Always double-check which table contains specific attributes you need to filter by to avoid missing critical information.",
        "ground_truth_sql": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
        "difficulty": "simple"
    },
    {
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM schools WHERE County = 'Amador' AND \"Low Grade\" = '9' AND \"High Grade\" = '12';",
        "compiler_hint": "no such column: Low Grade",
        "reflective_cot": "### Tip:\nAlways ensure that you are querying the correct tables for the required columns. In this case, `Low Grade` and `High Grade` were in the `frpm` table, not the `schools` table. Using proper JOIN statements helps in correctly linking related data from multiple tables. Ensure you know where each piece of data resides in the schema to prevent referencing nonexistent columns.",
        "ground_truth_sql": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
        "difficulty": "simple"
    },
    {
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "hint": "",
        "error_sql": "SELECT Sch.School FROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE Sch.County = 'Contra Costa' \nORDER BY S.NumTstTakr DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the specific columns and values used in the filtering conditions, such as `County`, `District`, and other relevant fields. Ensure you are referencing the correct columns from the appropriate tables. Additionally, be cautious about how you reference names particularly; if a name needs to be specified, check if it should be from a specific table or if there's a need for an additional condition to clarify the query.",
        "ground_truth_sql": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "hint": "Diffrence in enrollement = `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT Sch.School, Sch.MailStreet \nFROM frpm AS F \nINNER JOIN schools AS Sch ON F.CDSCode = Sch.CDSCode \nWHERE ABS(F.`Enrollment (K-12)` - F.`Enrollment (Ages 5-17)`) > 30;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen comparing values in SQL for differences, ensure that the calculation is properly structured. For example, if you are checking for a difference greater than a threshold, it may not be necessary to use the `ABS` function if you are only interested in one specific direction (e.g., `Enrollment (K-12) > Enrollment (Ages 5-17) + 30`). By focusing on the specific conditions, you can simplify your query and avoid potential logical errors. Always double-check your conditions and calculations to ensure they align with your intended logic.",
        "ground_truth_sql": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "difficulty": "moderate"
    },
    {
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "hint": "Percent eligible for free meals = Free Meal Count (K-12) / Total (Enrollment (K-12)",
        "error_sql": "SELECT Sch.School FROM schools AS Sch \nINNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE (F.`Free Meal Count (K-12)` / F.`Enrollment (K-12)`) > 0.1 AND S.NumTstTakr > 0 AND S.AvgScrRead + S.AvgScrMath + S.AvgScrWrite >= 1500;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure the accuracy of your JOIN conditions and the syntax for aggregating values in your WHERE clause. Additionally, validate column names and ensure the logic used for calculations is correctly implemented, including considering data types and possible divisions by zero. Testing smaller parts of the query step-by-step can help identify issues early on.",
        "ground_truth_sql": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "difficulty": "moderate"
    },
    {
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "hint": "Average of average math = sum(average math scores) / count(schools).",
        "error_sql": "SELECT Sch.FundingType \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE Sch.County = 'Riverside' \nGROUP BY Sch.CDSCode \nHAVING AVG(S.AvgScrMath) > 400;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen performing calculations or aggregations involving averages, ensure that you are correctly applying the aggregation to the necessary dataset before grouping. In the initial queries, the aggregation was done per school without correctly accounting for the total average math scores across all records for Riverside schools. Always double-check that the logic of your grouping aligns with the requirement of averaging or summing specific fields, and ensure you're including the right join conditions to access necessary related data.",
        "ground_truth_sql": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "difficulty": "moderate"
    },
    {
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "hint": "Full communication address should include Street, City, State and zip code if any.",
        "error_sql": "SELECT Sch.School, Sch.Street || ', ' || Sch.City || ', ' || Sch.State || ' ' || Sch.Zip AS FullAddress \nFROM schools AS Sch \nJOIN frpm AS Fr ON Sch.CDSCode = Fr.CDSCode \nWHERE Fr.`County Name` = 'Monterey' \n  AND Fr.`FRPM Count (Ages 5-17)` > 800 \n  AND Fr.`School Type` = 'High School';",
        "compiler_hint": "near \"Type\": syntax error",
        "reflective_cot": "### Tip:\nAlways verify the exact column names and their data types in the schema before forming queries. In particular, ensure to match the naming conventions, such as singular vs. plural forms and case sensitivity, and carefully check for any constraints in your `WHERE` clauses, especially when filtering on categorical variables like `School Type`. Additionally, consider looking for variations of standard terms (e.g., \"High School\" vs. \"High Schools (Public)\") to ensure that you're accurately capturing all relevant data.",
        "ground_truth_sql": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "hint": "Communication number refers to phone number.",
        "error_sql": "SELECT Sch.School, S.AvgScrWrite, Sch.Phone \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE (Sch.OpenDate > '1991-01-01' OR Sch.ClosedDate < '2000-01-01');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that date comparisons are correctly formatted and take into account the data types being used in the database fields. When working with dates, using appropriate functions (like `strftime` for SQLite) can help extract year parts for comparisons. Additionally, double-check whether `LEFT JOIN` or `INNER JOIN` is appropriate based on whether you need to include rows from one table without corresponding entries in the second table.",
        "ground_truth_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "difficulty": "moderate"
    },
    {
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "hint": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "error_sql": "SELECT F.`School Name`, S.`DOCType` \nFROM frpm AS F \nINNER JOIN schools AS S ON F.CDSCode = S.CDSCode \nWHERE (F.`Enrollment (K-12)` - F.`Enrollment (Ages 5-17)`) > \n    (SELECT AVG(F1.`Enrollment (K-12)` - F1.`Enrollment (Ages 5-17)`) \n     FROM frpm AS F1 \n     WHERE F1.`District Type` = 'Locally Funded');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're filtering for the correct conditions before calculating averages or performing comparisons. In your initial queries, the condition for `District Type` was used instead of the appropriate `FundingType`, which caused a mismatch with the requirement of selecting locally funded schools. Always double-check the specific field names and logical conditions relevant to your query's context to avoid such oversights.",
        "ground_truth_sql": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "difficulty": "challenging"
    },
    {
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "hint": "K-12 refers to students in grades 1 through 12.",
        "error_sql": "SELECT Sch.City, F.`Enrollment (K-12)` \nFROM frpm AS F \nINNER JOIN schools AS Sch ON F.CDSCode = Sch.CDSCode \nORDER BY F.`Enrollment (K-12)` ASC \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:  \nWhen trying to analyze data that is aggregated by groups (e.g., cities in this case), make sure to use aggregation functions (like `SUM`) and the `GROUP BY` clause appropriately. Simply ordering by an individual attribute (like enrollment per school) without grouping will not yield the correct result, as it doesn't consider the total enrollment across all schools within a city. Always think about the overall dataset you're trying to analyze and ensure that your aggregation aligns with the query's objective.",
        "ground_truth_sql": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "hint": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
        "error_sql": "SELECT `FRPM Count (K-12)` / `Enrollment (K-12)` AS EligibleFreeReducedRate, Sch.NCESSchool \nFROM frpm AS F \nINNER JOIN schools AS Sch ON F.CDSCode = Sch.CDSCode \nWHERE Sch.StatusType = '66' \nORDER BY `FRPM Count (K-12)` DESC \nLIMIT 5;",
        "compiler_hint": "no such column: Ownership Code",
        "reflective_cot": "### Tip:\nAlways verify the names of the columns you are referencing in your SQL query, including checking for any possible spelling errors or discrepancies in naming conventions. Additionally, ensure that you are using the right attributes or conditions that correspond to the data you intend to filter by, such as ownership codes or categorical classifications. Use database documentation or schema descriptions as a guide to avoid misidentifying columns and to confirm the correct usage of JOINs and WHERE clauses.",
        "ground_truth_sql": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "hint": "",
        "error_sql": "SELECT s.Website, s.School \nFROM schools s \nJOIN frpm f ON s.CDSCode = f.CDSCode \nWHERE f.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check if any columns used in filtering conditions should have specific non-null checks, such as ensuring the website field is not null when retrieving data. Additionally, be aware of column names and their aliases in relation to the correct tables, as they can lead to confusion when combining data from multiple sources.",
        "ground_truth_sql": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "hint": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
        "error_sql": "SELECT AdmFName1 || ' ' || AdmLName1 AS FullName FROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE S.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores) \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to include all relevant fields in the SELECT statement to retrieve all necessary administrator names at once. Multiple administrators should be included in the result set, not just the first one. Instead of filtering with a single name after the aggregation, utilize an ORDER BY clause to sort the results based on the desired condition (e.g., highest scores) and then limit the results to get the top entry.",
        "ground_truth_sql": "SELECT T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "hint": "Execellence Rate = NumGE1500 / NumTstTakr; complete address has Street, City, State, Zip code",
        "error_sql": "SELECT Sch.MailStreet, Sch.City, Sch.Zip, Sch.State \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE S.NumTstTakr > 0 \nORDER BY (S.NumGE1500 * 1.0 / S.NumTstTakr) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you explicitly specify the correct field names from the respective tables and verify data types in your SQL calculations. In your initial query, you didn't cast `NumGE1500` to a more suitable type, which could lead to unexpected results. When performing calculations, especially divisions, it's crucial to use a type that ensures precision (like REAL) and to confirm that the columns being referenced exist in the tables you are joining.",
        "ground_truth_sql": "SELECT T2.Street, T2.City, T2.State, T2.Zip FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "hint": "Fresno Unified is a name of district;",
        "error_sql": "SELECT Sch.Phone FROM schools AS Sch INNER JOIN satscores AS S ON Sch.CDSCode = S.cds WHERE Sch.District = 'Fresno Unified' ORDER BY S.AvgScrRead ASC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you account for potential NULL values in the columns being used for sorting or filtering. In this case, the original query did not exclude records with NULL average scores in reading, which could lead to inaccurate results. Use conditional filters like `IS NOT NULL` to avoid such issues.",
        "ground_truth_sql": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "hint": "Exclusively virtual refers to Virtual = 'F'; respective counties means PARTITION BY County",
        "error_sql": "SELECT Sch.School \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nWHERE Sch.Virtual = 'F' \nAND S.NumTstTakr > 0 \nAND (S.AvgScrRead, Sch.County) IN (\n    SELECT S2.AvgScrRead, Sch2.County \n    FROM schools AS Sch2 \n    INNER JOIN satscores AS S2 ON Sch2.CDSCode = S2.cds \n    WHERE Sch2.Virtual = 'F' \n    AND S2.NumTstTakr > 0 \n    ORDER BY S2.AvgScrRead DESC \n    LIMIT 5\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to rank values within groups (like counties), utilizing window functions (e.g., RANK() or ROW_NUMBER()) is often more efficient and straightforward than attempting to order and limit results in subqueries. When specifying rankings, remember to include the proper syntax for partitioning the data based on the grouping criteria. This avoids complications with nested queries and ensures accurate results.",
        "ground_truth_sql": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "difficulty": "simple"
    },
    {
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "hint": "Average score for all subjects can be computed by AvgScrMath + AvgScrRead + AvgScrWrite",
        "error_sql": "SELECT Sch.County, (S.AvgScrMath + S.AvgScrRead + S.AvgScrWrite) / 3 AS AvgScore \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nORDER BY (S.AvgScrMath + S.AvgScrRead + S.AvgScrWrite) / 3 ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nBe cautious when determining which fields to select and calculate in your SQL queries. Ensure that you are only including non-nullable relationships and conditions in your calculations. Additionally, always validate if the fields involved in mathematical operations can contain null values, as they can lead to unexpected results. Use explicit checks (like `IS NOT NULL`) to avoid including nulls, which can skew your averages.",
        "ground_truth_sql": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "hint": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
        "error_sql": "SELECT Sch.State, SUM(F.`Enrollment (K-12)`) AS TotalEnrollment\nFROM frpm AS F\nINNER JOIN schools AS Sch ON F.CDSCode = Sch.CDSCode\nWHERE Sch.DOC = 31\nGROUP BY Sch.State\nORDER BY TotalEnrollment DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're selecting the correct column for aggregation, such as using `Enrollment (K-12)` directly rather than summing it without ensuring it's for the specific grouping required. Additionally, make sure to consider the correct context of the query, whether it's for individual schools or states, to avoid misinterpretation of which data to group and order. Always reference your SQL structure against the requirements and expected results clearly before executing.",
        "ground_truth_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "hint": "Elementary School District refers to DOC = 52; Unified School District refers to DOC = 54.",
        "error_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE County = 'Orange' AND DOC = '54') * 1.0 / \n    (SELECT COUNT(*) FROM schools WHERE County = 'Orange' AND DOC = '52') AS Ratio;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you filter records based on the specific conditions required for your analysis, such as checking for a particular status (e.g., 'Merged') in this case. Using aggregate functions like `SUM` with conditional logic (`CASE WHEN`) can help you focus on relevant subsets of data, rather than just counting overall records without context.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "difficulty": "moderate"
    },
    {
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "hint": "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType.",
        "error_sql": "SELECT County, School, ClosedDate \nFROM schools \nWHERE StatusType = 'Closed' \nORDER BY ClosedDate DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your queries are not only retrieving the necessary data but also filtering and grouping correctly to answer the specific question asked. In this case, using a subquery to find the county with the most closed schools was essential, as simply selecting and ordering the results would not provide the correct context or result needed to identify that county. Additionally, make sure to include any relevant DISTINCT clauses if needed to avoid duplicates in your final results.",
        "ground_truth_sql": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "In which mailing street address can you find the school that has the lowest average score in reading? Also give the school's name.",
        "hint": "",
        "error_sql": "SELECT Sch.MailStreet, Sch.School \nFROM schools AS Sch \nINNER JOIN satscores AS S ON Sch.CDSCode = S.cds \nORDER BY S.AvgScrRead ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nAlways ensure that you explicitly check for `NULL` values in the relevant columns when performing aggregate operations or sorting. In this case, since average scores may contain `NULL` values, we need to filter them out first to avoid incorrectly including unscored records in your results.",
        "ground_truth_sql": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "How many test takers are there at the school/s whose mailing city address is in Fresno?",
        "hint": "",
        "error_sql": "SELECT SUM(S.NumTstTakr) FROM satscores AS S INNER JOIN schools AS Sch ON S.cds = Sch.CDSCode WHERE Sch.MailCity = 'Fresno';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen you want to aggregate data, ensure that you select the appropriate fields and use aggregation functions on the correct columns. In cases where you want to sum a column, make sure you only select that aggregated value and avoid including non-aggregated fields in the SELECT clause unless you're also using a GROUP BY statement. Always verify that you're returning the intended results based on the query structure.",
        "ground_truth_sql": "SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'",
        "difficulty": "simple"
    },
    {
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin city?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND MailCity = 'San Joaquin' AND StatusType = 'active';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to check the exact column names and their specifications in the database schema before formulating your queries. In this case, the original query mistakenly used `MailCity` instead of `City`, and the status value was mistakenly set to 'active' instead of 'Active'. Always refer to the schema for accurate casing and naming conventions.",
        "ground_truth_sql": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "difficulty": "simple"
    },
    {
        "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
        "hint": "Chartered schools refer to Charter = 1 in the table schools; Full name refers to first name, last name",
        "error_sql": "SELECT Sch.School, Sch.City, Sch.AdmFName1 || ' ' || Sch.AdmLName1 AS AdminName \nFROM schools AS Sch \nWHERE Sch.Charter = 1 AND Sch.CharterNum = '00D2';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check your SQL syntax and the usage of string concatenation. In SQL, especially in some databases, the concatenation operator may differ (e.g., using `||` vs. `+` or `CONCAT()`). Additionally, ensure you select all required columns explicitly and avoid assuming column aliases will be sufficient if not specified correctly.",
        "ground_truth_sql": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
        "difficulty": "simple"
    },
    {
        "question": "What is the ratio in percentage of Santa Clara County schools that are locally funded compared to all other types of charter school funding?",
        "hint": "Ratio in percentage = (count(locally funded schools in Santa Clara) / count(all funding type schools in Santa Clara) * 100%",
        "error_sql": "SELECT \n    (SELECT COUNT(*) FROM schools WHERE County = 'Santa Clara' AND FundingType = 'Locally Funded') * 100.0 / \n    (SELECT COUNT(*) FROM schools WHERE County = 'Santa Clara') AS Percentage;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nMake sure to clearly define the conditions for counting schools of specific funding types, especially when dealing with multiple categories. Ensure that aggregations and conditions are applied correctly to distinguish between different groups, such as \"locally funded\" vs. \"all other types.\" Use conditional counting within a single query to avoid confusion and ensure the counts are accurate relative to the context (e.g., only counting charter schools).",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN FundingType != 'Locally funded' THEN 1 ELSE 0 END) FROM schools WHERE County = 'Santa Clara' AND Charter = 1",
        "difficulty": "moderate"
    },
    {
        "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
        "hint": "Directly funded schools refers to FundingType = 'Directly Funded'",
        "error_sql": "SELECT COUNT(*) FROM schools WHERE County = 'Stanislaus' AND FundingType = 'Directly Funded' AND OpenDate BETWEEN '2000-01-01' AND '2005-12-31';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the conditions used in your SQL queries match exactly with the expected values in the database, including case sensitivity. For instance, in your queries, \"Directly Funded\" should match the exact casing of the value in the database, which was identified as \"Directly funded\" in the ground truth SQL. Using consistent string matching and considering potential variations in case or extra spaces can help avoid such issues.",
        "ground_truth_sql": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
        "difficulty": "simple"
    },
    {
        "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) FROM schools WHERE County = 'San Francisco' AND OpenDate BETWEEN '1989-01-01' AND '1989-12-31' AND DOC = 'Community College District';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to verify the specific criteria needed for your SQL query, such as the correct field names and conditions, especially when using date functions or filters. In your case, distinguishing between `Opened` and `Closed` dates and ensuring to check the correct `DOCType` instead of just `DOC` could help avoid confusion. Utilizing functions like `strftime()` for date manipulation and checking the complete context of conditions can improve the accuracy of your queries.",
        "ground_truth_sql": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
        "difficulty": "simple"
    },
    {
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "hint": "Youth Authority Facilities (CEA) refers to SOC = 11; 1980s = years between 1980 and 1989",
        "error_sql": "SELECT County, COUNT(*) AS ClosureCount \nFROM schools \nWHERE SOC = '11' AND ClosedDate BETWEEN '1980-01-01' AND '1989-12-31' \nGROUP BY County \nORDER BY ClosureCount DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that the columns you are using in your query correspond to the conditions specified in your requirements. Pay attention to any mandatory attributes in the original dataset, such as `StatusType`, which was crucial for identifying valid closure records. Additionally, ensure you properly handle data types, especially when comparing dates; using `strftime` can help correctly interpret date ranges in SQL queries.",
        "ground_truth_sql": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "hint": "",
        "error_sql": "SELECT StatusType, COUNT(*) \nFROM schools \nWHERE County = 'Alpine' AND DOC = '36' \nGROUP BY StatusType;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, it's crucial to ensure you're using the correct filter conditions and understand the specific requirements of the question. In this case, the focus was on \"District Community Day Schools\" which have a specific `SOC` (Standard Occupational Code). Ensure to include all relevant filters (like `SOC`) in your WHERE clause to avoid missing out on the intended dataset, and always double-check the definitions and criteria used in your database schema to ensure alignment with your query intentions.",
        "ground_truth_sql": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "difficulty": "simple"
    },
    {
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "hint": "When magent is equal to 0 in the database, it means ths school doesn't offer a magnet program.",
        "error_sql": "SELECT `District Code` FROM schools WHERE Magnet = 0 AND City = 'Fresno';",
        "compiler_hint": "no such column: District_Code",
        "reflective_cot": "### Tip:\nAlways verify the column names you are querying against the correct table structure. If you're unsure about the relationships between tables, consider using `JOIN` operations to connect them based on their foreign key constraints. This helps ensure you're accessing the correct data while considering the relationships between entities in your SQL queries.",
        "ground_truth_sql": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "difficulty": "simple"
    },
    {
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "hint": "State Special School means EdOpsCode = 'SSS'",
        "error_sql": "SELECT SUM(`Enrollment (Ages 5-17)`) FROM frpm WHERE `School Type` = 'State Special School' AND `Academic Year` = '2014-15' AND `County Name` = 'Fremont';",
        "compiler_hint": "no such column: EdOpsCode",
        "reflective_cot": "### Tip:\nAlways ensure you understand the table relationships and join conditions necessary to access all relevant data. Before assuming a column exists in one table, check the schema of related tables for the correct column. Additionally, verify that you are correctly filtering conditions based on the desired attributes from the appropriate table, especially when multiple tables are involved.",
        "ground_truth_sql": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "difficulty": "moderate"
    },
    {
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "hint": "",
        "error_sql": "SELECT `FRPM Count (Ages 5-17)` \nFROM frpm \nWHERE CDSCode = (SELECT CDSCode FROM schools WHERE `MailStreet` = 'PO Box 1040' AND `School Type` = 'Youth Authority School');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're using the correct filtering criteria for your SQL queries. In your original query, you were looking for a match using `School Type`, but the final valid SQL used `SOCType` with a specific value (`Youth Authority Facilities`). It's crucial to review the database schema and the required conditions to make sure you're referencing the correct columns and values. Double-checking the field names and their intended purpose can help avoid such errors.",
        "ground_truth_sql": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "difficulty": "simple"
    },
    {
        "question": "What is the lowest grade for the District Special Education Consortia School with National Center for Educational Statistics school district identification number of 0613360?",
        "hint": "District Special Education Consortia School refers to EdOpsCode = 'SPECON'.",
        "error_sql": "SELECT `Low Grade` FROM schools WHERE NCESDist = '0613360' AND EdOpsCode = 'SPECON';",
        "compiler_hint": "no such column: Low Grade",
        "reflective_cot": "### Tip:\nAlways ensure to join the correct tables and use the right column names in your queries. In this case, `Low Grade` was in the `frpm` table but was incorrectly referenced in the `schools` table. Before running a query, double-check the schema to confirm the location of each data point you intend to retrieve and ensure that your joins are properly set up to access related data from multiple tables.",
        "ground_truth_sql": "SELECT MIN(T1.`Low Grade`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.NCESDist = '0613360' AND T2.EdOpsCode = 'SPECON'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "hint": "",
        "error_sql": "SELECT [School Name] \nFROM frpm \nWHERE [NSLP Provision Status] = 'Breakfast Provision 2' AND [County Code] = '37';",
        "compiler_hint": "no such column: NSLP Provision Status",
        "reflective_cot": "### Tip:\nWhen writing SQL queries, ensure that you are referencing the correct table for each column. If a column is present in a different table, use a JOIN to connect the tables appropriately. Always double-check column names and their respective tables to avoid \"no such column\" errors. Moreover, pay attention to case sensitivity and formatting issues, such as using backticks or square brackets correctly for column names.",
        "ground_truth_sql": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "difficulty": "simple"
    },
    {
        "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
        "hint": "High school can be represented as EILCode = 'HS'",
        "error_sql": "SELECT Sch.City \nFROM schools AS Sch \nINNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode \nWHERE Sch.County = 'Merced' \nAND Sch.EILCode = 'HS' \nAND F.`Low Grade` = '9' \nAND F.`High Grade` = '12' \nAND F.`NSLP Provision Status` = '2';",
        "compiler_hint": "no such column: Sch.LowGrade",
        "reflective_cot": "### Tip:\nWhen querying for specific fields, ensure that you're referencing the correct table for each column, especially when column names exist in multiple tables. Always check that the fields you are using in your WHERE clause come from the appropriate tables as per your JOIN conditions. It's helpful to clearly distinguish each table's fields in your SQL query to avoid confusion.",
        "ground_truth_sql": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
        "difficulty": "moderate"
    },
    {
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "hint": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
        "error_sql": "SELECT Sch.School, (F.`FRPM Count (Ages 5-17)` / F.`Enrollment (Ages 5-17)`) * 100 AS PercentEligibleFRPM \nFROM schools AS Sch \nINNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode \nWHERE Sch.County = 'Los Angeles' \nAND F.`Low Grade` = 'K' \nAND F.`High Grade` = '9';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the exact format of the data you are querying, especially for fields related to categorical data like grade levels. Use the correct field for conditions, ensuring you reference the established conventions in the database schema, such as using a dedicated field like `GSserved` for grade spans, rather than relying on low and high grade fields which may contain different representations.",
        "ground_truth_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the most common type of grade span served in the city of Adelanto?",
        "hint": "",
        "error_sql": "SELECT GSserved, COUNT(*) AS count FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY count DESC LIMIT 1;",
        "compiler_hint": "no such column: Low Grade",
        "reflective_cot": "### Tip:\nAlways ensure to check the exact names of the columns in your database schema. A common pitfall is assuming the presence of columns that do not exist or mistyping their names. Use a schema reference while writing queries to avoid confusion and errors related to column names.",
        "ground_truth_sql": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "hint": "'Does not offer physical building' means Virtual = F in the database.",
        "error_sql": "SELECT \n    COUNT(*) AS SchoolCount, \n    County \nFROM \n    schools \nWHERE \n    Virtual = 'F' AND \n    County IN ('San Diego', 'Santa Barbara') \nGROUP BY \n    County \nORDER BY \n    SchoolCount DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the syntax and logic of your SQL queries, particularly when using aggregate functions and conditions. Ensure you correctly utilize the `COUNT()` function; specifying the correct column (or wildcard) is essential. Additionally, when filtering, be cautious with the conditions and how they relate to the grouping columns. Testing individual components of your query can help pinpoint issues before final execution.",
        "ground_truth_sql": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
        "hint": "",
        "error_sql": "SELECT Sch.School, Sch.Latitude, F.`School Type` \nFROM schools AS Sch \nINNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode \nORDER BY Sch.Latitude DESC \nLIMIT 1;",
        "compiler_hint": "no such column: Sch.SchoolType",
        "reflective_cot": "### Tip:\nAlways double-check the column names from all involved tables in your SQL queries. Make sure you reference the correct column names and their respective tables, especially when using aliases. If an error indicates a \"no such column,\" it often means either a typo or a misunderstanding of which table contains that column. Reviewing the schema before writing your query can help avoid these mistakes.",
        "ground_truth_sql": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.Latitude DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "hint": "State of California refers to state = 'CA'",
        "error_sql": "SELECT Sch.City, Sch.`Low Grade`, Sch.School \nFROM schools AS Sch \nWHERE Sch.State = 'CA' \nORDER BY Sch.Latitude ASC \nLIMIT 1;",
        "compiler_hint": "no such column: Sch.Low Grade",
        "reflective_cot": "### Tip:\nAlways ensure that you are referencing column names accurately and consider the relationships between tables when querying data. If a required column is in another table, utilize the correct JOIN statements to access it. Reviewing the table schema thoroughly before writing your query can help identify where to find the necessary data.",
        "ground_truth_sql": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the grade span offered in the school with the highest longitude?",
        "hint": "the highest longitude refers to the school with the maximum absolute longitude value.",
        "error_sql": "SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1;",
        "compiler_hint": "no such column: LowGrade",
        "reflective_cot": "### Tip:\nAlways double-check the column names in your SELECT statements against the schema definition to ensure they are correct. It\u2019s easy to overlook small discrepancies or column names that may not exist, leading to errors. Additionally, understanding the data structure and contents of the tables will help in writing accurate queries.",
        "ground_truth_sql": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "hint": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'",
        "error_sql": "SELECT COUNT(*) \nFROM schools \nWHERE Magnet = 1 AND (`Low Grade` = 'K' AND `High Grade` = '8') AND `Educational Option Type` = 'Multiple Provision Types';\n\nSELECT City, COUNT(*) AS SchoolCount \nFROM schools \nWHERE `Low Grade` = 'K' AND `High Grade` = '8' \nGROUP BY City;",
        "compiler_hint": "no such column: Low Grade",
        "reflective_cot": "### Tip:\nAlways ensure that you are referencing the correct tables and their respective columns in your SQL queries, especially when multiple tables are involved. Use INNER JOIN clauses to combine tables and target the necessary fields from both to avoid referencing an incorrect or non-existing column. Review the schema thoroughly for relationships between tables, and validate column availability before drafting your queries.",
        "ground_truth_sql": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "difficulty": "challenging"
    },
    {
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "hint": "",
        "error_sql": "SELECT AdmFName1, District, COUNT(*) as NameCount \nFROM schools \nGROUP BY AdmFName1, District \nORDER BY NameCount DESC \nLIMIT 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nTo avoid similar mistakes in the future, ensure that your query aggregates data in a way that reflects the requirements of the task. In this case, using `GROUP BY` without subquerying to identify the top names led to incorrect results. Consider breaking down the query into parts, especially for ranking or filtering tasks, to verify that you're selecting the desired subset of data accurately. Additionally, always double-check that your `GROUP BY` clause matches the intent of your aggregation and any subsequent JOIN operations.",
        "ground_truth_sql": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "difficulty": "simple"
    },
    {
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "hint": "Percent (%) Eligible Free (K-12) = `Free Meal Count (K-12)` / `Enrollment (K-12)` * 100%",
        "error_sql": "SELECT F.`Percent (%) Eligible Free (K-12)`, Sch.District AS DistrictCode \nFROM schools AS Sch \nINNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode \nWHERE Sch.AdmFName1 = 'Alusine';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways calculate derived values (like percentages) within the SQL query itself rather than relying on pre-calculated columns if those calculations are not guaranteed to be accurate or present. This ensures that you're getting the most accurate results based on the raw data available in your tables.",
        "ground_truth_sql": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
        "hint": "",
        "error_sql": "SELECT Sch.AdmLName1, Sch.District, Sch.County, Sch.School \nFROM schools AS Sch \nWHERE Sch.CharterNum = '40';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you check for the correct formatting of values in your SQL queries, especially for strings and numeric types. In this case, the Charter number was formatted as '40' but should have matched the actual stored format of '0040'. Always verify the data type and formatting in the database schema when constructing queries.",
        "ground_truth_sql": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
        "difficulty": "simple"
    },
    {
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "hint": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
        "error_sql": "SELECT AdmEmail1, AdmEmail2, AdmEmail3 \nFROM schools \nWHERE County = 'San Bernardino' \n  AND District = 'San Bernardino City Unified' \n  AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' \n  AND (SOC = '62' OR DOC = '54');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, always ensure that you are joining the relevant tables properly and including all necessary conditions to retrieve the correct records. In this case, ensure that the city is specified correctly and that you are using the correct attributes for joining the tables. Additionally, always verify that your filters align with your query requirements, particularly with specific codes or identifiers used in your WHERE clauses.",
        "ground_truth_sql": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "difficulty": "challenging"
    },
    {
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "hint": "A3 contains the data of region; 'POPLATEK PO OBRATU' represents for 'issuance after transaction'.",
        "error_sql": "SELECT COUNT(DISTINCT A.account_id) \nFROM account AS A \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE D.A3 = 'East Bohemia' AND A.frequency = 'POPLATEK PO OBRATU';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are referencing the correct column names and values for filtering conditions. Double-check that you're using the appropriate attributes (like `frequency` vs. `type`) and make sure to maintain consistency in case sensitivity when comparing string values (e.g., 'East Bohemia' vs. 'east Bohemia'). This will help avoid logical errors in your queries.",
        "ground_truth_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "difficulty": "moderate"
    },
    {
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "hint": "A3 contains the data of region",
        "error_sql": "SELECT COUNT(DISTINCT T1.account_id) \nFROM account AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T2.A3 = 'Prague' \nAND T1.account_id IN (SELECT account_id FROM loan WHERE status = 'eligible');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries involving multiple tables, always verify if you are filtering correctly after joining the necessary tables. Pay special attention to the criteria you are applying, ensuring you're not inadvertently excluding valid entries. In this case, utilizing the correct conditions and checking the point of inclusion for filtered results would have helped. Always consider whether you want to count distinct accounts only from the loan table or include those relationships more broadly.",
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "difficulty": "simple"
    },
    {
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "hint": "A12 refers to unemploymant rate 1995; A13 refers to unemploymant rate 1996",
        "error_sql": "SELECT CASE \n           WHEN (SELECT A12 FROM district) > (SELECT A13 FROM district) THEN '1995 has higher unemployment ratio' \n           ELSE '1996 has higher unemployment ratio' \n       END AS Higher_Year",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen comparing averages from multiple rows in SQL, always ensure you use aggregation functions correctly and avoid unnecessary subqueries. Instead of checking individual values, compute the average directly using the `AVG` function on the entire column. Additionally, make sure to check for nulls and zero values in the right context to avoid potential errors in your calculations. It's essential to think about whether you're dealing with overall averages or individual values when formulating your query logic.",
        "ground_truth_sql": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
        "difficulty": "simple"
    },
    {
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "hint": "Male means that gender = 'M'; A3 refers to region; A11 pertains to average salary.",
        "error_sql": "SELECT COUNT(DISTINCT c.client_id) \nFROM client AS c \nJOIN district AS d ON c.district_id = d.district_id \nWHERE c.gender = 'M' AND d.A3 = 'North Bohemia' AND d.A11 > 8000;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that string literals are compared with the correct case, as SQL string comparisons can be case-sensitive depending on the database settings. In this case, \"North Bohemia\" should match the case in the database, which may require checking for the correct capitalization (e.g., \"north Bohemia\"). To avoid similar mistakes in the future, consider using functions like `LOWER()` or `UPPER()` to perform case-insensitive comparisons.",
        "ground_truth_sql": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "difficulty": "moderate"
    },
    {
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "hint": "Female means gender = 'F'; A11 refers to average salary; Gap = highest average salary - lowest average salary; If the person A's birthdate > B's birthdate, it means that person B is order than person A.",
        "error_sql": "SELECT a.account_id, (SELECT MAX(d.A11) FROM district d JOIN client c ON d.district_id = c.district_id WHERE c.gender = 'F') - (SELECT MIN(d.A11) FROM district d JOIN client c ON d.district_id = c.district_id WHERE c.gender = 'F' AND c.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F')) AS salary_gap\nFROM account a\nJOIN client c ON a.district_id = c.district_id\nJOIN district d ON d.district_id = c.district_id\nWHERE c.gender = 'F' AND c.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F')\nORDER BY d.A11 ASC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you clearly understand the requirements of the query and validate the logic step-by-step. Break down complex queries into smaller parts and test them individually. Moreover, pay close attention to aggregate functions and their context; ensure that they apply correctly to the intended dataset. Carefully use subqueries and ensure they're returning the expected results before integrating them into the main query.",
        "ground_truth_sql": "SELECT T1.account_id , ( SELECT MAX(A11) - MIN(A11) FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "hint": "If the person A's birthdate < B's birthdate, it means that person B is younger than person A; A11 refers to average salary",
        "error_sql": "SELECT DISTINCT a.account_id \nFROM account AS a \nJOIN client AS c ON a.district_id = c.district_id \nJOIN district AS d ON c.district_id = d.district_id \nWHERE c.birth_date = (SELECT MIN(birth_date) FROM client) \nAND d.A11 = (SELECT MAX(A11) FROM district);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you carefully analyze the logical relationships between tables and the conditions applied in subqueries. Also, be cautious with aggregate functions and the context they apply to, as they can greatly affect the results. Always validate that your filter criteria align with the intended data selection, especially when dealing with multiple layers of conditions and joins.",
        "ground_truth_sql": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "difficulty": "moderate"
    },
    {
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "hint": "'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT COUNT(*) FROM disp AS T1 INNER JOIN card AS T2 ON T1.disp_id = T2.card_id WHERE T2.type = 'Owner' AND T1.account_id IN (SELECT account_id FROM account WHERE frequency = 'POPLATEK TYDNE')",
        "compiler_hint": "no such column: T2.frequency",
        "reflective_cot": "### Tip:\nAlways ensure that you clearly understand the relationships between tables and the correct keys to join on. Double-check the column names in the joined tables and ensure you reference them correctly. Use aliases judiciously and verify that the right conditions are applied in the `WHERE` clause based on the table being queried.",
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "difficulty": "simple"
    },
    {
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "hint": "'POPLATEK PO OBRATU' stands for issuance after transaction",
        "error_sql": "SELECT DISTINCT T1.client_id FROM disp AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.operation = 'Disponent' AND T1.type = 'POPLATEK PO OBRATU'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you verify the logical conditions and table references in your SQL queries against the actual requirements and schema. Double-check the columns you're filtering on and make sure they match what is specified in the question. Additionally, consider whether you are joining the correct tables and using the proper aliases for clarity. When in doubt, review the data relationships carefully before constructing the SQL statement.",
        "ground_truth_sql": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
        "difficulty": "simple"
    },
    {
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "hint": "'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT account_id FROM loan WHERE date BETWEEN '1997-01-01' AND '1997-12-31' AND amount = (SELECT MIN(amount) FROM loan WHERE date BETWEEN '1997-01-01' AND '1997-12-31') AND account_id IN (SELECT account_id FROM disp WHERE type = 'POPLATEK TYDNE');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering data based on specific criteria, ensure that you understand the relationships between the tables and the necessary joins to retrieve the required information. In your case, you needed to join the `loan` table with the `account` table to properly filter accounts by their issuance type. Familiarize yourself with SQL JOIN operations and their applications to ensure that you get the right results when querying data across multiple tables.",
        "ground_truth_sql": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "hint": "",
        "error_sql": "SELECT account_id FROM account WHERE date BETWEEN '1995-01-01' AND '1995-12-31' ORDER BY date ASC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are querying the correct table that contains the relevant data for your requirements. In this case, since the goal was to find accounts with the earliest trading date, the `trans` table should have been the primary focus, as it contains transaction records. Additionally, when filtering by a specific date range or criteria, make sure to verify which table's date column is more pertinent to the query context. Cross-reference your tables and their relationships to ensure accurate data retrieval.",
        "ground_truth_sql": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "hint": "",
        "error_sql": "SELECT DISTINCT account_id FROM account WHERE date < '1997-01-01' AND account_id IN (SELECT account_id FROM trans WHERE balance > 3000);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to use the correct join between tables to properly filter and combine data. In this case, joining the `account` and `trans` tables allows you to access both the account opening date and the transaction amounts simultaneously, which is crucial for meeting the query conditions effectively. Always verify that you are filtering the correct columns and applying conditions based on the joined data instead of relying solely on subqueries.",
        "ground_truth_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
        "difficulty": "simple"
    },
    {
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "hint": "Earlier birthdate refers to older age; A11 refers to average salary",
        "error_sql": "SELECT gender FROM client WHERE client_id = (SELECT client_id FROM disp WHERE account_id = (SELECT account_id FROM district ORDER BY A11 DESC LIMIT 1) LIMIT 1) ORDER BY birth_date ASC LIMIT 1;",
        "compiler_hint": "no such column: birth_date",
        "reflective_cot": "### Tip:\nWhen constructing nested SQL queries, ensure that you're accurately accessing the necessary columns from the relevant tables according to the logic of the required query. In the initial attempts, the nesting did not correctly join tables and lacked the proper ordering hierarchy. Always verify that your subqueries reference the correct relationships between tables and their columns. Additionally, when using `ORDER BY`, ensure that you're ordering in the correct subquery context and that it aligns with the overall logic of the query.",
        "ground_truth_sql": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "hint": "",
        "error_sql": "SELECT MIN(T2.date), T1.amount \nFROM trans AS T2 \nINNER JOIN account AS T3 ON T2.account_id = T3.account_id \nINNER JOIN loan AS T1 ON T3.account_id = T1.account_id \nWHERE T1.amount = (SELECT MAX(amount) FROM loan) \nGROUP BY T3.account_id \nORDER BY MIN(T2.date) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries that involve multiple tables and conditions, it's crucial to carefully track the relationships and ensure the correct aggregation is applied. Use clear aliases and consistently reference the correct columns in your `JOIN` clauses and conditions. Testing your subqueries independently can also help to validate their correctness before incorporating them into larger queries. Additionally, thoroughly understanding the sequence of operations (like `ORDER BY`, `GROUP BY`, and `LIMIT`) can prevent logical errors in the output results.",
        "ground_truth_sql": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "hint": "",
        "error_sql": "SELECT T1.disp_id \nFROM disp AS T1 \nINNER JOIN trans AS T2 ON T1.account_id = T2.account_id \nWHERE T2.amount = 5100 AND T2.date = '1998-09-02';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that all relevant tables are correctly joined and that the criteria specified in the WHERE clause align with the intended query conditions. Double-check the date and amount values against the correct datasets to avoid discrepancies.",
        "ground_truth_sql": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
        "difficulty": "simple"
    },
    {
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "hint": "A3 stands for region names",
        "error_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways be mindful of the order of sorting in SQL queries. When looking for the earliest entry, ensure you are using `ASC` (ascending) explicitly for clarity, even though `ORDER BY` defaults to ascending. This helps avoid misunderstandings and ensures that you retrieve the earliest record as intended.",
        "ground_truth_sql": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'Prague' ORDER BY T1.date ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "hint": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
        "error_sql": "SELECT (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0) / COUNT(*) AS male_percentage\nFROM client AS c\nJOIN district AS d ON c.district_id = d.district_id\nWHERE d.A3 = 'South Bohemia'\nAND d.A4 = (SELECT MAX(A4) FROM district WHERE A3 = 'South Bohemia');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that you are using the correct grouping and aggregation functions based on your needs. In this case, the original query did not include a `GROUP BY` clause after filtering for \"South Bohemia\" district; therefore, it attempted to compute the percentage across all records rather than for the record with the highest number of inhabitants. Always review the aggregate functions and make sure to group your results appropriately when dealing with data that requires summarization, especially when using aggregates like `MAX()` or `COUNT()`.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "hint": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
        "error_sql": "SELECT \n    ((B.balance - A.balance) / A.balance) * 100 AS increase_rate \nFROM \n    loan AS L \nINNER JOIN \n    account AS Acc ON L.account_id = Acc.account_id \nINNER JOIN \n    trans AS B ON Acc.account_id = B.account_id AND B.date = '1998-12-27' \nINNER JOIN \n    trans AS A ON Acc.account_id = A.account_id AND A.date = '1993-03-22' \nWHERE \n    L.date = '1993-07-05';",
        "compiler_hint": "ambiguous column name: A.account_id",
        "reflective_cot": "### Tip:\nWhen using aliases in SQL, ensure that they are unique within the query context to avoid ambiguity. If an alias needs to be reused or if a table contains columns that may share names (like `account_id` in multiple joins), always use a descriptive alias for each table to prevent confusion. This helps to clarify which instance of the column is being referred to, simplifying debugging and maintaining the query's logical flow.",
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "difficulty": "challenging"
    },
    {
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "hint": "Status = 'C' stands for running contract, ok so far; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100.",
        "error_sql": "SELECT CAST(SUM(CASE WHEN status = 'C' AND amount < 100000 THEN amount ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN amount < 100000 THEN amount ELSE 0 END) FROM loan;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're aggregating the correct fields and applying conditions appropriately. In your case, you mistakenly tried to calculate a condition based on a sum of amounts instead of counting the accounts. Focus on distinguishing between counts of distinct records that meet certain conditions (like the status) versus summing up numerical values (like amounts). Additionally, validate that aggregate functions like `SUM` or `COUNT` are correctly aligned with your intended analysis.",
        "ground_truth_sql": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "difficulty": "moderate"
    },
    {
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "hint": "Records about district names could be found in A2; A3 contains the information about regions. 'POPLATEK PO OBRATU' stands for issuance after transaction",
        "error_sql": "SELECT A.account_id, D.A2, D.A3 \nFROM account AS A \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE A.date BETWEEN '1993-01-01' AND '1993-12-31' \nAND A.account_id IN (SELECT account_id FROM trans WHERE operation = 'POPLATEK PO OBRATU');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the table structures and the semantics of the data you are querying. In this case, it's important to use the correct column (like `frequency` instead of `operation`) that directly relates to the condition you're checking. Additionally, ensure to verify date formats and aggregation functions such as `STRFTIME` to filter by year properly.",
        "ground_truth_sql": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "difficulty": "moderate"
    },
    {
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "hint": "Accounts holder refers to the person who own this account.",
        "error_sql": "SELECT A.account_id, A.frequency FROM account AS A INNER JOIN client AS C ON A.account_id = C.client_id INNER JOIN district AS D ON C.district_id = D.district_id WHERE A.date BETWEEN '1995-01-01' AND '2000-12-31' AND D.A2 = 'east Bohemia';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are joining the correct tables based on their relationships and correctly referencing the relevant fields. Double-check the schema to confirm which column corresponds to each entity, especially when dealing with foreign keys. Additionally, be cautious about the selection criteria; make sure you are filtering results based on the correct attributes from the right tables. Utilizing descriptive aliases for tables can help mitigate confusion in complex queries.",
        "ground_truth_sql": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
        "difficulty": "moderate"
    },
    {
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "hint": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
        "error_sql": "SELECT D.A2 AS district, D.A3 AS state, \n       ((D.A13 - D.A12) / D.A12) * 100 AS unemployment_increment_rate \nFROM loan AS L \nINNER JOIN account AS A ON L.account_id = A.account_id \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE L.status = 'D';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that division operations in SQL are performed with data types that prevent integer division, especially when calculating percentages. Using `CAST` or `CONVERT` to change integers to a `REAL` type before performing calculations will ensure accurate results. Additionally, check for any NULL values that could result in errors or misleading results during calculations.",
        "ground_truth_sql": "SELECT CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "difficulty": "challenging"
    },
    {
        "question": "List the account IDs with monthly issuance of statements.",
        "hint": "'POPLATEK MESICNE' stands for monthly issuance",
        "error_sql": "SELECT account_id FROM disp WHERE type = 'POPLATEK MESICNE';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check the correct table and column names against your desired output. In this case, the initial queries incorrectly referenced the `disp` table instead of the `account` table for the monthly issuance criteria. Familiarize yourself with the schema and clarify the relationships to avoid such mistakes, focusing on the specific attributes associated with the information you need.",
        "ground_truth_sql": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "difficulty": "simple"
    },
    {
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "hint": "Non-credit card withdraws refers to type = 'VYDAJ'; January 1996 can be found by date LIKE '1996-01%' in the database; A2 means district names",
        "error_sql": "SELECT D.A2, SUM(T.amount) AS total_withdrawals \nFROM trans AS T \nINNER JOIN account AS A ON T.account_id = A.account_id \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE T.type = 'VYDAJ' AND T.date LIKE '1996-01%' \nGROUP BY D.A2 \nORDER BY total_withdrawals DESC \nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query serves the exact requirements of the question. Pay particular attention to the requested operations (like aggregations) and make sure you're selecting the correct distinct or aggregated values based on the context. Use more explicit conditions (like BETWEEN) to filter date ranges correctly instead of using LIKE unless specifically required. Lastly, review the expected output format (e.g., distinct rows or aggregates) to align your `SELECT` statement properly.",
        "ground_truth_sql": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date LIKE '1996-01%' ORDER BY A2 ASC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "hint": "A3 contains the region names; South Bohemia is one of region names.",
        "error_sql": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'South Bohemia' AND T1.account_id NOT IN (SELECT DISTINCT disp.account_id FROM disp);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries that involve multiple conditions and table joins, be careful with the structure and logic of your subqueries and filters. Ensure that you're clearly selecting the correct fields and understanding the relationships between the tables involved. Additionally, ensure your conditions reflect the intended logic\u2014like distinguishing between those who have and don't have certain attributes correctly. Testing your queries incrementally can help identify logical errors early.",
        "ground_truth_sql": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "difficulty": "moderate"
    },
    {
        "question": "Which district has highest active loan?",
        "hint": "A3 refers to district names; Active loan refers to running contracts; Status = 'C' stands for running contract, OK so far; Status = 'D' stands for running contract, client in debt",
        "error_sql": "SELECT D.A3 AS district, COUNT(L.loan_id) AS active_loans \nFROM loan AS L \nINNER JOIN account AS A ON L.account_id = A.account_id \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE L.status IN ('C', 'D') \nGROUP BY D.district_id \nORDER BY active_loans DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen determining which district has the highest active loans, ensure that you consider the total loan amount in addition to the count of active loans. Simply counting the loans without evaluating their amounts can lead to an incomplete understanding of which district has the most significant financial obligation. Use `SUM` to aggregate the loan amounts and group by district accordingly to get a clearer picture of loan activity.",
        "ground_truth_sql": "SELECT T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.A3 ORDER BY SUM(T3.amount) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average loan amount by male borrowers?",
        "hint": "Male refers to gender = 'M'",
        "error_sql": "SELECT AVG(L.amount) \nFROM loan AS L \nINNER JOIN account AS A ON L.account_id = A.account_id \nINNER JOIN client AS C ON A.account_id = C.client_id \nWHERE C.gender = 'M';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables, ensure that the join conditions correctly match the intended columns across the foreign key relationships. Double-check the foreign key references in the schema to confirm that the correct corresponding columns are used in the joins. For instance, the errors in the joins resulted from incorrectly pairing `account_id` with `client_id` instead of linking through the necessary intermediary table (`disp`). Always follow the relationship path outlined in your schema for accurate joins.",
        "ground_truth_sql": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "difficulty": "simple"
    },
    {
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "hint": "A2 refers to district names; A13 refers to unemploymant rate in 1996",
        "error_sql": "SELECT d.A2, d.A4 \nFROM district AS d \nWHERE d.A13 = (SELECT MAX(A13) FROM district) \nAND d.A11 = 1996;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, always ensure that you correctly reference the specific conditions and values in your subqueries. In this case, you should have included both the unemployment rate condition and the year condition in the outer query, rather than mistakenly applying the year condition only in the inner query. To avoid similar mistakes, double-check that all conditions are properly aligned with the intended data context and structure when using subqueries or joins.",
        "ground_truth_sql": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "hint": "A16 stands for no. of committed crimes 1996",
        "error_sql": "SELECT COUNT(T1.account_id) \nFROM account AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T2.A16 = (SELECT MAX(A16) FROM district WHERE A16 IS NOT NULL) \nAND T1.date BETWEEN '1996-01-01' AND '1996-12-31';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, especially those involving aggregations and joins, ensure that you correctly group and order your results to specifically target the desired data. In this case, the initial queries did not correctly handle the grouping required to isolate the branch with the maximum number of crimes, and instead, they focused on filtering rather than aggregating. Always double-check whether you need to use aggregations like COUNT or MAX in combination with GROUP BY to achieve your goal.",
        "ground_truth_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.A16 ORDER BY T1.A16 DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "hint": "Negative balance means balance < 0; Operation = 'VYBER KARTOU' stands for credit card withdraw. Frequency = 'POPLATEK MESICNE' stands for monthly issurance",
        "error_sql": "SELECT COUNT(DISTINCT A.account_id) \nFROM account A \nINNER JOIN trans T ON A.account_id = T.account_id \nWHERE T.balance < 0 AND T.operation = 'VYBER KARTOU' AND A.frequency = 'POPLATEK MESICNE';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the use of DISTINCT when counting records, especially when joining tables. Using COUNT(DISTINCT A.account_id) may lead to undercounting if the join results in multiple rows for the same account, while using COUNT(T1.account_id) can ensure that you are counting correctly without missing any accounts that match the criteria. Additionally, ensure table aliases are consistently clear and contextually appropriate.",
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
        "difficulty": "moderate"
    },
    {
        "question": "Which accounts placed orders for household payment in Pisek?",
        "hint": "k_symbol = 'SIPO' refers to household payment",
        "error_sql": "SELECT DISTINCT A.account_id FROM account AS A INNER JOIN `order` AS O ON A.account_id = O.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE O.k_symbol = 'SIPO' AND D.A2 = 'Pisek';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're using the correct table for the columns needed in your query. In this case, the `k_symbol` column is in the `trans` table, not the `order` table. Double-check column locations and relationships within the database schema before constructing your SQL query to prevent referencing the wrong tables.",
        "ground_truth_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.k_symbol = 'SIPO' AND T3.A2 = 'Pisek'",
        "difficulty": "simple"
    },
    {
        "question": "What are the accounts that have gold credit cards?",
        "hint": "",
        "error_sql": "SELECT DISTINCT T1.account_id \nFROM account AS T1 \nINNER JOIN card AS T2 ON T1.account_id = T2.disp_id \nWHERE T2.type = 'gold';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure the correct join conditions between tables by carefully identifying the foreign key relationships. In this case, make sure you are joining on the correct columns that represent the relationships, such as using `disp_id` from the `disp` table to link with the `card` table, instead of mixing it with other tables prematurely. Double-checking your join logic and relationships can help avoid similar mistakes.",
        "ground_truth_sql": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "difficulty": "simple"
    },
    {
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "hint": "Operation = 'VYBER KARTOU' refers to credit card withdrawn",
        "error_sql": "SELECT AVG(T1.amount) \nFROM trans AS T1 \nWHERE T1.operation = 'VYBER KARTOU' \nAND STRFTIME('%Y', T1.date) = '2021' \nGROUP BY STRFTIME('%m', T1.date);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the schema and relationships between tables in your database. When searching for aggregated data (like averages), it's important to include the necessary joins to connect related tables properly. Additionally, be cautious with date filtering - ensure you're using the correct year and operation criteria as per your specific requirements. Consider leveraging explicit references to columns from the moment you join tables to avoid losing context or making assumptions about the data.",
        "ground_truth_sql": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?",
        "hint": "Operation = 'VYBER KARTOU' refers to credit card withdrawal",
        "error_sql": "SELECT DISTINCT T2.account_id \nFROM trans AS T1 \nINNER JOIN account AS T2 ON T1.account_id = T2.account_id \nWHERE T1.amount < (SELECT AVG(amount) FROM trans WHERE type = 'VYBER KARTOU' AND strftime('%Y', date) = '1998');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you pay attention to the specific conditions of the query, especially when filtering data. Make sure to use the right fields for operations and conditions in subqueries. In this case, it was crucial to filter by `operation = 'VYBER KARTOU'` in both the outer query and the subquery, and to ensure that any date filtering is applied correctly to the relevant rows. Always double-check which fields must be included in your conditions based on the requirements of the task.",
        "ground_truth_sql": "SELECT T1.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU' AND T1.amount < (SELECT AVG(amount) FROM trans WHERE STRFTIME('%Y', date) = '1998')",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "hint": "Female refers to gender = 'F'",
        "error_sql": "SELECT DISTINCT T1.client_id \nFROM client AS T1 \nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id \nINNER JOIN loan AS T3 ON T2.account_id = T3.account_id \nWHERE T1.gender = 'F';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you join all relevant tables necessary to satisfy the query requirements. In this case, the original queries missed the `card` table, which is essential to identify account holders with credit cards. Double-check the requirements and confirm all entities involved in the relationships to avoid similar oversights.",
        "ground_truth_sql": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "difficulty": "simple"
    },
    {
        "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
        "hint": "A3 contains the region names; North Bohemia is a region.",
        "error_sql": "SELECT COUNT(DISTINCT T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T3.A3 = 'North Bohemia' AND T1.bank = 'AB';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the correct casing for string comparisons in SQL, as some databases are case-sensitive. Additionally, be mindful of the order of joins and conditions to ensure that they accurately reflect the intended logic.",
        "ground_truth_sql": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "hint": "A3 refers to region names; A15 stands for the average number of crimes commited in 1995.",
        "error_sql": "SELECT AVG(T2.A15) \nFROM district AS T2 \nWHERE T2.A15 > 4000 AND T2.district_id IN (\n    SELECT DISTINCT T1.district_id \n    FROM account AS T1 \n    WHERE T1.date >= '1997-01-01'\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to join tables correctly when filtering data based on related attributes. In this case, instead of using a subquery to check for `district_id` in the `account` table, you should perform an `INNER JOIN` between the `district` and `account` tables to directly filter the relevant records, which allows you to use attributes from both tables in a single cohesive query. Always consider the relationships and dependencies between tables before composing your SQL query.",
        "ground_truth_sql": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "difficulty": "moderate"
    },
    {
        "question": "List all the withdrawals in cash transactions that the client with the id 3356 makes.",
        "hint": "operation = 'VYBER' refers to withdrawal in cash",
        "error_sql": "SELECT * FROM trans AS T \nJOIN account AS A ON T.account_id = A.account_id \nJOIN disp AS D ON A.account_id = D.account_id \nWHERE D.client_id = 3356 AND T.operation = 'VYBER';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are correctly joining tables using appropriate keys and conditions. Double-check that the join conditions match the logical relationships among the tables and use the correct keys to avoid incorrect results. Also, when filtering records, make sure to confirm that you've referenced the fields accurately based on your table structure.",
        "ground_truth_sql": "SELECT T4.trans_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 3356 AND T4.operation = 'VYBER'",
        "difficulty": "simple"
    },
    {
        "question": "Which district has the most accounts with loan contracts finished with no problems?",
        "hint": "status = 'A' refers to loan contracts finished with no problems",
        "error_sql": "SELECT D.A2, COUNT(*) AS account_count \nFROM loan AS L \nINNER JOIN account AS A ON L.account_id = A.account_id \nINNER JOIN district AS D ON A.district_id = D.district_id \nWHERE L.status = 'A' \nGROUP BY D.A2 \nORDER BY account_count DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen joining tables and counting entries, ensure that you are counting the distinct entities you are interested in, especially when multiple records can exist for those entities. In this case, using `COUNT(DISTINCT A.account_id)` was necessary to avoid counting duplicate accounts linked to multiple loans. Additionally, always verify your JOIN logic against the intended relational structure to ensure that the query accurately reflects the relationships defined in the schema.",
        "ground_truth_sql": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Who placed the order with the id 32423?",
        "hint": "",
        "error_sql": "SELECT A.account_id \nFROM `order` AS O \nINNER JOIN account AS A ON O.account_id = A.account_id \nWHERE O.order_id = 32423;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways analyze the relationships between tables and ensure that you join all necessary tables to retrieve the required information. In this case, the order is linked to the account, but the account is further connected to the client through the disp table. Always double-check foreign key relationships to avoid missing essential joins in your queries.",
        "ground_truth_sql": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "difficulty": "simple"
    },
    {
        "question": "Please list all the transactions made by accounts from district 5.",
        "hint": "",
        "error_sql": "SELECT T.* \nFROM trans AS T \nJOIN account AS A ON T.account_id = A.account_id \nWHERE A.district_id = 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that all relevant tables are included in your joins when filtering on a condition that involves multiple tables. It's essential to trace through relationships defined by foreign keys to guarantee that your query correctly reflects the intended relationships and conditions. Remember to test your query and review the table relationships before finalizing it.",
        "ground_truth_sql": "SELECT T3.trans_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.district_id = 5",
        "difficulty": "simple"
    },
    {
        "question": "What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?",
        "hint": "Growth rate = (sum of amount_1997 - sum of amount_1996) / (sum of amount_1996) * 100%; Male refers to gender = 'M'",
        "error_sql": "SELECT (SUM(CASE WHEN strftime('%Y', L.date) = '1997' THEN L.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', L.date) = '1996' THEN L.amount ELSE 0 END)) / NULLIF(SUM(CASE WHEN strftime('%Y', L.date) = '1996' THEN L.amount ELSE 0 END), 0) * 100 AS growth_rate\nFROM loan AS L\nINNER JOIN account AS A ON L.account_id = A.account_id\nINNER JOIN disp AS D ON A.account_id = D.account_id\nINNER JOIN client AS C ON D.client_id = C.client_id\nWHERE C.gender = 'M';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that all relevant data and conditions are properly accounted for. Specifically, if certain records should only be included based on their type or any other criteria (like \"OWNER\" in this case), always include that condition in your WHERE clause. Double-checking your joins and validating that all relationships are intact can help prevent exclusions of important data.",
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER'",
        "difficulty": "challenging"
    },
    {
        "question": "How many credit card withdrawals were recorded after 1995?",
        "hint": "Operation = 'VYBER KARTOU' means credit card withdrawals",
        "error_sql": "SELECT COUNT(*) \nFROM trans \nWHERE type = 'VYBER KARTOU' AND date > '1995-01-01';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure your SQL query conditions align with the intended logic. In this case, verify that you're checking the correct column for the operation type and the date filtering matches the desired range. Additionally, using date formatting functions like `STRFTIME` can provide clearer and more accurate conditions when dealing with date comparisons.",
        "ground_truth_sql": "SELECT COUNT(account_id) FROM trans WHERE STRFTIME('%Y', date) > '1995' AND operation = 'VYBER KARTOU'",
        "difficulty": "simple"
    },
    {
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "hint": "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in north Bohemia - Total no. of committed crimes in 1996 in e ast Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16",
        "error_sql": "SELECT (SELECT A16 FROM district WHERE A3 = 'North Bohemia') - (SELECT A16 FROM district WHERE A3 = 'East Bohemia') AS crime_difference;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the possibility of multiple records when aggregating data. Instead of directly selecting fields from individual queries, use aggregate functions like `SUM()` to calculate totals, especially when expecting data from a column that may contain multiple entries for a given condition. Additionally, ensure the conditions in your queries match the data casing and spelling in your database to avoid potential mismatches.",
        "ground_truth_sql": "SELECT SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) FROM district",
        "difficulty": "moderate"
    },
    {
        "question": "How many owner and disponent dispositions are there from account number 1 to account number 10?",
        "hint": "",
        "error_sql": "SELECT COUNT(*) \nFROM disp AS D \nWHERE D.account_id BETWEEN 1 AND 10 AND D.type IN ('OWNER', 'DISPONENT');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nBe cautious when using `COUNT(*)` with conditions on `SUM` or checking for specific values. Instead of counting directly, check if you need to aggregate or sum conditions, particularly when dealing with categorical data. Always double-check the expected result type and format for aggregation functions, ensuring you utilize the correct SQL functions (like `SUM` with conditions) to get the desired counts or sums.",
        "ground_truth_sql": "SELECT SUM(type = 'OWNER') , SUM(type = 'DISPONENT') FROM disp WHERE account_id BETWEEN 1 AND 10",
        "difficulty": "simple"
    },
    {
        "question": "How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?",
        "hint": "k_symbol refers to the purpose of payments",
        "error_sql": "SELECT frequency, SUM(amount) AS total_debit \nFROM account AS A \nINNER JOIN trans AS T ON A.account_id = T.account_id \nWHERE A.account_id = 3 \nGROUP BY frequency, A.account_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that each part of your query aligns with the intended analysis and the relationships between tables. In particular, be mindful of the grouping criteria and ensure you're aggregating the right fields in your subqueries. Always double-check if you're properly filtering on the relevant columns and handle joins effectively to capture the necessary data before aggregating.",
        "ground_truth_sql": "SELECT T1.frequency, T2.k_symbol FROM account AS T1 INNER JOIN (SELECT account_id, k_symbol, SUM(amount) AS total_amount FROM `order` GROUP BY account_id, k_symbol) AS T2 ON T1.account_id = T2.account_id WHERE T1.account_id = 3 AND T2.total_amount = 3539",
        "difficulty": "challenging"
    },
    {
        "question": "What year was account owner number 130 born?",
        "hint": "",
        "error_sql": "SELECT birth_date FROM client WHERE client_id = 130;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are correctly identifying the relationship between the tables and the specific conditions for your SQL queries. In this case, make sure to join the relevant tables accurately and filter based on the correct account or client IDs. Using alias names can help with clarity, but always verify that you're selecting from the correct context based on the relationships defined in your schema.",
        "ground_truth_sql": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
        "difficulty": "simple"
    },
    {
        "question": "What is the amount of debt that client number 992 has, and how is this client doing with payments?",
        "hint": "",
        "error_sql": "SELECT L.amount, L.payments, L.status \nFROM loan AS L \nINNER JOIN disp AS D ON L.account_id = D.account_id \nWHERE D.client_id = 992;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you have joined all necessary tables that relate to the data you need to retrieve. In this case, the first attempts only joined the loan and disp tables, missing the link to the client table and potentially the account table. Review your join paths and relationships in the database schema to ensure all relevant connections are included.",
        "ground_truth_sql": "SELECT T4.amount, T4.status FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 on T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 992",
        "difficulty": "simple"
    },
    {
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "hint": "",
        "error_sql": "SELECT C.gender, SUM(T.amount) AS total_amount \nFROM trans AS T \nINNER JOIN account AS A ON T.account_id = A.account_id \nINNER JOIN disp AS D ON A.account_id = D.account_id \nINNER JOIN client AS C ON D.client_id = C.client_id \nWHERE C.client_id = 4 AND T.trans_id > 851 \nGROUP BY C.gender;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nCarefully review the SQL logic and ensure the conditions in the WHERE clause align with the intended query. In the first query, the intention was to sum transactions following a specific transaction ID, but the logic incorrectly switched to the equality condition, leading to a misunderstanding of requirements. Always verify that the proper fields are being joined and filtered, and ensure the conditions reflect the actual requirement stated in the question.",
        "ground_truth_sql": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "difficulty": "simple"
    },
    {
        "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
        "hint": "",
        "error_sql": "SELECT T1.client_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.birth_date BETWEEN '1983-01-01' AND '1987-12-31' AND T2.A3 = 'East Bohemia';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you consider all relevant tables and their relationships when constructing your SQL queries. In this case, the connection between clients and their accounts required joining additional tables to fully retrieve the necessary information. Always verify the relationships in your schema to avoid missing data in your results.",
        "ground_truth_sql": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
        "difficulty": "moderate"
    },
    {
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "hint": "Man and male refers to gender = 'M'; 'SIPO' stands for household payment",
        "error_sql": "SELECT COUNT(DISTINCT C.client_id) \nFROM client AS C \nJOIN disp AS D ON C.client_id = D.client_id \nJOIN account AS A ON D.account_id = A.account_id \nJOIN trans AS T ON A.account_id = T.account_id \nWHERE C.gender = 'M' AND C.birth_date BETWEEN '1974-01-01' AND '1976-12-31' \nAND T.amount > 4000 AND T.type = 'SIPO';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, always ensure that you are using the correct column names and data types referenced in the tables. Additionally, be mindful of how to filter and aggregate data, especially when dealing with dates and classifications (like gender). Review the database schema carefully to align your conditions with the actual fields and ensure that any categorical values (like gender or transaction types) are accurate. Utilizing functions like `STRFTIME` can help manipulate date formats properly to match your filtering criteria.",
        "ground_truth_sql": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "hint": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
        "error_sql": "SELECT (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) * 100.0 / COUNT(e.client_id)) AS male_percentage\nFROM disp AS e \nJOIN client AS c ON e.client_id = c.client_id \nWHERE e.type = 'POPLATEK TYDNE';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nCarefully analyze the relationships between tables and ensure that all necessary joins are included to get the correct counts. In cases involving multiple conditions, ensure that you\u2019re filtering on the right columns and linking tables appropriately to avoid missing relevant data. Always cross-reference your conditions with the required output to ensure all factors are accounted for.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "hint": "Female refers to 'F' in the gender; A11 contains information about average salary",
        "error_sql": "SELECT a.account_id \nFROM client AS c \nJOIN account AS a ON c.client_id = a.account_id \nJOIN district AS d ON c.district_id = d.district_id \nWHERE c.gender = 'F' \nORDER BY c.birth_date ASC, d.A11 ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the join conditions to ensure they accurately reflect the relationships between the tables. In your case, the joins were incorrectly set, leading to incorrect associations. Ensure that the primary and foreign key connections are correctly matched, and verify which account corresponds to which client in the context of how the data is structured. Consider drawing out the relationships or writing down the logic of how tables relate to avoid confusion.",
        "ground_truth_sql": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
        "hint": "Only the owner accounts have the right to issue permanent orders or apply for loans",
        "error_sql": "SELECT DISTINCT C.client_id, D.A2 AS district \nFROM client AS C \nINNER JOIN disp AS D ON C.client_id = D.client_id \nINNER JOIN account AS A ON D.account_id = A.account_id \nINNER JOIN district AS D2 ON A.district_id = D2.district_id \nWHERE D.type = 'OWNER';",
        "compiler_hint": "no such column: D.A2",
        "reflective_cot": "### Tip:\nAlways ensure that your table aliases are unique and not reused for different tables in the same query. In your first attempt, you reused the alias `D` for both the `disp` and `district` tables, leading to confusion in column references. Clearly naming each alias distinctively helps prevent ambiguity and errors in SQL queries. Additionally, keep track of which columns belong to which table by using the alias consistently throughout your query.",
        "ground_truth_sql": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "hint": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')",
        "error_sql": "SELECT AVG(oxygen_count) FROM (\n    SELECT COUNT(A.atom_id) AS oxygen_count \n    FROM molecule AS M \n    INNER JOIN bond AS B ON M.molecule_id = B.molecule_id \n    INNER JOIN atom AS A ON M.molecule_id = A.molecule_id \n    WHERE B.bond_type = '-' AND A.element = 'o' \n    GROUP BY M.molecule_id\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that you are selecting the correct columns and grouping by the relevant identifiers. In your initial attempts, you were grouping by the molecule ID but did not include it in the final selection, preventing proper aggregation. Always double-check that all necessary fields for grouping and counting are consistently included in both the SELECT and the JOIN statements to avoid issues with your aggregations.",
        "ground_truth_sql": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "difficulty": "moderate"
    },
    {
        "question": "On average how many carcinogenic molecules are single bonded?",
        "hint": "carcinogenic molecules refers to label = '+'; single-bonded refers to bond_type = '-'; average = DIVIDE(SUM(bond_type = '-'), COUNT(atom_id))",
        "error_sql": "SELECT AVG(single_bond_count) FROM (SELECT COUNT(bond.bond_id) AS single_bond_count FROM molecule INNER JOIN bond ON molecule.molecule_id = bond.molecule_id WHERE molecule.label = '+' AND bond.bond_type = '-' GROUP BY molecule.molecule_id) AS temp;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you correctly join all necessary tables to access the relevant columns for your conditions. In this case, both the `bond` and `atom` tables needed to be joined appropriately along with the `molecule` table to accurately count the single bonds for carcinogenic molecules. Double-check your logic regarding the grouping and the conditions used in your SQL queries to avoid missing important joins.",
        "ground_truth_sql": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "difficulty": "challenging"
    },
    {
        "question": "In how many atoms is there no bromine?",
        "hint": "atoms with no bromine refers to element ! = 'br'",
        "error_sql": "SELECT COUNT(atom_id) FROM atom WHERE molecule_id NOT IN (SELECT molecule_id FROM atom WHERE element = 'br');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the possibility of duplicate entries when counting records in a database. Using `COUNT(DISTINCT ...)` ensures that only unique entries are considered, preventing miscalculations, especially in cases where you need to analyze distinct elements or entities.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
        "difficulty": "simple"
    },
    {
        "question": "What elements are in a double type bond?",
        "hint": "double type bond refers to bond_type = '=';",
        "error_sql": "SELECT DISTINCT element FROM atom WHERE atom_id IN (SELECT atom_id FROM connected WHERE bond_id IN (SELECT bond_id FROM bond WHERE bond_type = '='));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you consider the relationships between tables and include necessary JOIN operations when querying data across multiple related tables. In this case, you needed to join `atom`, `bond`, and `connected` to accurately extract the relevant elements associated with the double bond type.",
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "difficulty": "challenging"
    },
    {
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "hint": "label = '-' means molecules are non-carcinogenic",
        "error_sql": "SELECT c.atom_id, c.atom_id2 \nFROM connected c \nJOIN molecule m ON c.atom_id IN (SELECT atom_id FROM atom WHERE molecule_id = m.molecule_id) \nWHERE m.label = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the SQL joins accurately reflect the relationships between tables. Avoid using subqueries in the ON clause and instead directly join relevant tables based on their foreign key relationships. Make sure to select and project the appropriate columns needed to meet the query requirements.",
        "ground_truth_sql": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
        "difficulty": "simple"
    },
    {
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "hint": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT COUNT(DISTINCT a.atom_id) \nFROM atom a \nJOIN connected c ON a.atom_id = c.atom_id \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE (a.element = 'i' OR a.element = 's') AND b.bond_type = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using appropriate JOIN conditions. When counting distinct items, make sure to accurately reflect the relationships in your JOIN clauses. In this case, using an OR condition in the JOIN could introduce incorrect matches. Instead, consistently use INNER JOINs based on direct relationships to ensure you retrieve the correct data set and maintain the integrity of the relationships within the dataset.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "difficulty": "challenging"
    },
    {
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "hint": "TR181 molecule refers to molecule_id = 'TR181'",
        "error_sql": "SELECT DISTINCT c.atom_id2 \nFROM connected c \nJOIN atom a ON c.atom_id = a.atom_id \nWHERE a.molecule_id = 'TR181';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are joining tables correctly based on relationships that reflect the query's intent. Specifically, pay attention to which relationships connect tables and make sure to include all relevant conditions in the JOIN clause to avoid incomplete or incorrect results.",
        "ground_truth_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "difficulty": "simple"
    },
    {
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "hint": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;",
        "error_sql": "SELECT (COUNT(DISTINCT molecule_id) - SUM(CASE WHEN element = 'f' THEN 1 ELSE 0 END)) * 100.0 / COUNT(DISTINCT molecule_id) AS percentage_non_fluorine \nFROM atom \nWHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your conditions for counting or summing in SQL are correctly aligned with your logical requirements. In this case, the logic needed to separately count molecules that either contain or do not contain a specific element (like fluorine) but still relate to the overall dataset. Using CASE statements effectively and understanding the distinction between counting and summing can help avoid overly complex conditions that may lead to incorrect results. When dealing with DISTINCT values, remember to align your counting logic with the appropriate table relationships to maintain accurate counts.",
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "challenging"
    },
    {
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "hint": "label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(bond_type = '#') * 100, COUNT(bond_id)) as percent where label = '+'",
        "error_sql": "SELECT (SUM(bond_type = '#') * 100.0 / COUNT(bond_id)) AS percent FROM bond WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your subqueries accurately relate to the tables being referenced, considering necessary joins to reflect the relationships between them. This helps avoid missing associations that could lead to incorrect aggregations or calculations in your main query.",
        "ground_truth_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
        "difficulty": "challenging"
    },
    {
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "hint": "TR001 is the molecule id; TR001_2_6 is the bond id",
        "error_sql": "SELECT DISTINCT c.atom_id, c.atom_id2 \nFROM connected c \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE b.bond_id = 'TR001_2_6' AND b.molecule_id = 'TR001';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for specific relationships in a relational database, always ensure that you are extracting the right identifiers directly from the relevant tables. In this case, focus on clearly understanding how bond IDs correlate with the atoms they connect, potentially by mapping them correctly through string manipulation or additional JOINs that directly relate the bond's attributes to atom identifiers. Familiarizing yourself with your dataset's structure and relationships can help prevent similar mistakes in the future.",
        "ground_truth_sql": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "difficulty": "simple"
    },
    {
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "hint": "TR000_2_5 is the bond id",
        "error_sql": "SELECT c.atom_id, c.atom_id2 \nFROM connected c \nWHERE c.bond_id = 'TR000_2_5';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the expected output of your SQL query based on the requirements. In this case, the initial query aimed to retrieve both atoms of a bond but did not align with the requirement of returning only the atom IDs. Ensure to clarify exactly what data is needed and adjust your SQL query accordingly to prevent unnecessary complexity.",
        "ground_truth_sql": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
        "difficulty": "simple"
    },
    {
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "hint": "double bond refers to bond_type = ' = ';",
        "error_sql": "SELECT DISTINCT m.molecule_id, m.label \nFROM molecule m \nJOIN bond b ON m.molecule_id = b.molecule_id \nWHERE b.bond_type = ' = ' \nORDER BY m.molecule_id \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are accurately filtering the bond types and focus on distinct differences between bond types when analyzing tables. In this case, note that the correct representation should match exactly to how the bond_type is stored in the database, ensuring that you use a consistent comparison when looking for double bonds. Additionally, make sure to select unique identifiers as intended, while being cautious about the sorting order\u2014whether by molecule_id or label\u2014to achieve the desired results.",
        "ground_truth_sql": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "hint": "double bond refers to bond_type = '='; TR008 is the molecule id; percentage = DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent where molecule_id = 'TR008'",
        "error_sql": "SELECT (SUM(bond_type = '=') * 100.0 / COUNT(bond_id)) AS percent FROM bond WHERE molecule_id = 'TR008';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to use the correct aggregation functions and conditional expressions when calculating percentages in SQL. Instead of directly using `SUM(bond_type = '=')`, which may not yield the expected results due to type coercion, leverage `COUNT` with conditional logic (`CASE WHEN`) to count specific bond types accurately. This prevents miscalculations due to implicit conversions and ensures that the denominator reflects the total counts accurately.",
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "difficulty": "moderate"
    },
    {
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "hint": "TR010 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); ",
        "error_sql": "SELECT b.bond_type, COUNT(b.bond_type) AS bond_count, m.label \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.molecule_id = 'TR010' \nGROUP BY b.bond_type, m.label \nORDER BY bond_count DESC \nLIMIT 1; ",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "### Tip:\nAlways ensure to use subqueries or CTEs (Common Table Expressions) for scenarios requiring multiple aggregated results or when needing to correlate data from different tables. This helps in avoiding execution limitations and keeps the logic neat by combining results in one cohesive query rather than splitting them.",
        "ground_truth_sql": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "difficulty": "challenging"
    },
    {
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "hint": "TR009 is the molecule id;  involved atom 12 refers to atom_id = 'TR009_12' or atom_id2 = 'TR009_12'",
        "error_sql": "SELECT COUNT(DISTINCT b.bond_id) \nFROM bond b \nJOIN connected c ON b.bond_id = c.bond_id \nWHERE (c.atom_id = 'TR009_12' OR c.atom_id2 = 'TR009_12') AND b.molecule_id = 'TR009';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the conditions in your WHERE clause correctly match the requirements of the query. In this case, ensure you're accurately referencing the atom IDs involved in the bonds for the specified molecule and that the JOIN conditions align with the relevant relationships in the database. Double-checking your JOIN logic and the specific conditions can help avoid such errors.",
        "ground_truth_sql": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
        "difficulty": "moderate"
    },
    {
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "hint": "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT m.molecule_id, m.label \nFROM atom a \nJOIN molecule m ON a.molecule_id = m.molecule_id \nWHERE a.atom_id = 'TR001_10';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to account for the required output format and any transformations needed for specific fields. For instance, in this case, properly using conditional statements (like IIF) to convert data into a required output format (for carcinogenic flags) can help avoid errors. Additionally, double-check the logic of your queries to match the expected results closely.",
        "ground_truth_sql": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "difficulty": "moderate"
    },
    {
        "question": "How many connections does the atom 19 have?",
        "hint": "connections refers to bond_id; atom 19 refers to atom_id like 'TR%_19';",
        "error_sql": "SELECT COUNT(DISTINCT c.bond_id) \nFROM connected c \nWHERE c.atom_id = 'TR%_19' OR c.atom_id2 = 'TR%_19';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering results based on partial string matches or specific patterns, ensure that you use string functions correctly (like `LIKE` or `SUBSTR`) rather than attempting to match using equality operators or wildcard characters incorrectly. Always verify the syntax for pattern matching and take care to check for potential SQL injection or mismatches in expected formats.",
        "ground_truth_sql": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "difficulty": "simple"
    },
    {
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "hint": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT label FROM molecule WHERE molecule_id = (SELECT molecule_id FROM bond WHERE bond_type = ' = ' GROUP BY molecule_id ORDER BY COUNT(bond_id) DESC LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen working with SQL queries that involve aggregations and filtering based on results from subqueries, ensure you correctly join tables and reference the aggregated results for subsequent conditions. Always confirm that your joins maintain the relationships between the tables correctly and that the right attributes are used to filter the final results. Additionally, be cautious about using multiple layers of subqueries, as they can complicate the logic and lead to errors.",
        "ground_truth_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "hint": "atoms with the element iodine refers to element = 'i'; average = DIVIDE(COUND(bond_id), COUNT(atom_id)) where element = 'i'",
        "error_sql": "SELECT AVG(bond_count) AS average_bonds\nFROM (\n    SELECT COUNT(c.bond_id) AS bond_count\n    FROM atom a\n    LEFT JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\n    WHERE a.element = 'i'\n    GROUP BY a.atom_id\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the JOIN used for calculating aggregates reflects the correct relationship between the tables. Specifically, when counting related records (like bonds), verify that appropriate INNER or LEFT JOIN semantics are applied based on whether you want to include or exclude certain records, and confirm that the GROUP BY aligns with the aggregate calculations intended.",
        "ground_truth_sql": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "difficulty": "moderate"
    },
    {
        "question": "List the bond type and the bond ID of the atom 45.",
        "hint": "bond ID of atom 45 refers to SUBSTR(atom_id, 7, 2) + 0 = 45; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "error_sql": "SELECT b.bond_type, c.bond_id \nFROM bond b \nJOIN connected c ON b.bond_id = c.bond_id \nWHERE (c.atom_id = 'TR000_45' OR c.atom_id2 = 'TR000_45');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that comparisons in SQL queries match the expected data types. In the Ground Truth SQL, the comparison is made using the substring value directly as a string (`= '45'`) rather than converting it to a number. Additionally, clarify the criteria for the connections and ensure all logical conditions are correctly applied to avoid overlooking different formats in the identifiers.",
        "ground_truth_sql": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
        "difficulty": "moderate"
    },
    {
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "hint": " atoms cannot bond with other atoms means atom_id NOT in connected table;",
        "error_sql": "SELECT DISTINCT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries to find distinct values based on conditions from related tables, ensure that you're accurately capturing all relevant relationships. Instead of using separate checks for each table in a subquery, consider joins to ensure you're accounting for all connections comprehensively. This approach often provides a clearer understanding of how multiple tables interact and leads to more accurate results.",
        "ground_truth_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "difficulty": "challenging"
    },
    {
        "question": "What is the least common element of all carcinogenic molecules?",
        "hint": "label = '+' mean molecules are carcinogenic",
        "error_sql": "SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+') GROUP BY element ORDER BY COUNT(*) LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting distinct occurrences in a subgroup, ensure you correctly aggregate based on the unique identifiers relevant to your query, such as `molecule_id` in this case. Always review the logic of your GROUP BY and JOIN clauses to avoid mixing aggregates with non-aggregated fields, as this can lead to inaccurate results.",
        "ground_truth_sql": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "difficulty": "moderate"
    },
    {
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "hint": "atom that has the element lead refers to atom_id where element = 'pb'",
        "error_sql": "SELECT DISTINCT c.atom_id2 \nFROM connected c \nJOIN atom a ON c.atom_id = a.atom_id \nWHERE a.element = 'pb';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nCarefully examine the relationships and directionality of the joins in your queries. Ensure that you're referencing the correct columns for the intended logic, especially when dealing with symmetric relationships. In this case, correctly identify the atom from the first table and join using the correct connection to find its bonds with other atoms. Always validate the logic against the schema to ensure accurate mappings.",
        "ground_truth_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "difficulty": "simple"
    },
    {
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "hint": "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))",
        "error_sql": "SELECT (COUNT(b.bond_id) * 100.0 / (SELECT MAX(bond_count) FROM (SELECT COUNT(c.atom_id) AS bond_count FROM connected c JOIN bond b ON c.bond_id = b.bond_id GROUP BY b.bond_id))) AS bond_percentage\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen creating SQL queries that involve aggregates and subqueries, ensure that the logic correctly reflects the relationships and counts you're trying to calculate. In particular, be cautious with GROUP BY clauses and ensure that the aggregations align with the intended analysis. Break down complex queries into simpler steps to verify each part before combining them, and double-check the context and scope of COUNT() functions to avoid miscalculations.",
        "ground_truth_sql": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "difficulty": "moderate"
    },
    {
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "hint": "single bond refers to bond_type = '-'; label = '+' mean molecules are carcinogenic; proportion = DIVIDE(SUM(label = '+') * 100, COUNT(bond_id)) where bond_type = '-'",
        "error_sql": "SELECT ROUND((SELECT COUNT(*) FROM bond WHERE bond_type = '-' AND molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+')) * 100.0 / COUNT(bond_id), 5) AS proportion FROM bond WHERE bond_type = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're correctly referencing and joining tables when performing aggregations, especially when conditions depend on multiple columns or tables. Use explicit joins to clarify relationships and check if conditions in your aggregates align with the intended calculations. Testing subqueries separately can also help identify logical errors.",
        "ground_truth_sql": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "difficulty": "moderate"
    },
    {
        "question": "How many elements are there for single bond molecules?",
        "hint": "single bond refers to bond_type = '-';",
        "error_sql": "SELECT COUNT(DISTINCT a.element) \nFROM atom a \nJOIN connected c ON a.atom_id = c.atom_id \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE b.bond_type = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you verify relationships among tables, especially when counting unique elements. Specifically, check if the elements being counted are indeed directly associated with the specific criteria defined by the conditions in the query (in this case, single bond molecules). Using subqueries often helps clarify relationships and filter results more accurately before applying aggregations like `COUNT()`.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "difficulty": "simple"
    },
    {
        "question": "What is the composition of element chlorine in percentage among the single bond molecules?",
        "hint": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
        "error_sql": "SELECT (SUM(element = 'cl') * 100.0 / COUNT(atom_id)) AS chlorine_percentage FROM atom WHERE molecule_id IN (SELECT molecule_id FROM bond WHERE bond_type = '-')",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that all necessary joins between tables are included to capture the correct relationships between atoms, molecules, and bonds, especially when filtering based on specific criteria like bond types. Use INNER JOINs to link related tables and accurately restrict your results to the relevant subset of data.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T.element = 'cl' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id) FROM ( SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "difficulty": "challenging"
    },
    {
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "hint": "double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';",
        "error_sql": "SELECT DISTINCT b.bond_type \nFROM bond b \nWHERE b.molecule_id BETWEEN 'TR000' AND 'TR050';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL queries explicitly join the relevant tables and that the conditions in the `WHERE` clause properly reference those tables. Double-check the join syntax and the logic behind the filters you are applying, especially when dealing with primary and foreign keys. Additionally, validating column names and understanding the relationships between tables helps in forming accurate queries.",
        "ground_truth_sql": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "difficulty": "moderate"
    },
    {
        "question": "How many bond id have element iodine?",
        "hint": "iodine refers to element = 'i'",
        "error_sql": "SELECT COUNT(DISTINCT c.bond_id) \nFROM atom a \nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 \nWHERE a.element = 'i';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you carefully track the relationships and join conditions between tables. Specifically, when counting unique identifiers (like bond_id), always use the correct joins that reflect the proper connections between entities in your database schema. Pay particular attention to which fields you are joining on to avoid incorrect relationships that might lead to inaccurate results.",
        "ground_truth_sql": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
        "difficulty": "simple"
    },
    {
        "question": "Among the molecules with element Calcium, are they mostly carcinogenic or non carcinogenic?",
        "hint": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic; MAX(label)",
        "error_sql": "SELECT label, COUNT(*) as count FROM molecule WHERE molecule_id IN (SELECT molecule_id FROM atom WHERE element = 'ca') GROUP BY label ORDER BY count DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are joining tables correctly to include relevant data. If you need to analyze data from multiple tables, use appropriate JOIN clauses rather than relying solely on subqueries, as they may not correctly filter or bring together the necessary data to obtain accurate results.",
        "ground_truth_sql": "SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca' GROUP BY T2.label ORDER BY COUNT(T2.label) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "hint": "chlorine refers to element = 'cl'; carbon refers to element = 'c'",
        "error_sql": "SELECT DISTINCT CASE WHEN COUNT(DISTINCT element) = 2 THEN 'Yes' ELSE 'No' END AS has_both_elements\nFROM atom \nWHERE atom_id IN (\n    SELECT atom_id FROM connected WHERE bond_id = 'TR001_1_8'\n) AND element IN ('cl', 'c');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the SQL query structure correctly captures all relevant conditions for the elements being checked. Specifically, when counting distinct elements, properly join tables where necessary to ensure you are considering the right context. Additionally, verify the element codes (e.g., checking for variations like 'c' for carbon and 'c1' if applicable) to avoid missing out on valid options.",
        "ground_truth_sql": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "hint": "chlorine refers to element = 'cl'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(element = 'pb'); COUNT(molecule_id)) as percentage where label = '+'",
        "error_sql": "SELECT ROUND((SELECT COUNT(*) FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'cl' AND m.label = '+') * 100.0 / (SELECT COUNT(*) FROM molecule WHERE label = '+'), 3) AS percentage;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you correctly count the total number of atoms in the relevant carcinogenic molecules when calculating percentages. In both of your queries, you inadvertently used the `molecule` table to count molecules and strained the logic, instead of counting atoms directly tied to those molecules. Always double-check the context of the count you\u2019re performing, especially the denominator in percentage calculations.",
        "ground_truth_sql": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Give me the molecule ID of the double bond type.",
        "hint": "double bond refers to bond_type = ' = ';",
        "error_sql": "SELECT DISTINCT b.molecule_id \nFROM bond b \nWHERE b.bond_type = '= ';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the formatting and spacing of your string values in SQL queries, especially when comparing values that may include special characters or spaces. This helps prevent mismatches due to unintentional whitespace or incorrect characters.",
        "ground_truth_sql": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
        "difficulty": "simple"
    },
    {
        "question": "How many of the single bond type molecules are non-carcinogenic?",
        "hint": "label = '-' means molecules are non-carcinogenic; single bond refers to bond_type = '-';",
        "error_sql": "SELECT COUNT(*) FROM bond WHERE bond_type = '-' AND molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting distinct records in a query that involves multiple tables, it's important to use proper JOINs to combine the related data, ensuring that you're accurately filtering the results based on conditions from both tables. Avoid using subqueries when a join can provide a clearer and more efficient solution. Always review the data relationships and consider how to effectively combine the necessary tables to meet the query requirements.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "difficulty": "simple"
    },
    {
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "hint": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
        "error_sql": "SELECT DISTINCT a.element \nFROM atom a \nJOIN molecule m ON a.molecule_id = m.molecule_id \nWHERE m.label = '+' AND SUBSTR(a.atom_id, 7, 1) = '4';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways carefully analyze the schema and specific string manipulations required by the question. Pay attention to the conditions on columns, such as ensuring you're referencing the correct substring and validating the string length to avoid unexpected matches. Use logical expressions and make sure they align with the intended filtering criteria in your SQL query.",
        "ground_truth_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "difficulty": "challenging"
    },
    {
        "question": "What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.",
        "hint": "hydrogen refers to element = 'h'; ratio = DIVIDE(SUM(element = 'h'), count(element)) where molecule_id = 'TR006' ; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "error_sql": "SELECT m.label, ROUND((SUM(a.element = 'h') * 1.0 / COUNT(a.element)), 4) AS ratio \nFROM atom a \nJOIN molecule m ON a.molecule_id = m.molecule_id \nWHERE m.molecule_id = 'TR006' \nGROUP BY m.label;",
        "compiler_hint": "ambiguous column name: molecule_id",
        "reflective_cot": "### Tip:\nAlways qualify column names with their respective table aliases when using joins, especially when multiple tables have columns with the same name. This practice helps avoid ambiguity and ensures that your query references the correct column in the intended table.",
        "ground_truth_sql": "WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label",
        "difficulty": "challenging"
    },
    {
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "hint": "calcium refers to element = 'ca'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic;",
        "error_sql": "SELECT DISTINCT molecule_id FROM atom WHERE element = 'ca' AND molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries that involve filtering based on multiple conditions, ensure that you're accurately joining the relevant tables and selecting the right columns. Always double-check the logical flow and relationships between the tables to avoid missing necessary joins or wrong selections. In this case, using a clearer relationship between the `atom` and `molecule` tables would have avoided the oversight in filtering correctly for the carcinogenic labels.",
        "ground_truth_sql": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "difficulty": "moderate"
    },
    {
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "hint": "triple bond refers to bond_type = '#';",
        "error_sql": "SELECT (COUNT(DISTINCT b.molecule_id) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS triple_bond_percentage \nFROM bond b \nJOIN molecule m ON b.molecule_id = m.molecule_id \nWHERE b.bond_type = '#';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages or ratios, ensure you're comparing the same set of data. In the initial attempts, the calculation of total compounds or bonds may not have aligned correctly with the count of specific bond types. Use conditional aggregation to explicitly count only relevant entries and consider using subqueries or CASE statements effectively to derive accurate totals. Always double-check that denominators reflect the complete dataset you're interested in before performing any division.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
        "difficulty": "simple"
    },
    {
        "question": "Indicate the molecule id is belonging to the TR000_1_2 bond that has the first atom named TR000_1.",
        "hint": "",
        "error_sql": "SELECT DISTINCT b.molecule_id \nFROM bond b \nJOIN connected c ON b.bond_id = c.bond_id \nWHERE b.bond_id = 'TR000_1_2' AND c.atom_id = 'TR000_1';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, it's crucial to carefully check the join conditions and the relationships between tables to ensure that they accurately reflect the intended logic. Always validate that the filtering conditions correctly correspond to the keys and relationships defined in the schema. Additionally, consider using more intuitive aliases for clarity and ensure all necessary conditions are explicitly included to avoid logic errors.",
        "ground_truth_sql": "SELECT T2.molecule_id, T2.bond_id, T1.atom_id FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'",
        "difficulty": "simple"
    },
    {
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "hint": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0",
        "error_sql": "SELECT ROUND((SELECT COUNT(*) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+ 'AND a.element = 'h') * 100.0 / COUNT(molecule_id), 3) AS percent FROM molecule;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are counting distinct entities appropriately and validate the specific conditions used within aggregate functions. It can be helpful to break down complex queries into smaller parts and utilize `COUNT` statements on the correct datasets to avoid mismatches in context or incorrect assumptions about data relationships.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "difficulty": "moderate"
    },
    {
        "question": "What atoms comprise TR186?",
        "hint": "TR186 is a molecule id",
        "error_sql": "SELECT DISTINCT a.atom_id, a.element \nFROM atom a \nWHERE a.molecule_id = 'TR186';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the required columns in your query, especially when looking to obtain specific information. In this case, if only the `atom_id` is needed, consider simplifying your SELECT statement accordingly and check that you are correctly addressing the primary focus of the question.",
        "ground_truth_sql": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "difficulty": "simple"
    },
    {
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "hint": "single bond refers to bond_type = '-';",
        "error_sql": "SELECT DISTINCT c.atom_id, c.atom_id2 \nFROM connected c \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE b.bond_type = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to include all necessary fields in your SELECT statement that you intend to retrieve, especially when multiple tables are involved in the JOIN. Consider using aliases for clarity and make sure to explicitly review the relationships and dependencies between the tables to ensure the JOIN operation is accurately formed. This helps avoid missing crucial information in the result set.",
        "ground_truth_sql": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "difficulty": "simple"
    },
    {
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "hint": "triple bond refers to bond_type = '#'; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "error_sql": "SELECT DISTINCT a.element \nFROM atom a \nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE b.bond_type = '#' \nAND a.molecule_id IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query joins the relevant tables on correct fields that establish the intended relationships. In this case, focus on joining the `bond` table with `atom` through the `molecule_id` to ensure you are retrieving elements specifically associated with molecules that contain the desired bond type. Validate your query logic by breaking it down and confirming that each condition accurately reflects the requirements of the task.",
        "ground_truth_sql": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "difficulty": "challenging"
    },
    {
        "question": "List out the atom id that belongs to the TR346 molecule and how many bond type can be created by this molecule?",
        "hint": "",
        "error_sql": "SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_type_count \nFROM atom a \nJOIN bond b ON a.molecule_id = b.molecule_id \nWHERE a.molecule_id = 'TR346' \nGROUP BY a.atom_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are correctly joining the relevant tables that contain the necessary relationships, and be mindful of which attributes you are selecting and aggregating. Specifically, double-check that you're counting distinct bond types related to the specific molecule, and ensure the grouping aligns with the intended aggregation to avoid miscounting or misgrouping the data.",
        "ground_truth_sql": "SELECT T1.atom_id, COUNT(DISTINCT T2.bond_type),T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' GROUP BY T1.atom_id, T2.bond_type",
        "difficulty": "simple"
    },
    {
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "hint": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic;",
        "error_sql": "SELECT COUNT(*) \nFROM bond \nWHERE bond_type = '=' AND molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting unique occurrences or applying conditional logic in a query, ensure you properly join related tables and use aggregate functions correctly. In this scenario, using a `JOIN` to combine the `bond` and `molecule` tables allows you to correctly filter the relevant bonds while facilitating accurate counting of unique molecules. Always review the relationship between tables and use aggregate functions thoughtfully to summarize data accurately.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of carcinogenic molecules which contain the Chlorine element.",
        "hint": "label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'cl'), COUNT(molecule_id)) as percentage",
        "error_sql": "SELECT ROUND((SELECT COUNT(*) FROM molecule WHERE label = '+' AND molecule_id IN (SELECT molecule_id FROM atom WHERE element = 'cl')) * 100.0 / COUNT(molecule_id), 3) AS percentage FROM molecule;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages in SQL, ensure you accurately reference the correct counts for both the numerator (specific conditions) and the denominator (total counts). Utilize proper joins between tables to avoid miscounts, and be cautious of how you aggregate grouped data to maintain the integrity of your calculations. Also, consider using `CASE` statements within aggregate functions to simplify counting under specific conditions.",
        "ground_truth_sql": "SELECT COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "difficulty": "moderate"
    },
    {
        "question": "Which molecule consisted of Sulphur atom with double bond?",
        "hint": "sulphur refers to element - 's'; double bond refers to bond_type = ' = ';",
        "error_sql": "SELECT DISTINCT m.molecule_id \nFROM molecule m \nJOIN atom a ON m.molecule_id = a.molecule_id \nJOIN bond b ON m.molecule_id = b.molecule_id \nWHERE a.element = 's' AND b.bond_type = '=';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when joining tables, you verify that the relationships between the entities are correctly represented, especially when dealing with multiple connections. In this case, you should explicitly check that the atom's bonds are relevant and properly linked. Avoid using the molecule_id for joins indiscriminately; instead, focus on the specific relationships relevant to the query to accurately filter results.",
        "ground_truth_sql": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
        "difficulty": "simple"
    },
    {
        "question": "List all the elements with double bond, consisted in molecule TR024.",
        "hint": "double bond refers to bond_type = '='; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "error_sql": "SELECT DISTINCT a.element \nFROM atom a \nJOIN connected c ON a.atom_id = c.atom_id \nJOIN bond b ON c.bond_id = b.bond_id \nWHERE b.molecule_id = 'TR024' AND b.bond_type = '=';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways carefully examine the relationships between tables and ensure you are joining on the correct fields. In the original query, the join between `atom` and `bond` was incorrectly established through the `connected` table instead of directly leveraging the `molecule_id` from the `bond` table. A good practice is to clarify the purpose of each join and visually trace the foreign key relationships in your database schema before finalizing your SQL statements.",
        "ground_truth_sql": "SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR024' AND T2.bond_type = '='",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "hint": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; triple bond refers to bond_type = '#'; percentage = DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0 where element = 'h' AND bond_type = '#';",
        "error_sql": "SELECT ROUND((SELECT COUNT(DISTINCT m.molecule_id) \n                FROM molecule m \n                JOIN atom a ON m.molecule_id = a.molecule_id \n                JOIN bond b ON m.molecule_id = b.molecule_id \n                WHERE m.label = '+' AND a.element = 'h' AND b.bond_type = '#') * 100.0 / \n               (SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m \n                JOIN atom a ON m.molecule_id = a.molecule_id \n                JOIN bond b ON m.molecule_id = b.molecule_id \n                WHERE a.element = 'h' AND b.bond_type = '#'), 3) AS percent;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to differentiate between counting distinct entities and summing up conditions. Use `SUM` with `CASE` statements to explicitly count conditions (e.g., carcinogenic molecules) instead of counting directly in your aggregate functions. This ensures you accurately capture the specific conditions required for your calculations. Additionally, always double-check your joins and filtering criteria to confirm they align with the logic of your query.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "difficulty": "challenging"
    },
    {
        "question": "Which are the cards that have incredibly powerful foils.",
        "hint": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "error_sql": "SELECT * FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways clarify the intended output of your SQL query. If you're interested in specific columns (such as `id`), ensure your SELECT statement includes those columns explicitly, instead of using `*`, which retrieves all columns and may include unnecessary data. This avoids ambiguity and helps maintain performance.",
        "ground_truth_sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What are the borderless cards available without powerful foils?",
        "hint": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
        "error_sql": "SELECT * FROM cards WHERE borderColor = 'borderless' AND (cardKingdomFoilId IS NULL OR cardKingdomId IS NULL);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries with multiple conditions, ensure you clearly differentiate between the conditions using the correct logical operators. In this case, use the `OR` operator correctly to check if either of the conditions related to `cardKingdomFoilId` and `cardKingdomId` is true. Be cautious with the parentheses to avoid logical errors, and always double-check the conditions you want to apply against your data requirements.",
        "ground_truth_sql": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "difficulty": "simple"
    },
    {
        "question": "List the card names with value that cost more converted mana for the face.",
        "hint": "more converted mana for the face refers to Max(faceConvertedManaCost);",
        "error_sql": "SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve multiple records based on a condition involving maximum values, ensure that you're appropriately querying for all rows that match that condition rather than limiting the result to one. Using `ORDER BY` with `LIMIT` may lead to missing records if multiple cards share the same maximum value. Instead, use a subquery or a `JOIN` to return all cards meeting the criteria derived from the maximum calculation.",
        "ground_truth_sql": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "hint": "below 100 on EDHRec refers to EDHRec <100; with 2015 frame style refers to frameVersion = 2015;",
        "error_sql": "SELECT name FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that data types match the expected values in your SQL queries. For instance, when checking numeric conditions like `edhrecRank < 100`, ensure that any filtering on integers or other data types uses the appropriate syntax\u2014like omitting quotes for numeric fields.",
        "ground_truth_sql": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
        "difficulty": "simple"
    },
    {
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "hint": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
        "error_sql": "SELECT T1.name, T1.rarity \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.rarity = 'mythic' AND T2.status = 'Banned' AND T2.format = 'gladiator';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, always ensure that the column names, table aliases, and conditions precisely match the schema, including casing and specific unique values. In the case of formats or statuses, it's essential to verify the correct spelling and casing, as SQL may be case-sensitive depending on the system in use. Using consistent casing for string comparisons and ensuring there are no typos can prevent errors and misinterpretations in query results.",
        "ground_truth_sql": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
        "difficulty": "moderate"
    },
    {
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "hint": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist; Find all cards refers to return card id",
        "error_sql": "SELECT C.id, R.text \nFROM cards AS C \nINNER JOIN rulings AS R ON C.uuid = R.uuid \nWHERE C.artist = 'Stephen Daniele' AND C.hasContentWarning = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that all relevant conditions are included in the final query, such as returning specific properties like `hasContentWarning`, not just the ruling text. Additionally, always double-check the requirements for the selection criteria to confirm that all necessary data is retrieved efficiently.",
        "ground_truth_sql": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "hint": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
        "error_sql": "SELECT C.name, C.artist, C.isPromo \nFROM cards AS C \nINNER JOIN rulings AS R ON C.uuid = R.uuid \nGROUP BY C.uuid \nHAVING COUNT(R.uuid) = (SELECT MAX(rulings_count) \n                        FROM (SELECT COUNT(R1.uuid) AS rulings_count \n                              FROM rulings AS R1 \n                              GROUP BY R1.uuid));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the conditions in your WHERE clause or HAVING clause directly correspond to the logic you are trying to implement. In the provided query, the initial grouping and counting do not adequately filter for promotional cards. To avoid similar mistakes, validate your query logic by breaking down complex conditions into simpler subqueries or steps, ensuring that each part accurately reflects your intended logic. Additionally, after joining tables, make sure to apply filters before aggregation to avoid unintended results.",
        "ground_truth_sql": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "hint": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
        "error_sql": "SELECT CAST(SUM(CASE WHEN F.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(C.id) AS percentage_chinese_simplified\nFROM cards AS C\nLEFT JOIN foreign_data AS F ON C.uuid = F.uuid;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages, ensure that you're counting the total correctly. In your initial queries, you used a LEFT JOIN, which could include cards without any foreign data, leading to inaccurate counts. Switching to an INNER JOIN ensures that only those cards with corresponding foreign data are counted, thus maintaining the integrity of your calculations. Always double-check how your JOINs affect row counts in aggregate functions.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "difficulty": "moderate"
    },
    {
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "hint": "Aaron Boyd' is artist;",
        "error_sql": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using the COUNT function in SQL, be aware of the distinction between counting distinct values versus counting all occurrences. In this case, to get the total number of card types illustrated by a specific artist, you should count all instances and not just distinct types unless you specifically want to know unique types. Always clarify whether unique counts or total counts are required.",
        "ground_truth_sql": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "difficulty": "simple"
    },
    {
        "question": "What type of promotion is of card 'Duress'?",
        "hint": "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;",
        "error_sql": "SELECT promoTypes \nFROM cards \nWHERE name = 'Duress';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check for NULL values in your queries when dealing with fields that may not have guaranteed data. Including conditions to filter out NULL values can prevent overlooking relevant results and ensure data integrity in your output.",
        "ground_truth_sql": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "hint": "Ancestor's Chosen' is the name of card; type of the card as originally printed refers to originaltype;",
        "error_sql": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check for the presence of NULL values when querying specific columns. If the requirement specifies a non-null condition, include that in your SQL query to avoid retrieving unwanted results and ensure the correctness of your data retrieval.",
        "ground_truth_sql": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "hint": "Angel of Mercy' is the name of card;",
        "error_sql": "SELECT DISTINCT ST.language \nFROM cards AS C \nINNER JOIN sets AS S ON C.setCode = S.code \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE C.name = 'Angel of Mercy';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you understand the relationships between tables before forming your query. In this case, the cards table needed to be directly linked to the translations via the sets table, while making sure to fetch the correct identifiers. Always verify that you are referencing the right keys to establish proper joins.",
        "ground_truth_sql": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "difficulty": "moderate"
    },
    {
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "hint": "restricted refers to status = 'restricted'; have text boxes refers to is Textless = 0;",
        "error_sql": "SELECT COUNT(C.id) \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nWHERE L.status = 'restricted' AND C.isTextless = 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check the case sensitivity of your SQL queries, especially for string comparisons like 'restricted'. Database systems can treat uppercase and lowercase letters differently, which may lead to missed results. Using functions such as `UPPER()` or `LOWER()` can help standardize comparisons. Additionally, remember to use `DISTINCT` when counting unique entries to avoid duplication in results.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "difficulty": "simple"
    },
    {
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "hint": "restricted refers to status = 'restricted'; found in the starter deck refers to isStarter = 1;",
        "error_sql": "SELECT COUNT(DISTINCT C.id) \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nWHERE L.status = 'restricted' AND C.isStarter = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the case sensitivity of string values in your SQL queries, as SQL can be case-sensitive depending on the database system. When filtering by specific string values, ensure that the values match exactly, including case (e.g., 'restricted' vs. 'Restricted').",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "hint": "Benalish Knight' is the name of card; rule of playing card refers to format;",
        "error_sql": "SELECT L.format, L.status \nFROM legalities AS L \nINNER JOIN cards AS C ON L.uuid = C.uuid \nWHERE C.name = 'Benalish Knight';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, ensure all table aliases are clearly defined and used correctly throughout the query. Additionally, consistently referencing the required fields without mixing up aliases or table names can help avoid confusion and errors. Review the names and join conditions to ensure they align with the expected output of the query.",
        "ground_truth_sql": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "difficulty": "simple"
    },
    {
        "question": "What are the card layout of cards with keyword of flying?",
        "hint": "",
        "error_sql": "SELECT layout FROM cards WHERE keywords LIKE '%flying%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check for the exact match of keywords in the database, as they may be case-sensitive or require precise values. In this case, using `=` instead of `LIKE` and ensuring the correct casing ('Flying' instead of 'flying') could prevent incorrect queries.",
        "ground_truth_sql": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "difficulty": "simple"
    },
    {
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "hint": "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data",
        "error_sql": "SELECT L.uuid, F.language FROM legalities AS L INNER JOIN foreign_data AS F ON L.uuid = F.uuid WHERE L.format = 'legacy';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that all necessary tables are included in your JOIN statements based on the requirements specified in the question. In this case, the original query failed because it did not include the `cards` table, which is essential for accessing the `uuid` that corresponds to the `legalities` and `foreign_data` tables. Make sure to fully understand the relationships between tables and include all relevant ones for a complete result set.",
        "ground_truth_sql": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "difficulty": "simple"
    },
    {
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "hint": "future frame version refers to frameVersion = 'future'; legility status refers to status = 'legal';",
        "error_sql": "SELECT COUNT(T1.id) AS card_count, T2.status \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.frameVersion = 'future' \nGROUP BY T2.status;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries that involve aggregation (like COUNT) and joins, ensure you understand the output you want. If you're counting distinct entities grouped by different attributes, make sure you're selecting the correct fields in your SELECT clause and adequately addressing the need for aggregation versus detail. Always test smaller parts of your queries independently to confirm they return expected results before combining them.",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "difficulty": "simple"
    },
    {
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "hint": "set OGW refers to setCode = 'OGW';",
        "error_sql": "SELECT C.name, C.colors \nFROM cards AS C \nINNER JOIN sets AS S ON C.setCode = S.code \nWHERE S.code = 'OGW';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you understand the relationships and constraints between tables in your database schema before writing queries. In this case, the `cards` table does not have a direct column for `setCode`, so trying to join with the `sets` table based on `setCode` directly from `cards` led to incorrect results. Instead, using subqueries or ensuring you're pulling from the correct relationships is essential when datasets are interconnected. Familiarize yourself with the schema and consider how best to structure your SQL queries to reflect those relationships accurately.",
        "ground_truth_sql": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "difficulty": "simple"
    },
    {
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "hint": "set 10E refers to setCode = '10E'; converted mana of 5 refers to convertedManaCost = 5;",
        "error_sql": "SELECT C.name, F.language \nFROM cards AS C \nINNER JOIN foreign_data AS F ON C.uuid = F.uuid \nWHERE C.setCode = '10E' AND C.convertedManaCost = 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL queries appropriately reference the necessary tables and join conditions for the specific relationships needed in the data. In this case, verifying that you are correctly joining the `cards`, `foreign_data`, and `sets` tables, while also ensuring the conditions are precisely aligned with your requirements can prevent errors. Consider breaking down complex queries into smaller parts to validate each component (like pulling data from individual tables) before constructing the full query.",
        "ground_truth_sql": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
        "difficulty": "simple"
    },
    {
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "hint": "Creature - Elf is the originalType;",
        "error_sql": "SELECT c.name, r.date \nFROM cards c \nJOIN rulings r ON c.uuid = r.uuid \nWHERE c.originalType = 'Creature - Elf';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the SELECT statement retrieves the correct columns and matches the expected output format, particularly regarding any requirements for additional fields or specific conditions, and be mindful of using the appropriate table aliases to avoid ambiguity in larger queries.",
        "ground_truth_sql": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "difficulty": "simple"
    },
    {
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "hint": "ID 1-20 refers to id BETWEEN 1 and 20;",
        "error_sql": "SELECT colors, uuid FROM cards WHERE id BETWEEN 1 AND 20;",
        "compiler_hint": "no such column: format",
        "reflective_cot": "### Tip:\nAlways verify the column names and their existence in the database schema before formulating your SQL query. Review the schema carefully to identify the correct table and join conditions needed for retrieving related data, as incorrect naming or missing columns can lead to errors or unexpected results.",
        "ground_truth_sql": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "difficulty": "simple"
    },
    {
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "hint": "uncommon refers to rarity = 'uncommon';",
        "error_sql": "SELECT C.name \nFROM cards AS C \nINNER JOIN rulings AS R ON C.uuid = R.uuid \nWHERE C.rarity = 'uncommon' \nORDER BY R.date ASC \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, be cautious about duplicates. Using `DISTINCT` ensures that if there are multiple rulings for a card, only unique card names are returned. Always consider the potential for duplicate entries and how joins might affect your results.",
        "ground_truth_sql": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "difficulty": "simple"
    },
    {
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "hint": "John Avon refer to artist; foil poweful foils refers to cardKingdomId and cardKingdomFoildId is NOT NULL \n",
        "error_sql": "SELECT COUNT(id) FROM cards WHERE artist = 'John Avon' AND cardKingdomId IS NULL AND cardKingdomFoilId IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, be attentive to the logical conditions used in the WHERE clause. Ensure that you fully understand the meaning of each condition and how they relate to the data requirements. In this case, clarify the distinction between \"non-powerful\" as represented by the absence of both `cardKingdomId` and `cardKingdomFoilId`, rather than just one being NULL. Always test your queries with sample data to confirm they yield the expected results before finalizing them.",
        "ground_truth_sql": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "difficulty": "simple"
    },
    {
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "hint": "unconverted mana refer to manaCost; Rob Alexander refer to artist",
        "error_sql": "SELECT SUM(manaCost) FROM cards WHERE artist = 'Rob Alexander';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the data type of the column you are working with, especially when performing aggregate operations like `SUM()`. In this case, `manaCost` is stored as text, so casting it to a numeric type before summation is essential. Consider using the `typeof()` function or validating the schema to ensure proper type handling.",
        "ground_truth_sql": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "difficulty": "simple"
    },
    {
        "question": "Lists all types of cards available in arena.",
        "hint": "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'",
        "error_sql": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for distinct values, always ensure that the fields being selected are not null if you expect to retrieve distinct results. Use conditions like `IS NOT NULL` for those fields to avoid missing important data in the results. Additionally, consider whether the filtration criteria encompass all necessary cases to prevent unintentional exclusions.",
        "ground_truth_sql": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "hint": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100",
        "error_sql": "SELECT (COUNT(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 END) * 100.0 / COUNT(id)) AS percent_story_spotlight_no_text_box \nFROM cards;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're filtering the dataset correctly before calculating aggregates. For percentage calculations, the numerator should only include records that match your specific criteria, while the denominator should reflect the total count of relevant records, not just any count. Use separate filters for each part to ensure accuracy.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the percentage of cards in Spanish. List them by name.",
        "hint": "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100",
        "error_sql": "SELECT (COUNT(CASE WHEN F.language = 'Spanish' THEN 1 END) * 100.0 / COUNT(T.id)) AS percent_spanish, T.name \nFROM cards AS T \nINNER JOIN foreign_data AS F ON T.uuid = F.uuid;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to separate the calculations properly and maintain the correct aggregation context. Use subqueries for calculating aggregates like percentages while ensuring you're referencing the right dataset, like `COUNT(*)` for the total cards and counting only those in Spanish. Always consider the scope of your `GROUP BY` or affect on joins to avoid misalignment between total counts and specific filtered counts.",
        "ground_truth_sql": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
        "difficulty": "simple"
    },
    {
        "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
        "hint": "Commander block refer to block = 'Commander'; sets refer to code = setCode; Portuguese refer to language = 'Portuguese (Brasil)'",
        "error_sql": "SELECT COUNT(S.code) \nFROM sets AS S \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE S.block = 'Commander' AND ST.language = 'Portuguese (Brasil)';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the exact string values for specific fields in the database, including spaces, punctuation, and case sensitivity. Utilize comprehensive resources or documentation when checking for translations and other attributes to ensure accuracy. For languages, confirm the exact naming conventions used in the database to avoid discrepancies (e.g., \"Portuguese (Brasil)\" vs. \"Portuguese\").",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
        "difficulty": "moderate"
    },
    {
        "question": "Lists by ID all Creature-type cards with legal status.",
        "hint": "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';",
        "error_sql": "SELECT C.id \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nWHERE L.status = 'legal' AND C.types LIKE '%Creature%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nMake sure to verify the expected values for columns, such as `types`. In SQL, `LIKE` with wildcards can produce unintended matches. If you're looking for an exact match (e.g., 'Creature'), use `=` instead of `LIKE`. Additionally, validate if joins and conditions capture all necessary context, as omitted tables (like `rulings` here) can lead to incomplete or inaccurate results. Always clarify the logical requirements before composing your queries.",
        "ground_truth_sql": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
        "difficulty": "simple"
    },
    {
        "question": "How many unknown power cards contain info about the triggered ability",
        "hint": "unknown power cards refers to power is null or power = '*';contain info about the triggered ability refers to text contains 'triggered ability'",
        "error_sql": "SELECT COUNT(id) \nFROM cards \nWHERE (power IS NULL OR power = '*') AND text LIKE '%triggered ability%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you account for the correct tables and their relationships when constructing SQL queries. If you're querying specific attributes or details related to a primary table, make sure to join with related tables that contain the necessary information, such as rulings in this case. Additionally, it's essential to understand the context of the attributes you're querying to avoid missing relevant data.",
        "ground_truth_sql": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "difficulty": "moderate"
    },
    {
        "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
        "hint": "",
        "error_sql": "SELECT artist FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE F.text = 'Das perfekte Gegenmittel zu einer dichten Formation';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are matching the correct column for your queries. In this case, the query needed to look for 'flavorText' instead of 'text' in the `foreign_data` table, as the specific text in the question refers to flavor text rather than the general card text. Additionally, using wildcard searches (LIKE) can help account for any potential discrepancies, such as variations in case or punctuation.",
        "ground_truth_sql": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
        "difficulty": "simple"
    },
    {
        "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
        "hint": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
        "error_sql": "SELECT F.name \nFROM cards AS C \nINNER JOIN foreign_data AS F ON C.uuid = F.uuid \nWHERE C.originalType = 'Creature' AND C.layout = 'normal' AND C.borderColor = 'black' AND C.artist = 'Matthew D. Wilson' AND F.language = 'French';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are using the correct column names in your SQL query. In your case, you used `C.originalType` instead of `C.types`, which is what was necessary for filtering the card types correctly. Always double-check the schema for the exact column names and their contexts before constructing queries to avoid such errors.",
        "ground_truth_sql": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage of Japanese translated sets are expansion sets?",
        "hint": "Japanese translated refers to language = 'Japanese'; expansion sets refers to type = 'expansion'; percentage = DIVIDE(COUNT(language = 'Japanese'),COUNT(language))*100",
        "error_sql": "SELECT (COUNT(S.code) * 100.0 / (SELECT COUNT(*) FROM sets)) AS percentage FROM sets S INNER JOIN set_translations ST ON S.code = ST.setCode WHERE ST.language = 'Japanese' AND S.type = 'expansion';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure your subqueries correctly match the group you are counting. When calculating percentages, confirm that the denominator accurately reflects the total count for the specific condition you are analyzing. Additionally, be careful with using DISTINCT, as it may alter your counts and lead to incorrect logic.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the language of the card with the multiverse number 149934?",
        "hint": "multiverse number 149934 refers to multiverseid = 149934;",
        "error_sql": "SELECT F.language FROM foreign_data AS F INNER JOIN cards AS C ON F.uuid = C.uuid WHERE C.multiverseId = 149934;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:  \nAlways ensure that the column names used in your SQL queries match the definitions in the database schema, including being mindful of data types (e.g., TEXT vs INTEGER). Additionally, confirm that you are using the correct column for filtering, such as using the correct `multiverseId` in the `foreign_data` table. To avoid similar mistakes, it can be useful to outline your query logic before writing it and double-check your column references against the schema.",
        "ground_truth_sql": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
        "difficulty": "simple"
    },
    {
        "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
        "hint": "poweful refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
        "error_sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are selecting all necessary columns for your intended output, especially when needing to reference linked data. In this case, the initial queries only selected the card IDs instead of the paired values (cardKingdomFoilId and cardKingdomId), which were needed for meaningful results. Additionally, double-check the requirement to ensure the order of selection matches the context of the query.",
        "ground_truth_sql": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
        "difficulty": "simple"
    },
    {
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "hint": "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100",
        "error_sql": "SELECT (COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END) * 100.0 / COUNT(CASE WHEN isTextless = 1 THEN 1 END)) AS proportion_textless_normal \nFROM cards;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you clearly understand the requirements of the calculation before constructing your SQL query. In this case, the focus should be on the entire dataset of cards, rather than just those with a specific attribute (like `isTextless`). Also, remember that you need to divide by the total number of cards, not just those that meet a specific condition. Double-checking the condition being counted and the denominator can help avoid logical errors in calculations.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "difficulty": "simple"
    },
    {
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "hint": "don't have multiple faces on a single card side is null",
        "error_sql": "SELECT number \nFROM cards \nWHERE otherFaceIds IS NULL AND subtypes IN ('Angel', 'Wizard');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for multiple values within a single column, ensure to use the correct syntax for checking list values. Instead of using `IN` with multiple distinct values or combining conditions with `OR`, check for exact matches using string comparisons (like `subtypes = 'Angel,Wizard'`) or consider how the data is structured (e.g., if subtypes are stored as a comma-separated string). Additionally, always verify how the data is stored to avoid logical errors in condition checks.",
        "ground_truth_sql": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "difficulty": "simple"
    },
    {
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "hint": "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''",
        "error_sql": "SELECT code, name \nFROM sets \nWHERE mtgoCode IS NULL OR mtgoCode = '' \nORDER BY name \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the conditions in your WHERE clause to ensure they accurately reflect the requirements of your query. In this case, be attentive to the specific nullity conditions you need to check for each column, and make sure your query aligns with the intended logic. Using the appropriate comparison operators and understanding the implications of NULL values can prevent errors in your results.",
        "ground_truth_sql": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "difficulty": "simple"
    },
    {
        "question": "What is the name of set number 5 and its translation?",
        "hint": "set number 5 refers to id = 5",
        "error_sql": "SELECT S.name, ST.translation FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.id = 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are referencing the correct table and column in your queries. The condition for filtering by `id` should reference the primary key of the `sets` table directly, not the `set_translations` table. Always verify that the relevant foreign keys are used correctly and that the filtering criteria is applied to the correct table to prevent confusion.",
        "ground_truth_sql": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "difficulty": "simple"
    },
    {
        "question": "What is the language and expansion type of set number 206?",
        "hint": "set number 206 refers to id = 206",
        "error_sql": "SELECT ST.language, S.type FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.id = 206;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to use the correct identifier when joining tables, and make sure to reference the appropriate primary key or foreign key relationships. In this case, the first two SQL queries incorrectly used `S.id = 206` when they should have checked `T2.id = 206`. Always verify the relationships within your query logic to avoid such mistakes.",
        "ground_truth_sql": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
        "difficulty": "simple"
    },
    {
        "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
        "hint": "",
        "error_sql": "SELECT S.id, S.code \nFROM sets AS S \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE ST.language = 'Italian' AND S.block = 'Shadowmoor' \nORDER BY S.name \nLIMIT 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you use the correct column for ordering and retrieval in your SQL query. In this case, ordering should be based on `T1.id` or `T1.name`, and you shouldn't include a `GROUP BY` clause unless you're aggregating results. Review the intended attributes and their types to avoid misunderstandings regarding how they should be processed or sorted.",
        "ground_truth_sql": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
        "difficulty": "simple"
    },
    {
        "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
        "hint": "available outside of the United States refers to isForeignOnly = 1; has foil cards refers to isFoilOnly = 1; with Japanese writing on them refers to language = 'Japanese'",
        "error_sql": "SELECT S.id FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.isForeignOnly = 1 AND S.isFoilOnly = 1 AND ST.language = 'Japanese';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen formulating SQL queries, carefully double-check the conditions for each filter. Ensure that logical conditions align precisely with the requirements\u2014like distinguishing between \"isForeignOnly\" and \"isNotForeignOnly\". Always verify that the expected values correspond to their intended meanings, as small oversights can lead to incorrect results.",
        "ground_truth_sql": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
        "difficulty": "challenging"
    },
    {
        "question": "Which Russian set of cards contains the most cards overall?",
        "hint": "Russian refers to language = 'Russian'; contains the most cards overall refers to MAX(baseSetSize)",
        "error_sql": "SELECT MAX(S.baseSetSize) \nFROM sets AS S \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE ST.language = 'Russian';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when using aggregate functions like MAX, you group by the appropriate columns to avoid incorrect results. In particular, if you want to get the name of the set along with the maximum base set size, you need to group by the set's identifier (e.g., `S.code`) instead of another column (like `S.name`). This ensures that you're correctly calculating the maximum size per distinct set rather than influencing the result by grouping on a field not intended for aggregation.",
        "ground_truth_sql": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
        "hint": "are only available for online games refers to isOnlineOnly = 1; percentage = DIVIDE(COUNT(isOnlineOnly = 1),COUNT(isOnlineOnly))*100",
        "error_sql": "SELECT (COUNT(CASE WHEN F.language = 'Chinese Simplified' AND C.isOnlineOnly = 1 THEN 1 END) * 100.0 / COUNT(CASE WHEN C.isOnlineOnly = 1 THEN 1 END)) AS percent_chinese_online \nFROM cards AS C \nINNER JOIN foreign_data AS F ON C.uuid = F.uuid \nWHERE C.isOnlineOnly = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the logic of your joins aligns with the desired data set. In this case, the initial queries incorrectly assumed the context of `isOnlineOnly` and incorrectly aggregated counts without properly addressing the set context. Always double-check the join relationships, the correct aggregation and filtering conditions, and ensure that you're counting all relevant records before applying conditions.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
        "difficulty": "moderate"
    },
    {
        "question": "Point out the language of set id \"174\"?",
        "hint": "",
        "error_sql": "SELECT ST.language FROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE S.id = 174;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a specific record by its ID, ensure that you directly filter on the table corresponding to that ID rather than joining multiple tables unnecessarily. In this case, since you're looking for the language of set ID \"174,\" you should query directly from the `set_translations` table where the ID matches, rather than joining it with the `sets` table. This approach helps to prevent confusion and potential errors in the query logic.",
        "ground_truth_sql": "SELECT language FROM set_translations WHERE id = 174",
        "difficulty": "simple"
    },
    {
        "question": "State the set code of the set with release date of 07/13/2007?",
        "hint": "",
        "error_sql": "SELECT code FROM sets WHERE releaseDate = '2007-07-13';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider potential relationships between tables when querying data, especially when attempting to retrieve additional attributes that may not exist in the primary table. Utilizing JOINs can help ensure you gather all relevant information efficiently. Reading the schema carefully for relationships and foreign keys before constructing your query can prevent missing necessary joins.",
        "ground_truth_sql": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "difficulty": "simple"
    },
    {
        "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
        "hint": "",
        "error_sql": "SELECT baseSetSize, code FROM sets WHERE block IN ('Masques', 'Mirage');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check if a relationship exists between tables when querying related data. In this case, using a join between the `sets` and `set_translations` tables allowed retrieval of the desired attributes that may not be directly available in a single table. Also, consider using `DISTINCT` when expecting unique results from joined queries to avoid duplicates.",
        "ground_truth_sql": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
        "difficulty": "simple"
    },
    {
        "question": "Give the code of sets have expansion type of 'expansion'?",
        "hint": "code of sets refers to setCode",
        "error_sql": "SELECT code FROM sets WHERE type = 'expansion';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to consider all relevant tables and their relationships when querying for specific data. In this case, the `set_translations` table was necessary to get the correct set codes linked to the desired type. Utilizing JOINs and understanding foreign key relationships can help avoid missing critical data.",
        "ground_truth_sql": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
        "difficulty": "simple"
    },
    {
        "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
        "hint": "",
        "error_sql": "SELECT F.name, C.type FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE C.watermark = 'boros';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the `DISTINCT` keyword when joining tables and you expect there may be duplicate entries in the results. This can help in returning unique records when the join operation might combine multiple rows from one table with a single row from another.",
        "ground_truth_sql": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
        "difficulty": "simple"
    },
    {
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "hint": "",
        "error_sql": "SELECT F.language, C.flavorText, C.type \nFROM cards AS C \nINNER JOIN foreign_data AS F ON C.uuid = F.uuid \nWHERE C.watermark = 'colorpie';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure the use of `DISTINCT` when querying for non-unique values across multiple tables to avoid duplicate entries in the result set. This is especially important when joining tables where the foreign key relationship could lead to multiple matching rows in the joined table.",
        "ground_truth_sql": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "difficulty": "simple"
    },
    {
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "hint": "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100",
        "error_sql": "SELECT (COUNT(CASE WHEN convertedManaCost = 10 THEN 1 END) * 100.0 / COUNT(convertedManaCost)) AS percent_cmc_10 \nFROM cards \nWHERE name = 'Abyssal Horror';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you always join related tables to access the necessary context for your queries. In this case, properly joining the `cards` table with the `sets` table was essential to filter cards based on their associated set, rather than just filtering by card names directly. Always verify that you're querying the correct data structure, especially when referencing keys found in different tables.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "difficulty": "moderate"
    },
    {
        "question": "Give the code of sets have expansion commander type?",
        "hint": "code of sets refers to setCode",
        "error_sql": "SELECT code FROM sets WHERE type = 'expansion commander';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for specific types or categories that may be associated with additional translations or variations, ensure to join related tables that may contain relevant contextual data. Always confirm the structure and relationships of the tables to include all necessary criteria for accurate results.",
        "ground_truth_sql": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "difficulty": "simple"
    },
    {
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "hint": "",
        "error_sql": "SELECT F.name, C.type FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE C.watermark = 'abzan';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use `DISTINCT` when selecting columns that include potential duplicates from joined tables, especially when aggregating results from multiple records. This ensures that the output remains unique and prevents redundancies.",
        "ground_truth_sql": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "difficulty": "simple"
    },
    {
        "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
        "hint": "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'",
        "error_sql": "SELECT convertedManaCost FROM cards WHERE name = 'Ancestor''s Chosen';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the correct column names and their definitions in the database schema before formulating your queries. In this case, \"convertedManaCost\" was misinterpreted as \"unconvertedManaCost,\" which does not exist in the schema. Additionally, ensure to check for any special notes on how terms are defined and mapped in the context of your data model.",
        "ground_truth_sql": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
        "difficulty": "simple"
    },
    {
        "question": "Among the cards with a white border color, how many of them have unknown power?",
        "hint": "unknown power refers to power = '*' or power is null",
        "error_sql": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND (power = '*' OR power IS NULL);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider using the `LIKE` operator when checking for wildcard characters like `*` in SQL, as the `=` operator cannot correctly handle them. Additionally, ensure you understand the differences between NULL values and string representations to avoid potential logical errors in your queries.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
        "difficulty": "simple"
    },
    {
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "hint": "available in both \"arena\" and \"mtgo\" refers to availability like '%arena,mtgo%'",
        "error_sql": "SELECT COUNT(DISTINCT artist) \nFROM cards \nWHERE borderColor = 'black' AND availability LIKE '%arena,mtgo%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen formulating SQL queries, ensure that your conditions accurately reflect the intended logic. Specifically, when checking for multiple values in a single field, use a method that combines all desired conditions rather than checking them separately with `AND`. For instance, if you're looking for entries that contain both 'arena' and 'mtgo' in the availability column, you can either check for their combination with a single LIKE statement or ensure that both are present in your query logic. Using COUNT with CASE can also help clarify the logic and return accurate results in complex queries.",
        "ground_truth_sql": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "difficulty": "simple"
    },
    {
        "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
        "hint": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater",
        "error_sql": "SELECT name, convertedManaCost \nFROM cards \nWHERE name IN ('Serra Angel', 'Shrine Keeper');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways be clear on your selection criteria and ensure that your ORDER BY clause is capturing the correct sorting for the desired comparison. Specifically, ensure that your final SQL query properly returns the names and the converted mana costs of the specified cards without modifying the selection in the final output. Also, be cautious with LIMIT clauses to avoid unintended data omissions.",
        "ground_truth_sql": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "hint": "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'",
        "error_sql": "SELECT COUNT(ST.id) \nFROM set_translations AS ST \nINNER JOIN cards AS C ON C.setCode = ST.setCode \nWHERE C.name = 'Angel of Mercy';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you clearly understand the relationships between tables and the specific columns you need to join. In this case, the `setCode` in the `cards` table was not directly related to the `setCode` in the `set_translations` table through a clear joined relationship based solely on the card name. Instead, focus on using subqueries to accurately filter relevant records while considering all applicable conditions and relationships.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "hint": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
        "error_sql": "SELECT ST.translation FROM cards AS C \nINNER JOIN sets AS S ON C.setCode = S.code \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE C.name = 'Ancestor''s Chosen' AND ST.language = 'Korean';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when querying for translations, you are appropriately checking against the correct tables and conditions that relate to the specific language and confirm that the translation field is not null. Be meticulous about your join conditions and select statements to avoid missing necessary relationships between the tables. Using aggregate functions like `SUM` with a conditional `CASE` statement can help in succinctly determining the presence of translations without excessive joins.",
        "ground_truth_sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "difficulty": "moderate"
    },
    {
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "hint": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
        "error_sql": "SELECT CASE WHEN mtgoCode IS NOT NULL THEN 'Yes' ELSE 'No' END AS appears_online\nFROM sets\nWHERE mtgoCode IS NOT NULL AND code IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy');",
        "compiler_hint": "no such column: mtgoCode",
        "reflective_cot": "### Tip:\nAlways ensure you are selecting the correct columns from the appropriate tables before executing your query. Understand the relationships between tables and use JOINs properly to access related data. Familiarize yourself with the schema layout to avoid referencing columns that do not exist in the selected table.",
        "ground_truth_sql": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "difficulty": "moderate"
    },
    {
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "hint": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
        "error_sql": "SELECT CASE WHEN COUNT(*) > 0 THEN 'Yes' ELSE 'No' END \nFROM sets \nWHERE name = 'Adarkar Valkyrie' AND isForeignOnly = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are referencing the correct tables and columns when constructing your SQL queries. In this case, the initial queries mistakenly tried to check the card name in the `sets` table instead of joining it with the `cards` table where the card's attributes are correctly defined. Be mindful of the relationships between tables and ensure proper joins to access the relevant data needed for your queries.",
        "ground_truth_sql": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "difficulty": "moderate"
    },
    {
        "question": "What's the German type of the card \"Ancestor's Chosen\"?",
        "hint": "German refers to language = 'German'; \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'",
        "error_sql": "SELECT FD.type \nFROM foreign_data AS FD \nINNER JOIN cards AS C ON FD.uuid = C.uuid \nWHERE C.name = 'Ancestor''s Chosen' AND FD.language = 'German';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you use `DISTINCT` when querying for unique values, especially when dealing with joins that may produce duplicate entries. Additionally, be cautious to verify that the join conditions and filtering criteria match your requirements precisely.",
        "ground_truth_sql": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
        "error_sql": "SELECT R.text \nFROM rulings AS R \nINNER JOIN cards AS C ON R.uuid = C.uuid \nINNER JOIN sets AS S ON C.setCode = S.code \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE S.name = 'Coldsnap' AND ST.language = 'Italian';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your JOIN conditions correctly reference the appropriate tables and their relationships. When filtering for translated records, use the correct table containing the language data in the WHERE clause, and remember to check for distinct values when working with relationships that can produce duplicates.",
        "ground_truth_sql": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "hint": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'; highest converted mana cost refers to MAX(convertedManaCost)",
        "error_sql": "SELECT F.name \nFROM foreign_data F \nJOIN cards C ON F.uuid = C.uuid \nJOIN sets S ON C.setCode = S.code \nWHERE S.name = 'Coldsnap' \nAND F.language = 'Italian' \nAND C.convertedManaCost = (SELECT MAX(convertedManaCost) FROM cards WHERE setCode = S.code);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when you are comparing attributes across different joined tables, you reference the correct table for the specific attribute you are comparing. Additionally, when aiming to find data based on aggregate functions like `MAX`, make sure they operate within the correct context of the data you are interested in, potentially using a separate subquery or appropriate ordering instead of equating directly within the main query.",
        "ground_truth_sql": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "difficulty": "moderate"
    },
    {
        "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
        "hint": "all cards illustrated by Jim Pavelec refers to artist = 'Jim Pavelec'; the text of the ruling refers to text; cards have missing or degraded properties and values if hasContentWarning = 1 else it doesn't have;",
        "error_sql": "SELECT T1.id, T1.name, T2.text, CASE WHEN T1.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS has_degraded_properties \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid \nWHERE T1.artist = 'Jim Pavelec';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the query structure aligns with the desired output format. Pay close attention to the selected columns, table joins, and the conditions applied in the WHERE clause. Comparing the columns in your SELECT statement with those in the Ground Truth can help identify discrepancies. Regularly validate the query logic against the intended results, especially with complex joins and conditions.",
        "ground_truth_sql": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
        "difficulty": "challenging"
    },
    {
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "hint": "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Tenth Edition'",
        "error_sql": "SELECT COUNT(*) \nFROM set_translations AS ST \nINNER JOIN sets AS S ON ST.setCode = S.code \nWHERE S.name = 'Tenth Edition' AND ST.translation IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are counting distinct values when the requirement specifies \"translations\" or similar fields, as duplicates may exist. Use `COUNT(DISTINCT column_name)` to avoid counting the same translation multiple times.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "hint": "Japanese name refers to language = 'Japanese'; card \"Fellwar Stone\" refers to name = 'Fellwar Stone'",
        "error_sql": "SELECT ST.translation \nFROM cards AS C \nINNER JOIN sets AS S ON C.setCode = S.code \nINNER JOIN set_translations AS ST ON S.code = ST.setCode \nWHERE C.name = 'Fellwar Stone' AND ST.language = 'Japanese';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you verify all the join conditions and where clauses used in your SQL query. In this case, the join between `cards`, `sets`, and `set_translations` was not structured correctly, as it didn't account for the association between cards and their respective sets properly. Additionally, always include conditions to filter out null values if necessary, to prevent returning unwanted results.",
        "ground_truth_sql": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
        "hint": "Japanese translation refers to language = 'Japanese'; in non-foil refers to isNonFoilOnly = 1; percentage of Japanese non foil in Japanese cards refers to DIVIDE(SUM(isNonFoilOnly = 1), SUM(language = 'Japanese'))*100",
        "error_sql": "SELECT (SUM(CASE WHEN S.isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(F.uuid)) AS percent_non_foil\nFROM foreign_data AS F \nINNER JOIN cards AS C ON F.uuid = C.uuid \nINNER JOIN sets AS S ON C.setCode = S.code \nWHERE F.language = 'Japanese';",
        "compiler_hint": "no such column: C.isNonFoilOnly",
        "reflective_cot": "### Tip:\nAlways double-check the table schema and ensure that you're joining on the correct columns. Also, verify the logic of your subqueries and ensure they return the expected results before integrating them into your main query. When in doubt, breaking complex queries into smaller pieces and testing them individually can help identify issues.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
        "difficulty": "challenging"
    },
    {
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "hint": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100",
        "error_sql": "SELECT (SUM(CASE WHEN C.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(F.language)) AS percent_online_only_brazil_portuguese \nFROM cards AS C \nINNER JOIN foreign_data AS F ON C.uuid = F.uuid \nWHERE F.language = 'Portuguese (Brazil)';",
        "compiler_hint": "no such column: S.isOnlineOnly",
        "reflective_cot": "### Tip:\nAlways ensure that you're querying the correct tables and their relevant columns for your calculations. It's crucial to double-check the schema and the relationships between the tables in your query, particularly when dealing with joins. In your case, you mistakenly referenced a non-existent alias (`S`) instead of using the correct alias (`C`). Before finalizing your SQL, break down your logic and validate each part of your query, ensuring that you're using the right context for column references and that you're referencing the intended tables.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "difficulty": "challenging"
    },
    {
        "question": "What is the most common visual frame effects among the incredibly powerful foils?",
        "hint": "when both cardKingdomFoilId and cardKingdomId are not null, this foil is incredibly powerful; most common visual frame effects refers to MAX(frameEffects)",
        "error_sql": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(*) DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using aggregate functions like `COUNT()` in conjunction with `GROUP BY`, always ensure that you are counting the correct column to achieve the desired results. In this case, `COUNT(frameEffects)` was needed instead of `COUNT(*)`. Additionally, always review the specific requirements of the query to ensure the correct columns are used for grouping and counting, which can help avoid such mistakes.",
        "ground_truth_sql": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "hint": "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)",
        "error_sql": "SELECT id FROM sets WHERE totalSetSize = (SELECT MAX(totalSetSize) FROM sets WHERE type = 'commander');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen looking to identify a single record based on a condition involving aggregate functions (like MAX), ensure that you properly filter the records by the primary criteria first, rather than just relying on equality. Using `ORDER BY` with `LIMIT 1` directly retrieves the top record according to the desired sorting, simplifying the selection process and avoiding the need for subqueries.",
        "ground_truth_sql": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "hint": "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)",
        "error_sql": "SELECT C.name \nFROM cards C \nJOIN legalities L ON C.uuid = L.uuid \nWHERE L.format = 'duel' \nORDER BY C.manaCost DESC \nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for specific data attributes (like the highest unconverted mana costs), ensure you consistently reference the correct column names. In the initial queries, confusion arose between `manaCost` and `convertedManaCost`. Always double-check the exact requirements of the question and use the appropriate columns in your queries. Additionally, consider validating whether you're aggregating or filtering the intended data before applying ORDER BY and LIMIT clauses.",
        "ground_truth_sql": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "difficulty": "simple"
    },
    {
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "hint": "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format",
        "error_sql": "SELECT S.releaseDate, L.format \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nINNER JOIN sets AS S ON C.setCode = S.code \nWHERE C.rarity = 'mythic' AND L.status = 'Legal' \nGROUP BY C.uuid \nHAVING S.releaseDate = (SELECT MIN(releaseDate) FROM sets WHERE code IN (SELECT setCode FROM cards WHERE rarity = 'mythic'));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are referencing the correct columns for filtering and aggregation. In this case, `originalReleaseDate` should be checked instead of `releaseDate` while also confirming the rarity of the cards before doing aggregations. Always double-check the logical flow of your SQL query to ensure all conditions are appropriately applied to the right data attributes.",
        "ground_truth_sql": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
        "hint": "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Ba\u01f5a'; foreign language is in French refers to language = 'French'",
        "error_sql": "SELECT COUNT(T1.uuid) \nFROM cards AS T1 \nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid \nWHERE T1.artist = 'Volkan Ba\u00c7\u00b5a' AND T2.language = 'French';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use the appropriate aggregation functions and grouping correctly, especially when counting distinct entries. In SQL, if you're counting unique items from a joined table and there's a chance of duplicate rows being generated, consider using a subquery with `GROUP BY` to ensure the counted results are distinct.",
        "ground_truth_sql": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
        "difficulty": "moderate"
    },
    {
        "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
        "hint": "rare refers to rarity = 'rare'; enchantment card refers to types = 'Enchantment'; Abundance cards refers to name = 'Abundance'; format status are all legal refers to status = 'Legal'",
        "error_sql": "SELECT COUNT(DISTINCT T1.uuid) \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.rarity = 'rare' AND T1.type = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you reference the correct column names from your database schema. Double-check for typos or incorrect column names (like \"type\" versus \"types\") that may lead to SQL errors or incorrect results. Using an IDE or a tool that provides auto-completion for SQL queries can help in avoiding such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
        "difficulty": "moderate"
    },
    {
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "hint": "play format refers to format; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(COUNT(status = 'Banned'))",
        "error_sql": "SELECT L.format, C.name \nFROM legalities AS L \nINNER JOIN cards AS C ON L.uuid = C.uuid \nWHERE L.status = 'Banned' \nGROUP BY L.format \nHAVING COUNT(L.status) = (SELECT MAX(banned_count) \n                          FROM (SELECT COUNT(status) AS banned_count \n                                FROM legalities \n                                WHERE status = 'Banned' \n                                GROUP BY format));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen grouping and aggregating in SQL, ensure that you are correctly aligning the logic needed to isolate the desired data points before applying further filters or joins. Specifically, if you need to reference an aggregate result in a subsequent operation, consider using Common Table Expressions (CTEs) or subqueries effectively to clearly define test conditions and streamline the data flow. This helps avoid complex groupings that may inadvertently change the context or relationships between data sets.",
        "ground_truth_sql": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the language of the \"Battlebond\" set?",
        "hint": "\"Battlebond\" set refers to name = 'Battlebond'",
        "error_sql": "SELECT ST.language FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.name = 'Battlebond';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying data across multiple tables, always ensure that you are selecting fields that exist within the context of the query. Specifically, when using JOINs, make sure to differentiate between columns from different tables explicitly, and validate the specific structure of your WHERE conditions to ensure correct referencing of values. Instead of filtering on a derived result, directly use nested queries or CTEs if necessary to maintain clarity and accuracy in the relationships you are querying.",
        "ground_truth_sql": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "difficulty": "simple"
    },
    {
        "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
        "hint": "format of the cards refers to format; illustrator refers to artist; the least amount of cards refers to MIN(artist)",
        "error_sql": "SELECT L.format \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nWHERE C.artist = (SELECT artist FROM cards GROUP BY artist ORDER BY COUNT(*) ASC LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your subqueries return the correct results by thoroughly analyzing the aggregation and GROUP BY clauses. In the initial attempts, the focus was on filtering the artist before aggregating, which can lead to incorrect or incomplete results. Instead, consider joining and grouping properly first, then applying filters or limits as needed. This ensures that the aggregation is performed on the correct dataset before any conditions are applied.",
        "ground_truth_sql": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
        "hint": "AVG(id); releaseDate BETWEEN 1/1/2012 AND 12/31/2015; the common language refers to MAX(COUNT(language))",
        "error_sql": "SELECT AVG(annual_count) AS annual_average, common_language \nFROM (\n    SELECT COUNT(S.id) AS annual_count, \n           MAX(ST.language) AS common_language \n    FROM sets AS S\n    LEFT JOIN set_translations AS ST ON S.code = ST.setCode \n    WHERE S.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' \n    GROUP BY strftime('%Y', S.releaseDate)\n);",
        "compiler_hint": "ambiguous column name: id",
        "reflective_cot": "### Tip:\nAlways use fully qualified column names when joining tables to avoid ambiguity, especially if multiple tables share column names. Additionally, carefully review the grouping logic and ensure it aligns with your aggregation strategy to prevent incorrect counting or averaging.",
        "ground_truth_sql": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "hint": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
        "error_sql": "SELECT S.name FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.language = 'Korean' AND S.code NOT IN (SELECT ST2.setCode FROM set_translations AS ST2 WHERE ST2.language = 'Japanese');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the filtering conditions for both the presence and absence of translations are clearly expressed. In this case, instead of checking for codes that don't have Japanese translations using a `NOT IN` subquery, you should directly check for the presence of Korean translations while excluding any translations with Japanese. This prevents logical errors in how conditions are applied, allowing for clearer and more accurate queries.",
        "ground_truth_sql": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "difficulty": "moderate"
    },
    {
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "hint": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
        "error_sql": "SELECT DISTINCT C.frameVersion, C.name \nFROM cards AS C \nINNER JOIN legalities AS L ON C.uuid = L.uuid \nWHERE C.artist = 'Allen Williams' AND L.status = 'Banned';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for specific conditions like filtering banned cards, be careful to include those conditions appropriately. In your initial queries, you only focused on banned cards but did not account for the need to list all cards by the specified artist regardless of their ban status. Make sure to retrieve all relevant data first and then apply conditional logic, such as using `IIF` or `CASE`, to handle specific needs like marking banned cards distinctly. Always review SQL joins and where conditions to ensure they correctly reflect the required logic.",
        "ground_truth_sql": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "difficulty": "moderate"
    },
    {
        "question": "How many users last accessed the website after 2014/9/1?",
        "hint": "last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'",
        "error_sql": "SELECT COUNT(Id) FROM users WHERE LastAccessDate > '2014-09-01';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the date format used in your SQL queries matches the format of the date column in the database. When comparing dates, consider using proper date functions like `date()` or ensure the date strings correspond exactly to the data types in the database to avoid any potential mismatches.",
        "ground_truth_sql": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "difficulty": "simple"
    },
    {
        "question": "How many posts does the user csgillespie own?",
        "hint": "\"csgillespie\" is the DisplayName of user",
        "error_sql": "SELECT COUNT(*) FROM posts WHERE OwnerDisplayName = 'csgillespie';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the correct foreign key references to link tables when querying. In this case, instead of filtering directly by `OwnerDisplayName` in the `posts` table, you should join with the `users` table to correctly associate the posts with the user's display name. This avoids issues where similar names might exist in different contexts or tables, ensuring the accuracy of your query.",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "difficulty": "simple"
    },
    {
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "hint": "user no. 3025 refers to UserId = '3025'; comment at 20:29:39 on 2014/4/23 refers to CreationDate = '2014/4/23 20:29:39.0'",
        "error_sql": "SELECT FavoriteCount FROM posts WHERE Id = (SELECT PostId FROM comments WHERE UserId = 3025 AND CreationDate = '2014-04-23 20:29:39');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the queried columns are correctly matched to their respective data types and formats in the database. Pay close attention to details such as precise datetime formatting and proper joins for related tables. Utilizing meaningful aliases in your SQL queries can also help clarify which table each column belongs to, promoting better readability and reducing the chances of errors.",
        "ground_truth_sql": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "difficulty": "moderate"
    },
    {
        "question": "Give the only one comment text of the post with parent id 107829.",
        "hint": "one comment refers to CommentCount = '1'",
        "error_sql": "SELECT Text FROM comments WHERE PostId = 107829 LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for related data, always consider the relationships between the tables involved. Pay attention to foreign keys and the conditions that limit results based on the scores or counts of related records. In this case, filtering by both `ParentId` and `CommentCount` was crucial to get the correct results. Always verify if additional filters or joins are necessary to accurately reflect the data structure and requirements outlined in the question.",
        "ground_truth_sql": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "difficulty": "simple"
    },
    {
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "hint": "user no. 23853 refers to UserId = '23853'; at 9:08:18 on 2013/7/12 refers to CreationDate = '2013-07-12 09:08:18.0'; not well-finished refers to ClosedDate IS NULL and vice versa",
        "error_sql": "SELECT CASE WHEN ClosedDate IS NULL THEN 'Not well-finished' ELSE 'Well-finished' END AS PostStatus \nFROM posts \nWHERE Id = (SELECT PostId FROM comments WHERE UserId = 23853 AND CreationDate = '2013-07-12 09:08:18.0');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you correctly specify data types and formats for date comparisons, and always double-check that the subquery returns a single row or value when used in the main query's WHERE clause. Using INNER JOINs can also help ensure that you are accurately linking tables while filtering the results together.",
        "ground_truth_sql": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "difficulty": "moderate"
    },
    {
        "question": "Give the number of votes for the post about data visualization.",
        "hint": "About data visualization is the Title that contains 'data visualization';",
        "error_sql": "SELECT COUNT(*) FROM votes WHERE PostId = (SELECT Id FROM posts WHERE Title LIKE '%data visualization%');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the context and necessary join conditions when dealing with related tables. Instead of relying solely on subqueries, consider using joins which can more effectively limit the data you are working with and prevent unexpected results from occurring. Additionally, verify that your main query addresses all necessary relationships that could affect the count or data retrieved.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data visualization%'",
        "difficulty": "simple"
    },
    {
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "hint": "user no. 24 refers to UserId = OwnerUserId = '24'; times of his/her post than votes = Divide (Count(post.Id), Count(votes.Id))",
        "error_sql": "SELECT (SELECT COUNT(Id) FROM posts WHERE OwnerUserId = 24) * 1.0 / (SELECT COUNT(Id) FROM votes WHERE UserId = 24);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're accurately joining the relevant tables to reflect the relationships between entities, especially when calculating ratios or comparisons. In this case, joining the `votes` and `posts` tables correctly was crucial to relate the votes specifically to the posts owned by the user. Additionally, double-check if you're counting distinct values where necessary to avoid over-counting.",
        "ground_truth_sql": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "difficulty": "moderate"
    },
    {
        "question": "Name the user that commented 'thank you user93!'",
        "hint": "\"thank you user93\" is the Text of comment; user refers to DisplayName",
        "error_sql": "SELECT UserDisplayName FROM comments WHERE Text = 'thank you user93!';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to join related tables when you need information from multiple sources. In this case, the `UserDisplayName` is not stored in the `comments` table but rather in the `users` table. Always identify the necessary relationships between tables and include appropriate joins when querying data from more than one table.",
        "ground_truth_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "difficulty": "simple"
    },
    {
        "question": "Write all comments made by user 'A Lion.'",
        "hint": "\"A Lion\" is the DisplayName of user; comment refers to Text",
        "error_sql": "SELECT Text FROM comments WHERE UserDisplayName = 'A Lion';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're using the appropriate JOINs when querying data across multiple tables by matching foreign keys and primary keys. In this case, the first attempts did not join the `users` table with the `comments` table to properly filter comments based on the user's display name. If you're ever referencing attributes from different tables, remember to check if you need to join them based on their relationships.",
        "ground_truth_sql": "SELECT T2.Text FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'A Lion'",
        "difficulty": "simple"
    },
    {
        "question": "Who is the editor of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "hint": "'Open source tools for visualizing multi-dimensional data' is the Title of Post; editor refers to DisplayName;",
        "error_sql": "SELECT LastEditorDisplayName FROM posts WHERE Title = 'Open source tools for visualizing multi-dimensional data';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are joining tables correctly when you need information from multiple related entities. In this case, the LastEditorDisplayName is found in the users table, so you should join the posts table with the users table using the appropriate foreign key relation (LastEditorUserId or OwnerUserId) to retrieve the editor\u2019s display name.",
        "ground_truth_sql": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "difficulty": "moderate"
    },
    {
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "hint": "\"Vebjorn Ljosa\" is the DisplayName; last edited refers to LastEditorUserId",
        "error_sql": "SELECT Title FROM posts WHERE LastEditorUserId = (SELECT Id FROM users WHERE DisplayName = 'Vebjorn Ljosa');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying a database, ensure that you correctly identify the relationships between tables and the specific fields relevant to your query. In this case, focus on the correct identifier for the action you are interested in (e.g., the last editor of a post) rather than using the owner of the post. Always review the schema and relationships to avoid misunderstandings, and double-check the criteria specified in the question.",
        "ground_truth_sql": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "difficulty": "simple"
    },
    {
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "hint": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
        "error_sql": "SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title = 'Why square the difference instead of taking the absolute value in standard deviation?';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're referencing the correct tables when looking for related data. In this case, comments are linked to posts directly, but edits to posts are tracked in a separate `postHistory` table. When querying for comments related to edited post content, make sure to use the appropriate tables that reflect the desired relationships and data.",
        "ground_truth_sql": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "difficulty": "moderate"
    },
    {
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "hint": "bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName; title mentioning variance refers to Title include 'variance'",
        "error_sql": "SELECT DisplayName \nFROM users \nWHERE Id = (\n    SELECT UserId \n    FROM votes \n    WHERE BountyAmount = 50 AND PostId IN (\n        SELECT Id \n        FROM posts \n        WHERE Title LIKE '%variance%'\n    )\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use JOINs to directly combine related tables instead of relying on subqueries. This improves readability and often performance. In this case, joining the `posts`, `votes`, and `users` tables allowed you to directly access the necessary fields, eliminating potential issues with nested queries and making the SQL clearer.",
        "ground_truth_sql": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "hint": "tagged as  'humor' refers to tag = '<humor>'; comment of the post refers to Text; average view count = AVG(ViewCount)",
        "error_sql": "SELECT p.Title, c.Text, AVG(p.ViewCount) AS AverageViewCount \nFROM posts p \nJOIN comments c ON p.Id = c.PostId \nJOIN postLinks pl ON p.Id = pl.PostId \nJOIN tags t ON pl.RelatedPostId = t.Id \nWHERE t.TagName = 'humor' \nGROUP BY p.Title, c.Text;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the JOIN conditions and WHERE clauses are accurate. Specifically, confirm that you are correctly targeting the relevant relationships and attributes, such as verifying the tag filtering and ensuring joins match intended keys in related tables. In this case, using the appropriate field to link posts with their tags and examining if the tag presence is properly filtered is crucial for getting correct results.",
        "ground_truth_sql": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "difficulty": "moderate"
    },
    {
        "question": "How many users are awarded with more than 5 badges?",
        "hint": "more than 5 badges refers to Count (Name) > 5; user refers to UserId",
        "error_sql": "SELECT COUNT(DISTINCT UserId) FROM badges GROUP BY UserId HAVING COUNT(Name) > 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you properly nest your aggregation functions and the `HAVING` clause is applied within the same level of the query where you aggregate your data. When needing to filter aggregated results, use a subquery that first groups and aggregates the data, and only then apply further conditions. This helps clarify the intention of your query and prevents misinterpretation of the aggregation logic.",
        "ground_truth_sql": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "difficulty": "simple"
    },
    {
        "question": "How many users from New York have a teacher and supporter badge?",
        "hint": "\"Supporter\" and \"Teachers\" are both Name of badge; 'New York' is the Location; user refers to UserId",
        "error_sql": "SELECT COUNT(DISTINCT b.UserId) \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE (b.Name = 'Supporter' OR b.Name = 'Teacher') \nAND u.Location = 'New York' \nGROUP BY b.UserId \nHAVING COUNT(DISTINCT b.Name) = 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating results based on multiple criteria, ensure that you use the `HAVING` clause correctly to filter on the grouped results. Instead of counting distinct `UserId` and checking the number of distinct badge names, use direct filtering in the `WHERE` clause where possible. It\u2019s important to follow the logical sequence: first filter to get the relevant rows, then group and aggregate accordingly, ensuring that any necessary conditions on the groups are accurately applied.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "difficulty": "simple"
    },
    {
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "hint": "",
        "error_sql": "SELECT Reputation FROM users WHERE Id = (SELECT OwnerUserId FROM posts WHERE Id = 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to gather information about a post and its creator, make sure to examine the correct relationships and tables in the database schema. In your initial queries, you focused only on the `users` and `posts` tables without considering other relevant tables such as `comments` that could also provide essential context. Always review the schema thoroughly to ensure you are checking the right associations or looking for information in the appropriate tables.",
        "ground_truth_sql": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "difficulty": "simple"
    },
    {
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "hint": "having at least 1000 view refers to Views > = 1000; user refers to UserId",
        "error_sql": "SELECT UserId \nFROM postHistory \nGROUP BY PostId, UserId \nHAVING COUNT(*) = 1 \nAND UserId IN (SELECT OwnerUserId FROM posts WHERE ViewCount >= 1000);",
        "compiler_hint": "no such column: Views",
        "reflective_cot": "### Tip:\nAlways carefully check the column names in the tables you are querying. Misnaming a column or confusing it with similarly named columns from different tables can lead to errors. When writing queries, especially aggregations, ensure that you clearly understand the relationships between the tables and the fields you need to reference, as this will help you avoid these common pitfalls. Additionally, utilizing SQL IDEs with autocomplete features can minimize typing errors.",
        "ground_truth_sql": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which users have posted the most comments. List out the user's badge?",
        "hint": "user with the most comments refers to UserId where Max(Count(Id)",
        "error_sql": "SELECT u.DisplayName, b.Name \nFROM users u \nJOIN comments c ON u.Id = c.UserId \nJOIN badges b ON u.Id = b.UserId \nGROUP BY u.Id \nHAVING COUNT(c.Id) = (SELECT MAX(CommentCount) \n                      FROM (SELECT UserId, COUNT(Id) AS CommentCount \n                            FROM comments \n                            GROUP BY UserId));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries that involve aggregation, ensure that your GROUP BY clause includes all non-aggregated fields in your SELECT statement. Additionally, be mindful of the scope of your subqueries\u2014ensure they return the intended values without conflicting with the outer query. Use clearer joins and simplify your subqueries to maintain clarity and correctness.",
        "ground_truth_sql": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "hint": "",
        "error_sql": "SELECT PostHistoryTypeId FROM postHistory WHERE PostId = 3720; \nSELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720;",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "### Tip:\nAlways combine multiple queries into a single statement using subqueries or JOINs when the database system allows it. This not only reduces the number of executions but also enhances performance and avoids errors related to executing multiple statements at once.",
        "ground_truth_sql": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "difficulty": "simple"
    },
    {
        "question": "List out all post that are related to post ID 61217 and what is the popularity of this post?",
        "hint": "post related refers to RelatedPostId; popularity refers to ViewCount",
        "error_sql": "SELECT p.Id, p.ViewCount FROM posts p INNER JOIN postLinks pl ON p.Id = pl.RelatedPostId WHERE pl.PostId = 61217;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the direction of your joins and ensure that you are referencing the correct columns for your conditions. In cases involving relationships, make sure to clarify which table's column represents the relationship you are interested in (e.g., `PostId` vs. `RelatedPostId`) to avoid confusion.",
        "ground_truth_sql": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 61217",
        "difficulty": "simple"
    },
    {
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "hint": "score more than 60 refers to Score > 60",
        "error_sql": "SELECT p.Id, p.OwnerUserId FROM posts p WHERE p.Score > 60;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you fully understand the requirements and context of the query. In this case, the goal was to find user IDs associated with posts that have a score above 60, which involves referencing the `postHistory` table, not just the `posts` table. When uncertain, clarify the relationships between tables and include all necessary joins or subqueries to gather the required data.",
        "ground_truth_sql": "SELECT PostId, UserId FROM postHistory WHERE PostId IN ( SELECT Id FROM posts WHERE Score > 60 )",
        "difficulty": "simple"
    },
    {
        "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
        "hint": "in 2011 refers to year (CreatinDate) = 2011",
        "error_sql": "SELECT SUM(FavoriteCount) FROM posts WHERE OwnerUserId = 686 AND strftime('%Y', CreaionDate) = '2011';",
        "compiler_hint": "no such column: CreationDate",
        "reflective_cot": "### Tip:\nWhen writing SQL queries, always ensure that you verify the exact names of the columns in the database schema, including checking for typos or differences in spelling. In particular, pay attention to the creation date columns or other key identifiers that are critical for filtering your results. Additionally, consider using subqueries or JOINs where necessary to ensure you are referencing the correct context and relationships between tables. Always double-check nested queries or filters to maintain the integrity of your results.",
        "ground_truth_sql": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
        "difficulty": "simple"
    },
    {
        "question": "How many users obtained the \"Announcer\" badge?",
        "hint": "\"Announcer\" is the Name of badge; user refers to UserId",
        "error_sql": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Announcer';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you understand the difference between distinct counts and total counts in SQL queries. When counting unique users, using `COUNT(DISTINCT UserId)` is correct for counting unique entries, but if your logic requires just the total number of rows that meet a condition, `COUNT(id)` may suffice. Confirm your requirements before constructing your query.",
        "ground_truth_sql": "SELECT COUNT(id) FROM badges WHERE Name = 'Announcer'",
        "difficulty": "simple"
    },
    {
        "question": "State the detailed content of the comment which was created on 7/19/2010 7:25:47 PM.",
        "hint": "detailed content of the comment refers to Text; created on 7/19/2010 7:16:14 PM refers to CreationDate = '2010-07-19 19:16:14.0'",
        "error_sql": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nBe attentive to the exact values and formats specified in the question. Double-check both the date and time components to ensure the query matches the required criteria. Using proper date-time formatting is crucial, especially when filtering data based on timestamps. Always verify the context of the requirements before constructing your SQL query.",
        "ground_truth_sql": "SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:16:14.0'",
        "difficulty": "simple"
    },
    {
        "question": "What are the name of badge that users who have the highest reputation obtained?",
        "hint": "highest reputation refers to Max(Reputation); user refers to UserId",
        "error_sql": "SELECT Name FROM badges WHERE UserId = (SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find related data from multiple tables, using joins can often provide more accurate results than subqueries, especially when needing to retrieve data from both tables. Ensure that you consider how different records may relate to each other and structure your query accordingly to avoid missing necessary relationships.",
        "ground_truth_sql": "SELECT T2.name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY T1.Reputation DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "hint": "",
        "error_sql": "SELECT Name FROM badges WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Pierre');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying data that involves relationships between multiple tables, it's often beneficial to use JOINs instead of subqueries. This approach can enhance readability and sometimes improve performance by reducing the complexity of the execution. Always consider how tables relate to each other and construct queries that align with those relationships.",
        "ground_truth_sql": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "difficulty": "simple"
    },
    {
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "hint": "\"Organizer\" is the Name of badge; teenager refers to Age BETWEEN 13 AND 18; percentage = Divide (Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) *100",
        "error_sql": "SELECT (COUNT(DISTINCT u.Id) * 100.0 / COUNT(DISTINCT b.UserId)) AS PercentageOfTeenageOrganizerBadgeUsers \nFROM badges b \nJOIN users u ON b.UserId = u.Id \nWHERE b.Name = 'Organizer' AND u.Age BETWEEN 13 AND 18;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages in SQL, ensure that the denominator does not evaluate to zero. Always check for the inclusion of all relevant conditions and consider using aggregate functions judiciously to avoid potential division by zero errors. Additionally, ensure you're accurately combining conditional logic and counts to reflect your query's intent clearly.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "hint": "created on 7/19/2010 7:19:56 PM refers to CreationDate = '2010-07-19 19:19:56.0'",
        "error_sql": "SELECT T2.Score FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.CreaionDate = '2010-07-19 19:19:56.0';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the column names in your SQL queries for spelling errors, as even a small typo can lead to incorrect results or errors. In this case, ensure you refer to the correct column name (`CreationDate` instead of `CreaionDate`) when querying the database. Additionally, it can be helpful to reference the schema while writing your queries to confirm correct syntax and column names.",
        "ground_truth_sql": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "difficulty": "simple"
    },
    {
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "hint": "detailed content of the comment refers to Text; created on 7/19/2010 7:37:33 PM CreationDate = 2010-07-19 19:37:33.0'",
        "error_sql": "SELECT T2.Text FROM comments AS T2 INNER JOIN posts AS T1 ON T2.PostId = T1.Id WHERE T1.CreaionDate = '2010-07-19 19:37:33';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check for any spelling mistakes in column names and ensure you\u2019re referencing the correct table's columns as specified in the schema to avoid errors in your SQL queries. Additionally, ensure you're using the correct column for filtering (in this case, `CreationDate` instead of `CreaionDate`).",
        "ground_truth_sql": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "difficulty": "simple"
    },
    {
        "question": "What are the name of badges that users who have the lowest reputation obtained?",
        "hint": "lowest reputation refers to Min(Reputation); user refers to UserId",
        "error_sql": "SELECT Name FROM badges WHERE UserId = (SELECT Id FROM users ORDER BY Reputation ASC LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to use proper joins to combine tables when multiple conditions or relationships between entities are involved. Utilizing `INNER JOIN` allows you to directly associate relevant rows from different tables, leading to more accurate results. Always validate the relationships and conditions specified in your query to ensure they align with your data structure.",
        "ground_truth_sql": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
        "difficulty": "simple"
    },
    {
        "question": "How many users were from New York?",
        "hint": "New York refers to Location;",
        "error_sql": "SELECT COUNT(Id) FROM users WHERE Location LIKE '%New York%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the possibility of data variations or specific formatting in the database. When querying for locations or similar fields, it\u2019s best to use exact matches if you expect uniformity, or apply wildcard searches only if you anticipate variability. It\u2019s crucial to verify and understand the data being queried to ensure your conditions reflect the possible values accurately.",
        "ground_truth_sql": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "difficulty": "simple"
    },
    {
        "question": "Which users have the highest number of views?",
        "hint": "users have the highest number of views refer to DisplayName where MAX(Views);",
        "error_sql": "SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are retrieving all necessary columns in your query. If you need the user IDs alongside the display names, include them in your SELECT statement to avoid limitations in your results. Additionally, always verify that your query matches the intended output and requirements before finalizing it.",
        "ground_truth_sql": "SELECT Id, DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "difficulty": "simple"
    },
    {
        "question": "What is the name of tags used by John Salvatier's?",
        "hint": "DisplayName = 'John Salvatier';",
        "error_sql": "SELECT T.TagName FROM tags AS T INNER JOIN posts AS P ON T.ExcerptPostId = P.Id INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'John Salvatier';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you're targeting the correct relationship between tables when querying data. In this case, the `tags` table is linked to the `posts` table through `ExcerptPostId`, which may not directly relate to the posts authored by a specific user. Instead, consider looking at the `postHistory` or `posts` directly related to the user to find all tags associated with their contributions. Always verify the table relationships and the fields used to join them to prevent misdirected queries.",
        "ground_truth_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'John Salvatier'",
        "difficulty": "simple"
    },
    {
        "question": "How many posts were created by Daniel Vassallo?",
        "hint": "DisplayName = 'Daniel Vassallo';",
        "error_sql": "SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Daniel Vassallo');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen crafting SQL queries, ensure you understand the relationships between tables and the context of the data you're querying. In this case, posts may not directly link to users through the `OwnerUserId` field in the `posts` table; you need to confirm if the correct association to look for was actually through the `postHistory` table where ownership may need to be considered. Always double-check the table structure and relationships to avoid producing inaccurate queries.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "difficulty": "simple"
    },
    {
        "question": "How many votes were made by Harlan?",
        "hint": "DisplayName = 'Harlan';",
        "error_sql": "SELECT COUNT(*) FROM votes WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you consider the relationships between tables when querying data. In this case, simply counting votes based on the user ID isn\u2019t sufficient if you need to account for specific criteria, such as the posts voted on by the user. Using joins can allow you to track relevant data associated with multiple tables, ensuring a more accurate result.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'",
        "difficulty": "simple"
    },
    {
        "question": "Which post by slashnick has the most answers count? State the post ID.",
        "hint": "most answers count refers to MAX(AnswerCount); post by slashnick refers to DisplayName = 'slashnick';",
        "error_sql": "SELECT Id FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'slashnick') AND AnswerCount = (SELECT MAX(AnswerCount) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'slashnick'));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you fully understand the relationships between tables and the context of the query requirements. In this case, the initial queries incorrectly focused only on the `posts` table without considering the `postHistory` table, which holds relevant information linking to the correct user. Always verify that all necessary joins and relationships are included to capture the correct data.",
        "ground_truth_sql": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "hint": "Has higher popularity means the post has higher view count ; calculation = MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
        "error_sql": "SELECT OwnerDisplayName, MAX(ViewCount) AS MaxViewCount FROM posts WHERE OwnerUserId IN (SELECT Id FROM users WHERE DisplayName IN ('Harvey Motulsky', 'Noah Snyder')) GROUP BY OwnerDisplayName;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you join the necessary tables to access related data. In your initial queries, you were only querying the `posts` table. To correctly aggregate view counts according to user display names, you must join the `users` table to accurately associate post owners with their respective display names. Make sure to include all relevant tables in your queries to extract the data you need effectively.",
        "ground_truth_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "How many posts by Matt Parker have more than 4 votes?",
        "hint": "more than 4 votes refer to PostId > 4; DisplayName = 'Matt Parker';",
        "error_sql": "SELECT COUNT(*) FROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName = 'Matt Parker' \nAND (SELECT COUNT(*) FROM votes v WHERE v.PostId = p.Id) > 4;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting conditional results in subqueries, ensure to aggregate the results correctly and use `HAVING` instead of `WHERE` when filtering based on aggregate counts. This prevents the logic from being applied to the wrong set of data and ensures accuracy in your conditions. Always test the relational logic by breaking down the query into simpler parts if necessary before combining them.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE T1.DisplayName = 'Matt Parker' GROUP BY T2.PostId, T4.Id HAVING COUNT(T4.Id) > 4",
        "difficulty": "moderate"
    },
    {
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "hint": "Negative comment refers to score < 60; DisplayName = 'Neil McGuigan';",
        "error_sql": "SELECT COUNT(*) FROM comments WHERE Score < 60 AND UserId IN (SELECT Id FROM users WHERE DisplayName = 'Neil McGuigan');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you fully understand the relationships between the tables and the context of the query. Double-check the logic of how the joins or subqueries are constructed to accurately connect the data across related entries. Consider using explicit joins when dealing with multiple tables to clarify the relationships and conditions being applied.",
        "ground_truth_sql": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "difficulty": "simple"
    },
    {
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "hint": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
        "error_sql": "SELECT TagName \nFROM tags \nWHERE ExcerptPostId IN (SELECT Id FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes') AND CommentCount = 0);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query logic correctly considers the relationships between tables, especially when dealing with multiple conditions or joins. In complex queries, validate the joins and subqueries to ensure they accurately reflect the data relationships and desired filters. Pay close attention to column references that must be consistent across different tables.",
        "ground_truth_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "hint": "DIVIDE(COUNT(PostId WHERE TagName = 'r')), (COUNT(PostId WHERE DisplayName = 'Community')) as percentage; R language refers to tagname = 'r'",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN T2.TagName = 'r' THEN 1 END) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN tags AS T2 ON T1.Id = T2.ExcerptPostId WHERE T1.OwnerDisplayName = 'Community'",
        "compiler_hint": "no such column: T1.DisplayName",
        "reflective_cot": "### Tip:\nAlways verify that the columns you reference in your SQL queries actually exist in the tables you're using. In the first query, `T1.DisplayName` was incorrect because the `posts` table does not include a `DisplayName` column; instead, it should be drawn from the `users` table. To prevent such errors, carefully check the schema and confirm column existence before writing your query. Additionally, understanding the relationships between the tables and their columns can help in crafting accurate joins and conditions.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "hint": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));",
        "error_sql": "SELECT \n    (SELECT SUM(ViewCount) FROM posts WHERE OwnerUserId IN (SELECT Id FROM users WHERE DisplayName = 'Mornington')) - \n    (SELECT SUM(ViewCount) FROM posts WHERE OwnerUserId IN (SELECT Id FROM users WHERE DisplayName = 'Amos')) AS ViewCountDifference;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL queries accurately join the necessary tables to access all required fields. In this case, user display names needed to be properly linked to their posts, which required joining the `users` table with the `posts` table through an intermediary table like `postHistory`. Additionally, verify the logic of calculations through testing with sample data to ensure correctness.",
        "ground_truth_sql": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "difficulty": "moderate"
    },
    {
        "question": "How many posts were created on 21st July, 2010?",
        "hint": "created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2012-07-21 23:59:59';",
        "error_sql": "SELECT COUNT(*) FROM posts WHERE CreaionDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';",
        "compiler_hint": "no such column: CreationDate",
        "reflective_cot": "### Tip:\nAlways double-check the column names for typos or inconsistencies, especially if they're not part of well-known specifications. Use `DESCRIBE table_name;` or equivalent commands to verify column names before writing queries.",
        "ground_truth_sql": "SELECT COUNT(id) FROM postHistory WHERE date(CreationDate) = '2010-07-21'",
        "difficulty": "simple"
    },
    {
        "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
        "hint": "positive comments refer to Score > 60;",
        "error_sql": "SELECT T1.Title, T2.UserDisplayName \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.Score > 60;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the join conditions in your SQL queries correctly reference the appropriate columns. In the first query, you mistakenly checked `T1.Score > 60` when the requirement was to filter based on the comment `Score`. Additionally, always carefully verify the table structure and relationships to avoid referencing the wrong columns in the ON clause or WHERE conditions.",
        "ground_truth_sql": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
        "difficulty": "simple"
    },
    {
        "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
        "hint": "",
        "error_sql": "SELECT COUNT(*) AS PostHistoryCount, CreationDate AS LastEditDate FROM postHistory WHERE PostId = (SELECT Id FROM posts WHERE Title = 'What is the best introductory Bayesian statistics textbook');",
        "compiler_hint": "no such column: LastEditDate",
        "reflective_cot": "### Tip:\nAlways ensure that you clarify which table the columns belong to, especially when dealing with multiple tables in a join or subquery. In cases where multiple tables might have overlapping column names, explicitly specify the table or alias to avoid ambiguity.",
        "ground_truth_sql": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
        "difficulty": "simple"
    },
    {
        "question": "Describe the last accessed date and location of the users who received the outliers badge.",
        "hint": "Outliers is the name of the badge;",
        "error_sql": "SELECT LastAccessDate, Location FROM users WHERE Id IN (SELECT UserId FROM badges WHERE Name = 'Outliers');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the syntax and casing of string literals in your SQL queries match exactly, especially when dealing with case-sensitive databases. For instance, if the badge name is stored as 'outliers', referencing it as 'Outliers' will lead to no results. Using inner joins instead of subqueries can also optimize the query for better performance and clarity.",
        "ground_truth_sql": "SELECT T1.LastAccessDate, T1.Location FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'outliers'",
        "difficulty": "simple"
    },
    {
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "hint": "",
        "error_sql": "SELECT Title FROM posts WHERE Id = (SELECT PostId FROM comments WHERE Text = 'How to tell if something happened in a data set which monitors a value over time');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find related data in a database, ensure you understand the relationships between tables. In this case, the original queries failed because they only looked at comments directly related to a post, without considering how posts can be linked to other related posts through a dedicated table (like `postLinks`). Always review the schema to identify all necessary joins and relationships for your data retrieval.",
        "ground_truth_sql": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "difficulty": "simple"
    },
    {
        "question": "List the post IDs and badge names of the user Samuel in 2013.",
        "hint": "Samuel refers to UserDisplayName; YEAR(CreationDate) = 2013 relates to PostId; YEAR(Date) = 2013 relates to the badge;",
        "error_sql": "SELECT p.Id, b.Name \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nJOIN badges b ON b.UserId = u.Id \nWHERE u.DisplayName = 'Samuel' \nAND strftime('%Y', p.CreaionDate) = '2013' \nAND strftime('%Y', b.Date) = '2013';",
        "compiler_hint": "no such column: u.UserDisplayName",
        "reflective_cot": "### Tip:\nAlways double-check the column names in your queries, particularly when they come from multiple tables. Pay attention to the specific aliases used for each table to ensure you\u2019re referencing the correct attribute. If a column does not exist or is misnamed, it will lead to errors in the query. Consulting the schema closely before writing or revising SQL statements can help prevent such issues.",
        "ground_truth_sql": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the owner's display name of the most popular post?",
        "hint": "Higher view count means the post has higher popularity; the most popular post refers to MAX(ViewCount);",
        "error_sql": "SELECT OwnerDisplayName FROM posts WHERE ViewCount = (SELECT MAX(ViewCount) FROM posts);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are retrieving data from related tables when needed. In this case, the owner's display name is stored in the `users` table, so you must join or retrieve from the appropriate table that holds the desired information, using foreign keys to connect the data. Always check the relationships between your tables to avoid missing relevant data.",
        "ground_truth_sql": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "difficulty": "simple"
    },
    {
        "question": "Write down the related posts titles and link type IDs of the post \"What are principal component scores?\".",
        "hint": "Title = 'What are principal component scores?';",
        "error_sql": "SELECT p.Title, pl.LinkTypeId \nFROM posts p \nJOIN postLinks pl ON p.Id = pl.RelatedPostId \nWHERE p.Title = 'What are principal component scores?';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you fully understand the relationships between tables in your database schema. In this case, when looking for related posts, it's crucial to join posts not only with postLinks but also back to posts again to properly access the related post information. Visualizing the schema or writing down the relationships can help clarify the necessary joins to produce accurate results.",
        "ground_truth_sql": "SELECT T3.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE T1.Title = 'What are principal component scores?'",
        "difficulty": "simple"
    },
    {
        "question": "Describe the display name of the parent ID for child post with the highest score.",
        "hint": "If the parent id is not null, the post is the child post; the highest score refers to MAX(Score);",
        "error_sql": "SELECT u.DisplayName FROM posts AS child JOIN posts AS parent ON child.ParentId = parent.Id JOIN users AS u ON parent.OwnerUserId = u.Id WHERE child.Score = (SELECT MAX(Score) FROM posts WHERE ParentId IS NOT NULL);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your filtering criteria in subqueries correctly identify the rows you want to work with. Use appropriate sorting and limiting functions to refine your results, and make sure to test your logic incrementally to confirm it reflects the desired relationships and hierarchies within your data.",
        "ground_truth_sql": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1 )",
        "difficulty": "simple"
    },
    {
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "hint": "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;",
        "error_sql": "SELECT COUNT(*) \nFROM posts AS P \nINNER JOIN votes AS V ON P.Id = V.PostId \nWHERE strftime('%Y', P.CreaionDate) = '2011' AND V.BountyAmount = 50;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're filtering based on the correct attributes and their respective tables. In your queries, you used the `CreationDate` from the `posts` table when the bounty relates to the `votes` table. Always double-check that your conditions match the relevant context of the data, especially when dealing with multiple tables.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "difficulty": "simple"
    },
    {
        "question": "What is the title of the post with the oldest post link?",
        "hint": "the oldest post link refers to MIN(CreaionDate);",
        "error_sql": "SELECT Title FROM posts WHERE Id = (SELECT PostId FROM postLinks WHERE CreationDate = (SELECT MIN(CreationDate) FROM postLinks));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways validate your SQL syntax and ensure that you are using the correct column names and table structures. Additionally, use joins instead of subqueries where appropriate to simplify the query and enhance performance. Double-check the data you're filtering on, like ensuring you're working with the right date fields and that they have been spelled correctly. In the case of your query, typos like \"CreaionDate\" instead of \"CreationDate\" led to incorrect results.",
        "ground_truth_sql": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?",
        "hint": "favorite amount of 4 or more refers to FavoriteCount > = 4; Location = 'United Kingdom';",
        "error_sql": "SELECT COUNT(DISTINCT u.Id) FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE u.Location = 'United Kingdom' AND p.FavoriteCount >= 4;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use explicit SQL syntax, especially with JOIN operations. It's helpful to apply aliases consistently and choose between 'INNER JOIN' or 'JOIN' to clearly express the type of join being performed. This can prevent ambiguity and improve readability. Moreover, double-check column names and conditions for typos or mismatches.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average number of posts voted by the oldest users?",
        "hint": "average number of posts voted refers to AVG(PostId) FROM votes; the oldest users refer to MAX(Age);",
        "error_sql": "SELECT AVG(PostCount) AS AveragePostsVoted \nFROM (SELECT COUNT(PostId) AS PostCount \n      FROM votes \n      WHERE UserId IN (SELECT Id FROM users WHERE Age = (SELECT MAX(Age) FROM users)) \n      GROUP BY UserId);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating the average of a specific attribute, ensure that you're directly applying the AVG function to that attribute instead of counting occurrences first. In this case, instead of counting `PostId` and then averaging the counts, you should calculate the average directly from `PostId` related to the specific users' votes. Always review the SQL functions and the data you are aggregating to avoid unnecessary complications.",
        "ground_truth_sql": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "difficulty": "simple"
    },
    {
        "question": "Which post has the highest score? Please give its id and title's name.",
        "hint": "the highest score refers to MAX(Score); owner's name refers to DisplayName;",
        "error_sql": "SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you understand the relationships between tables and incorporate necessary joins when retrieving data that involves multiple tables. In this case, the owner's DisplayName from the users table was required alongside the post's Id and Title from the posts table. Always check if additional data is needed from related tables and construct your SQL queries accordingly.",
        "ground_truth_sql": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "hint": "the most valuable post in 2015 refers to MAX(FavoriteCount) where year(CreationDate) = 2010;",
        "error_sql": "SELECT Id, OwnerDisplayName FROM posts WHERE FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts WHERE strftime('%Y', CreaionDate) = '2010');",
        "compiler_hint": "no such column: CreationDate",
        "reflective_cot": "### Tip:\nAlways double-check the column names and ensure they match exactly with the schema definition. Pay attention to any potential typos, such as missing letters or incorrect casing, as these will lead to errors in SQL queries.",
        "ground_truth_sql": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "hint": "total views refer to ViewCount; Name the user refers to DisplayName; post 'Computer Game Datasets' refers to Text = 'Computer Game Datasets';",
        "error_sql": "SELECT p.ViewCount, u.DisplayName \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE p.Title = 'Computer Game Datasets';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you consider the correct table and column relationships when querying complex data. In this case, since we were interested in the last editor of the post and the content of the post, the correct approach was to reference the `postHistory` table to find the relevant entry for `'Computer Game Datasets'`, rather than relying solely on the `posts` table. Always analyze the requirements carefully to identify the appropriate data sources.",
        "ground_truth_sql": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the total number of posts with views above average.",
        "hint": "views above average refer to ViewCount > AVG(ViewCount);",
        "error_sql": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your final query includes an aggregate function (like COUNT) correctly following the intended output. When counting the entries that meet a condition, it\u2019s essential to keep the structure focused on the desired output rather than mistakenly altering the result set in nested queries. Always test and run the query to check if the output matches your expectation before finalizing it.",
        "ground_truth_sql": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "difficulty": "simple"
    },
    {
        "question": "How many comments were added to the post with the highest score?",
        "hint": "the highest score refers to MAX(Score);",
        "error_sql": "SELECT CommentCount FROM posts WHERE Score = (SELECT MAX(Score) FROM posts);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find aggregated information based on maximum values, ensure that you are joining the relevant tables correctly and using aggregation functions like `COUNT()` in conjunction with grouping. In this case, the initial queries attempted to retrieve a single column's value rather than counting the comments associated with the post. Always check the relationships between the tables to accurately reflect your query's objective.",
        "ground_truth_sql": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "hint": "last to edit refers to MAX(LastEditDate);",
        "error_sql": "SELECT DisplayName, Location FROM users WHERE Id = (SELECT LastEditorUserId FROM posts WHERE Id = 183 AND LastEditDate = (SELECT MAX(LastEditDate) FROM posts WHERE Id = 183));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your queries accurately target the correct relationships between tables and focus on the appropriate aggregate functions that match your requirements. In this case, using `ORDER BY` and `LIMIT` was not the right approach to retrieve the last editor's information; instead, utilize `INNER JOIN` to seamlessly connect related tables and accurately filter based on the edit date. Additionally, test your queries step-by-step to validate each part before running the entire statement.",
        "ground_truth_sql": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
        "hint": "SUBTRACT(Date from stats_badges, CreationDate) where DisplayName = 'Zolomon';",
        "error_sql": "SELECT JULIANDAY(Date) - JULIANDAY(CreationDate) AS DaysToGetBadge \nFROM badges \nJOIN users ON badges.UserId = users.Id \nWHERE users.DisplayName = 'Zolomon';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the data types and formats are compatible when performing calculations or comparisons in SQL. In the initial queries, the difference operation was attempted between different data types (JULIANDAY returns a floating point number, while direct date subtraction may lead to type conflicts). Use consistent functions, like `JULIANDAY` for both dates, and clearly define aliases in your joins to avoid ambiguity.",
        "ground_truth_sql": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
        "hint": "the latest created user account refers to MAX(CreationDate);",
        "error_sql": "SELECT COUNT(p.Id) AS PostCount, COUNT(c.Id) AS CommentCount \nFROM users u \nLEFT JOIN posts p ON u.Id = p.OwnerUserId \nLEFT JOIN comments c ON u.Id = c.UserId \nWHERE u.CreationDate = (SELECT MAX(CreationDate) FROM users);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure your aggregations (like COUNT) do not unintentionally collapse the data you need to analyze. When joining multiple tables and using aggregate functions, you might end up counting the same entities multiple times due to the nature of joins, unless you specifically isolate the data you want to aggregate first. Consider using subqueries or DISTINCT in your COUNT operations to get an accurate count of unique entities.",
        "ground_truth_sql": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.",
        "hint": "the latest comment refers to MAX(CreationDate);",
        "error_sql": "SELECT c.Text, c.UserDisplayName \nFROM comments c \nJOIN posts p ON c.PostId = p.Id \nWHERE p.Title = 'Analysing wind data with R' \nORDER BY c.CreationDate DESC \nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are joining the correct tables and columns that relate to the data you want. In your original SQL query, you correctly joined the `comments` and `posts` tables, but you didn't include the necessary join with the `users` table to correctly retrieve the user's display name. Additionally, verify that you are using the correct fields for ordering the results based on your desired criteria.",
        "ground_truth_sql": "SELECT T3.Text, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T2.Title = 'Analysing wind data with R' ORDER BY T1.CreationDate DESC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "Count the number of posts with a tag specified as 'careers'.",
        "hint": "tag specified as 'careers' refers to TagName = 'careers';",
        "error_sql": "SELECT COUNT(*) FROM posts WHERE Tags LIKE '%careers%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when counting posts by tags, you first retrieve the relevant tag ID from the `tags` table and then filter the `posts` table based on that ID, instead of relying on a text search within a delimited string. This avoids errors that arise from improperly structured data. For an accurate approach, establish a proper relationship between the `posts` and `tags` tables, potentially using a junction table for many-to-many relationships.",
        "ground_truth_sql": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'",
        "difficulty": "simple"
    },
    {
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "hint": "The higher reputation the user has the more influence; percentage = DIVIDE(COUNT(stats_posts.Id where Score > 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation));",
        "error_sql": "SELECT (COUNT(CASE WHEN p.Score > 50 THEN 1 END) * 100.0 / COUNT(*)) AS Percentage \nFROM posts p \nWHERE p.OwnerUserId = (SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that subqueries used in filtering conditions correctly relate to the main query context. When calculating aggregates like percentages, double-check that joins or filters are properly set to include relevant data from all tables involved, particularly when needing to associate user attributes (like reputation) with their posts. Using INNER JOINs can create clearer associations and make sure you are measuring across the right dataset.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "difficulty": "challenging"
    },
    {
        "question": "In comments with 0 score, how many of the posts have view count lower than 5?",
        "hint": "view count lower than 5 refers to ViewCount < 5;",
        "error_sql": "SELECT COUNT(DISTINCT T1.Id) FROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.Score = 0 AND T1.ViewCount < 5; ",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you clearly distinguish between the tables you are querying and what columns belong to each table. Specifically, verify the conditions in your WHERE clause to match them to the correct columns of the respective tables, and make sure you maintain the logical order in your joins to avoid mixing up field sources.",
        "ground_truth_sql": "SELECT COUNT(T1.Id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ViewCount < 5 AND T2.Score = 0",
        "difficulty": "simple"
    },
    {
        "question": "In posts with 1 comment, how many of the comments have 0 score?",
        "hint": "in posts with 1 comment refers to CommentCount = 1;",
        "error_sql": "SELECT COUNT(*) FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE CommentCount = 1) AND Score = 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are accurately referencing the necessary columns in your queries. In this case, it was vital to join the `comments` and `posts` tables on the correct relationship and to filter by the associated post's score in the `posts` table, not the `comments` table. Always double-check the logical relationships and conditions based on your dataset schema to avoid misplaced filtering.",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
        "difficulty": "simple"
    },
    {
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "hint": "",
        "error_sql": "SELECT COUNT(DISTINCT UserId) FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score = 0 AND u.Age = 40;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure consistency in your table aliases (naming conventions) across the entire query. Double-check that you use the same alias for both the SELECT statement and other parts of the query. Standardizing your naming (e.g., using T1 and T2 for the same tables) can enhance readability and reduce errors.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "difficulty": "simple"
    },
    {
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "hint": "percentage = DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10))*100, (COUNT(UserId where Score BETWEEN 5 and 10));",
        "error_sql": "SELECT (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END) * 100.0 / COUNT(DISTINCT c.UserId)) AS Percentage\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score BETWEEN 5 AND 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use aggregated functions correctly and consider the context of your calculations. In particular, be aware of how you apply COUNT and CASE statements, and verify if you need DISTINCT values based on your requirements. Using appropriate joining techniques and ensuring that you're correctly handling NULL values and data types can prevent computation errors and miscalculations in SQL queries.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "hint": "15 super powers refers to COUNT(full_name) > 15",
        "error_sql": "SELECT s.full_name \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id \nGROUP BY s.id \nHAVING COUNT(hp.power_id) > 15;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use the correct columns in the `GROUP BY` clause that match the selected columns. In cases where you are aggregating data, ensure that all non-aggregated selected columns are included in the `GROUP BY` clause to avoid potential SQL errors. Additionally, using `DISTINCT` can sometimes clarify intent when you're expecting unique results.",
        "ground_truth_sql": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
        "difficulty": "simple"
    },
    {
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "hint": "name refers to superhero_name; the tallest hero refers to MAX(height_cm); published by Marvel Comics refers to publisher_name = 'Marvel Comics'",
        "error_sql": "SELECT s.superhero_name, s.height_cm \nFROM superhero s \nJOIN publisher p ON s.publisher_id = p.id \nWHERE p.publisher_name = 'Marvel Comics' \nORDER BY s.height_cm DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the need for ranking functions (like RANK() or ROW_NUMBER()) when sorting data, especially when the requirement specifies a ranking. Additionally, ensure that any specific aggregation or window functions are applied to present the data in the desired format.",
        "ground_truth_sql": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "difficulty": "moderate"
    },
    {
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "hint": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; most common color refers to COUNT(superhero.id) DESC;",
        "error_sql": "SELECT c.colour, COUNT(s.id) AS superhero_count \nFROM superhero s \nJOIN publisher p ON s.publisher_id = p.id \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE p.publisher_name = 'Marvel Comics' \nGROUP BY c.colour \nORDER BY superhero_count DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen grouping results in SQL, always group by the correct identifier that uniquely distinguishes the values in the selected column. In the context of aggregating data on colors, ensure you group by the color's primary key (e.g., `c.id`) if it is used to join with other tables. This helps prevent incorrect aggregations and ensures accurate results. Also, consider using analytical functions like `RANK()` for ranking purposes, which may provide more insightful results in certain contexts.",
        "ground_truth_sql": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "difficulty": "moderate"
    },
    {
        "question": "Who is the dumbest superhero?",
        "hint": "the dumbest superhero refers to MIN(attribute_value) where attribute_name = 'Intelligence'",
        "error_sql": "SELECT s.superhero_name \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nJOIN attribute a ON ha.attribute_id = a.id \nWHERE a.attribute_name = 'Intelligence' \nAND ha.attribute_value = (SELECT MIN(attribute_value) \n                          FROM hero_attribute \n                          JOIN attribute ON hero_attribute.attribute_id = attribute.id \n                          WHERE attribute.attribute_name = 'Intelligence');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL queries match the logical flow of the data retrieval process. Pay special attention to how aggregates, such as `MIN`, interact with the rest of your query when substituting results. When looking for minimum values, careful usage of `ORDER BY` with `LIMIT` can sometimes be clearer and more efficient, helping to avoid subqueries that may complicate the intended logic.",
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the name of the superhero that has the most powers?",
        "hint": "name of the superhero refers to superhero_name; superhero that has the most powers refers to MAX(COUNT(superhero_name))",
        "error_sql": "SELECT s.superhero_name \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id \nGROUP BY s.superhero_name \nHAVING COUNT(hp.power_id) = (SELECT MAX(power_count) \n                              FROM (SELECT COUNT(hp.power_id) AS power_count \n                                    FROM hero_power hp \n                                    GROUP BY hp.hero_id));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using aggregate functions like `COUNT` in SQL queries, make sure to group correctly to avoid incorrect results. Always ensure your `GROUP BY` clause matches the columns you're selecting and any subqueries you use to compare counts should be properly structured to return single values rather than a sublist of grouped results. This reduces the chance of discrepancies in the aggregation and helps maintain clarity on which attributes you're working with.",
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "hint": "published by Marvel Comics refers to publisher_name = 'Marvel Comics'; superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment = 'Bad'; calculation = MULTIPLY(DIVIDE(SUM(alignment = 'Bad); count(id)), 100)",
        "error_sql": "SELECT \n    (SELECT COUNT(DISTINCT s.id) \n     FROM superhero s \n     JOIN publisher p ON s.publisher_id = p.id \n     JOIN alignment a ON s.alignment_id = a.id \n     WHERE p.publisher_name = 'Marvel Comics' AND a.alignment = 'Bad') * \n    100.0 / COUNT(DISTINCT s.id) AS percentage,\n    (SELECT COUNT(DISTINCT s.id) \n     FROM superhero s \n     JOIN publisher p ON s.publisher_id = p.id \n     JOIN alignment a ON s.alignment_id = a.id \n     WHERE p.publisher_name = 'Marvel Comics' AND a.alignment = 'Bad') AS marvel_bad_count\nFROM superhero s;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to separate aggregate calculations from individual counts. In your initial queries, the denominator (total superhero count) was treated incorrectly relative to the context of the calculations. Formulate aggregate queries clearly, focusing on returning the same context for both numerator and denominator, even if that means using subqueries.",
        "ground_truth_sql": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "difficulty": "challenging"
    },
    {
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "hint": "185 cm tall refers to height_cm = 185; human superhero refers to race = 'human'; hair colour refers to colour where hair_colour_id = colour.id;",
        "error_sql": "SELECT c.colour \nFROM superhero s \nJOIN colour c ON s.hair_colour_id = c.id \nJOIN race r ON s.race_id = r.id \nWHERE s.height_cm = 185 AND r.race = 'human';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the exact case and spelling for string comparisons in SQL, as SQL is case-sensitive for string values. In this case, \"human\" should be capitalized as \"Human\" to match the value in the database. Additionally, verify the use of table aliases and ensure that column names are appropriately qualified to avoid ambiguity.",
        "ground_truth_sql": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "difficulty": "moderate"
    },
    {
        "question": "How many heroes have stealth power?",
        "hint": "stealth power refers to power_name = 'stealth';",
        "error_sql": "SELECT COUNT(DISTINCT hp.hero_id) \nFROM superpower sp \nJOIN hero_power hp ON sp.id = hp.power_id \nWHERE sp.power_name = 'stealth';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you use consistent casing for string comparisons in SQL queries. SQL is case-sensitive depending on the database system being used. For example, 'stealth' and 'Stealth' might be treated as different values. It's best practice to check the exact case used in your database to avoid any mismatches.",
        "ground_truth_sql": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "difficulty": "simple"
    },
    {
        "question": "What is the hero's full name with the highest attribute in strength?",
        "hint": "highest attribute in strength refers to MAX(attribute_value) WHERE attribute_name = 'strength';",
        "error_sql": "SELECT s.full_name \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nJOIN attribute a ON ha.attribute_id = a.id \nWHERE a.attribute_name = 'Strength' \nAND ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute ha2 JOIN attribute a2 ON ha2.attribute_id = a2.id WHERE a2.attribute_name = 'Strength');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the case sensitivity of column names and values is correct in SQL queries, as SQL can be sensitive to capitalization in certain contexts. Additionally, double-check your JOIN conditions and ensure that the attribute name matches the exact spelling in the database schema. Using aliases (like T1, T2, T3) can help improve readability and prevent confusion in complex queries.",
        "ground_truth_sql": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the average of superheroes with no skin colour?",
        "hint": "average = DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)); no skin colour refers to skin_colour_id WHERE colour.id = 1;",
        "error_sql": "SELECT COUNT(s.id) * 1.0 / SUM(CASE WHEN s.skin_colour_id IS NULL THEN 1 ELSE 0 END) AS average_no_skin_colour \nFROM superhero s;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating averages involving counts and conditions, ensure you are counting the correct subsets explicitly. Using `SUM` with a condition helps focus on a specific case, while `COUNT` without conditions counts all rows. Also, be cautious about which columns you're summing or counting based on their relationships to conditions or joins, as this can lead to incorrect numerator or denominator values. Always check the context of your conditions and the data being aggregated.",
        "ground_truth_sql": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "difficulty": "simple"
    },
    {
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "hint": "eyes refers to eye_colour_id; hair refers to hair_colour_id; skin colour refers to skin_colour_id; female superheroes refers to gender = 'Female'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "error_sql": "SELECT DISTINCT c_eye.colour AS eye_color, c_hair.colour AS hair_color, c_skin.colour AS skin_color\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN publisher p ON s.publisher_id = p.id\nJOIN colour c_eye ON s.eye_colour_id = c_eye.id\nJOIN colour c_hair ON s.hair_colour_id = c_hair.id\nJOIN colour c_skin ON s.skin_colour_id = c_skin.id\nWHERE g.gender = 'Female' AND p.publisher_name = 'Dark Horse Comics';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that you are explicitly selecting and combining the correct columns in your `SELECT` statement. Pay attention to the relationships and join conditions to avoid confusion with column names. Always test your queries step by step, verifying that the output matches your expectations, especially when dealing with multiple joins. In this case, using `JOIN` on the `colour` table and selecting the proper attributes (colour names) right away could prevent oversights in the final output.",
        "ground_truth_sql": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "difficulty": "challenging"
    },
    {
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "hint": "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
        "error_sql": "SELECT (SUM(CASE WHEN g.gender = 'Female' AND p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) * 100.0 / COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END)) AS percentage\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN publisher p ON s.publisher_id = p.id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentages in SQL, always ensure your divisor (the total count) correctly reflects the subset you're interested in. Use conditional aggregation wisely and avoid attempts to reference the condition of one subset (e.g., all female heroes) while counting another subset (e.g., all heroes published by a specific publisher). Always use the correct criteria in both the numerator and denominator to ensure accurate calculations. Additionally, consider using the `NULLIF` function to prevent division by zero errors.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female'",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the average height for each superhero.",
        "hint": "average = DIVIDE(SUM(height_cm), COUNT(all heros));",
        "error_sql": "SELECT AVG(height_cm) AS average_height \nFROM superhero;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when calculating averages, you account for `NULL` values in the denominator. Use conditional counting (like `COUNT(column_name)` or `COUNT(*)`) to avoid miscalculating the average when some entries might not contribute to your intended calculation. Additionally, casting the sum to a float type ensures that integer division does not occur, which can lead to inaccurate results.",
        "ground_truth_sql": "SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero",
        "difficulty": "simple"
    },
    {
        "question": "Which hero was the fastest?",
        "hint": "which hero refers to superhero_name; fastest refers to MAX(attribute_value) WHERE attribute_name = 'Speed';",
        "error_sql": "SELECT s.superhero_name \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nJOIN attribute a ON ha.attribute_id = a.id \nWHERE a.attribute_name = 'Speed' \nAND ha.attribute_value = (SELECT MAX(attribute_value) \n                          FROM hero_attribute \n                          WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed'));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen attempting to find a hero with the maximum attribute value, avoid using a subquery that retrieves just the maximum value on its own. Instead, use an `ORDER BY` clause combined with `LIMIT` to directly sort the results based on the desired attribute while retrieving the corresponding hero. This ensures you get the correct hero associated with the maximum value without the risk of mismatching rows.",
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many superheroes didn't have any publisher?",
        "hint": "didn't have any publisher refers to publisher.id = 1;",
        "error_sql": "SELECT COUNT(DISTINCT s.id) \nFROM superhero s \nWHERE s.publisher_id IS NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to understand the specific conditions or logic required by the question. In this case, the requirement was to count superheroes without a publisher, but the focus was mistakenly placed on counting those with `NULL` publisher IDs instead. Always carefully analyze the requirements and verify your logic against the expected outcomes, especially when dealing with joins and conditions.",
        "ground_truth_sql": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.id = 1",
        "difficulty": "simple"
    },
    {
        "question": "Who is the tallest superhero?",
        "hint": "who refers to superhero_name; tallest superhero refers to MAX(height_cm);",
        "error_sql": "SELECT superhero_name \nFROM superhero \nWHERE height_cm = (SELECT MAX(height_cm) FROM superhero);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve a single record based on aggregate functions like MAX, consider using an ORDER BY clause with LIMIT instead of relying solely on a subquery. This method is more efficient and helps avoid potential issues with ties in the aggregated data.",
        "ground_truth_sql": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the power ID of cryokinesis?",
        "hint": "power ID refers to superpower.id; cryokinesis refers to power_name = 'cryokinesis';",
        "error_sql": "SELECT id \nFROM superpower \nWHERE power_name = 'cryokinesis';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that string comparisons in SQL are case-sensitive according to the database's configuration. When searching for specific text values, double-check the exact casing of those values in your database entries, as this can lead to missing results if the cases do not match.",
        "ground_truth_sql": "SELECT id FROM superpower WHERE power_name = 'Cryokinesis'",
        "difficulty": "simple"
    },
    {
        "question": "List the full names of superheroes with missing weight.",
        "hint": "missing weight refers to weight_kg = 0 OR weight_kg = NULL;",
        "error_sql": "SELECT s.full_name \nFROM superhero s \nWHERE s.weight_kg = 0 OR s.weight_kg IS NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways validate constraints like uniqueness and NULL handling when formulating your queries. To avoid overlooking potential issues with data retrieval, ensure that you consider all relevant conditions\u2014such as distinguishing between `NULL` values and other potential indicators (like `0`)\u2014and explicitly include conditions reflecting your requirements comprehensively.",
        "ground_truth_sql": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "difficulty": "simple"
    },
    {
        "question": "What is the race of the superhero with maximum attribute value?",
        "hint": "maximum attribute value refers to MAX(attribute_value);",
        "error_sql": "SELECT r.race \nFROM hero_attribute ha \nJOIN superhero s ON ha.hero_id = s.id \nJOIN race r ON s.race_id = r.id \nWHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen attempting to identify a maximum value and its associated records, ensure to use an ordering mechanism (like `ORDER BY`) along with a limit constraint (like `LIMIT 1`) to directly retrieve the highest attribute value entry, rather than relying on equality with a subquery. This approach ensures you capture the appropriate record without false matches that might occur with multiple identical maximum values.",
        "ground_truth_sql": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List down at least five full names of superheroes with blue eyes.",
        "hint": "blue eyes refers to colour.colour = 'Blue' WHERE eye_colour_id = colour.id; Name of superheroes refers to superhero_name;",
        "error_sql": "SELECT DISTINCT s.full_name \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE c.colour = 'Blue' \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, always double-check the required field in the `SELECT` clause. In this case, ensure you're selecting the correct column that represents the superhero's name, which was `superhero_name` instead of `full_name`. Also, be mindful of any additional conditions specified in the question to ensure all necessary information is included in the query.",
        "ground_truth_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "Give the race of the blue-haired male superhero.",
        "hint": "blue-haired refers to colour.colour = 'blue' WHERE hair_colour_id = colour.id; male refers to gender = 'male';",
        "error_sql": "SELECT r.race \nFROM superhero s \nJOIN colour c ON s.hair_colour_id = c.id \nJOIN gender g ON s.gender_id = g.id \nJOIN race r ON s.race_id = r.id \nWHERE c.colour = 'blue' AND g.gender = 'male';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the casing of string literals in your SQL queries matches the values stored in the database. SQL is typically case-sensitive for string comparisons, so make sure to check the expected case for any specific values like 'blue' and 'male' in the database.",
        "ground_truth_sql": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "difficulty": "moderate"
    },
    {
        "question": "Name the tallest superhero.",
        "hint": "tallest superhero refers to MAX(height_cm);",
        "error_sql": "SELECT s.superhero_name \nFROM superhero s \nWHERE s.height_cm = (SELECT MAX(height_cm) FROM superhero);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve a single record based on a maximum value, consider using an `ORDER BY` clause combined with `LIMIT 1` for simplicity and efficiency, as it directly sorts the results and limits the output to the highest value. Avoid subqueries for such straightforward calculations unless necessary, as they can complicate the query and potentially lead to incorrect results in some contexts.",
        "ground_truth_sql": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "hint": "race number refers to raceId; second qualifying period refers to q2; best lap time refers to MIN(q2);",
        "error_sql": "SELECT d.surname FROM qualifying AS q INNER JOIN drivers AS d ON q.driverId = d.driverId WHERE q.raceId = 19 AND q.q2 = (SELECT MIN(q2) FROM qualifying WHERE raceId = 19);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the possibility of NULL values when dealing with string comparisons in SQL. In the context of lap times, if `q2` contains NULL for any driver, it could affect the results. Using `ORDER BY` in combination with `LIMIT 1` is often a more reliable approach for retrieving the best entry when direct comparison operations (like MIN) can be problematic due to NULL entries.",
        "ground_truth_sql": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "hint": "introduction of races refers to url; Circuit de Barcelona-Catalunya is a name of circuit;",
        "error_sql": "SELECT DISTINCT r.url \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Circuit de Barcelona-Catalunya'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways clearly define your query's intention, whether you need details from the main table or related entities. If looking for URLs of races, ensure to join the appropriate tables and reference the right attributes based on what you aim to retrieve. Additionally, pay attention to the context of the attributes involved in the joins to avoid discrepancies in filtering.",
        "ground_truth_sql": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "hint": "Renault is a name of constructor;",
        "error_sql": "SELECT DISTINCT C.location \nFROM circuits AS C \nINNER JOIN races AS R ON C.circuitId = R.circuitId \nINNER JOIN constructorResults AS CR ON R.raceId = CR.raceId \nINNER JOIN constructors AS CO ON CR.constructorId = CO.constructorId \nWHERE CO.name = 'Renault'",
        "compiler_hint": "no such column: T1.position",
        "reflective_cot": "### Tip:\nAlways ensure that you fully understand the relationships between tables, especially regarding foreign keys and relevant columns for the query context. Use explicit joins based on the actual schema and data relationships, and validate that the columns being selected exist in the relevant tables. Familiarizing yourself with the table structures and their attributes beforehand can help avoid such errors.",
        "ground_truth_sql": "SELECT DISTINCT T1.position FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T2.name = 'Renault'",
        "difficulty": "simple"
    },
    {
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "hint": "",
        "error_sql": "SELECT COUNT(r.raceId) \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE r.year = 2010 AND c.country NOT IN ('Asia', 'Europe');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering by geographical regions, ensure you check specific country names rather than generic regional labels like \"Asia\" and \"Europe.\" Create a comprehensive list of all countries that belong to those regions and exclude them from your query. This helps avoid misclassifying races based on incomplete geographic definitions.",
        "ground_truth_sql": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "difficulty": "moderate"
    },
    {
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "hint": "information about races refers to url;",
        "error_sql": "SELECT r.url \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Sepang International Circuit'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use `DISTINCT` when querying to avoid duplicate results, especially when joining tables. Ensure your SQL query is structured correctly by understanding the relationships and filtering conditions, and consider using appropriate aliases for clarity.",
        "ground_truth_sql": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "difficulty": "simple"
    },
    {
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "hint": "race number refers to raceId;",
        "error_sql": "SELECT d.nationality \nFROM qualifying AS q \nINNER JOIN drivers AS d ON q.driverId = d.driverId \nWHERE q.raceId = 355 AND q.q2 = '0:01:40'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:  \nAlways consider potential formatting variations when querying time fields. Instead of using an exact match with the format (like '0:01:40'), consider using pattern matching with `LIKE` to account for possible variations in leading zeros or other format discrepancies. This ensures your query captures all relevant results without being overly strict on the format.",
        "ground_truth_sql": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "difficulty": "simple"
    },
    {
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "hint": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'",
        "error_sql": "SELECT d.number \nFROM qualifying AS q \nINNER JOIN drivers AS d ON q.driverId = d.driverId \nWHERE q.raceId = 903 AND q.q3 LIKE '0:01:54%'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the pattern you use in the `LIKE` clause is appropriate for the data you are trying to match, paying close attention to the exact formatting of the time values. If looking for a specific format only partially, consider using wildcards effectively. In this case, checking for a leading minute digit (i.e., using `'1:54%'` instead of an exact match with seconds) can capture more possible correct results while still conforming to the structure of the time data.",
        "ground_truth_sql": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "difficulty": "simple"
    },
    {
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "hint": "Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL);",
        "error_sql": "SELECT COUNT(*) \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Bahrain Grand Prix' AND r.time IS NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you include all necessary conditions in your SQL queries from the outset, including specific filtering criteria for the relevant tables. In cases involving multiple joins, double-check that you are accurately referencing the appropriate tables and including all required fields in the WHERE clause to fetch the correct dataset. This can significantly reduce the likelihood of missing key conditions and ensure your query returns the intended results.",
        "ground_truth_sql": "SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL",
        "difficulty": "simple"
    },
    {
        "question": "Show me the season page of year when the race No. 901 took place.",
        "hint": "race number refers to raceId;",
        "error_sql": "SELECT s.year \nFROM races AS r \nINNER JOIN seasons AS s ON r.year = s.year \nWHERE r.raceId = 901;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query selects the correct columns that are relevant to your requirements. In this case, the query should have selected the season URL instead of just the year. Double-check the output fields based on the context of the query to avoid similar mistakes in the future.",
        "ground_truth_sql": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "difficulty": "simple"
    },
    {
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "hint": "drivers who finished the race refers to time is not empty (i.e. time IS NOT NULL); race number refers to raceId; date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT d.driverRef \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE r.raceId = 592 AND r.time IS NOT NULL \nORDER BY d.dob ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you account for all necessary conditions in your SQL query. In this case, checking for the presence of a non-null date of birth (`dob`) for the drivers was crucial because it can lead to incorrect results or exclusion of valid entries. Additionally, consider using clear aliases for readability and double-check that the sorting logic aligns with the intended results (oldest first rather than youngest). Always test your queries in parts to validate each condition's effectiveness.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "hint": "player and driver are synonyms; the lap time of 0:0M:SS refers to lapTime.time LIKE 'M:SS%';race number refers to raceId; introduction website of the drivers refers to url;",
        "error_sql": "SELECT d.url \nFROM lapTimes AS lt \nINNER JOIN drivers AS d ON lt.driverId = d.driverId \nWHERE lt.raceId = 161 AND lt.time LIKE '0:01:27';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for time values formatted as 'M:SS', use the LIKE operator with appropriate wildcards to match only the minutes and seconds parts. For example, using `LIKE '1:27%'` allows for variations in format, ensuring cases where the minute part is less than 10 are captured as well (e.g., '0:1:27' would not match). Always verify the format of your data and use wildcards as necessary to account for possible variations.",
        "ground_truth_sql": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 161 AND T1.time LIKE '1:27%'",
        "difficulty": "moderate"
    },
    {
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "hint": "race number refers to raceId;",
        "error_sql": "SELECT d.nationality \nFROM qualifying AS q \nINNER JOIN drivers AS d ON q.driverId = d.driverId \nWHERE q.raceId = 347 AND q.q2 = '00:01:15';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure time formats match the data stored in the database. In this case, using `LIKE` is beneficial if the Q2 time might be stored in a varied format. Additionally, consider possible leading zeros in the string representation of the time. Using string manipulation functions can help ensure accurate comparisons.",
        "ground_truth_sql": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'",
        "difficulty": "simple"
    },
    {
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "hint": "race number refers to raceId; had the Q3 time as 0:0M:SS refers to q3 LIKE 'M:SS%'",
        "error_sql": "SELECT d.code \nFROM qualifying AS q \nINNER JOIN drivers AS d ON q.driverId = d.driverId \nWHERE q.raceId = 45 AND q.q3 LIKE '0:01:33%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nBe cautious with using exact matches versus wildcard patterns when dealing with time formatting. In this case, the query should have used a LIKE condition that accommodates variable minute prefixes instead of a strict equality to account for potential formatting variations (e.g., '0:01:33' vs '1:33'). Always analyze the data format and consider using wildcards when working with data types that may have leading zeros or variable formats.",
        "ground_truth_sql": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 45 AND T1.q3 LIKE '1:33%'",
        "difficulty": "simple"
    },
    {
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "hint": "race number refers to raceId; drivers who finished the race refers to time has value; the youngest is a driver where MAX(dob);",
        "error_sql": "SELECT d.driverRef FROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE r.raceId = 872 AND r.time IS NOT NULL \nORDER BY d.dob DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for the youngest driver, ensure that the ORDER BY clause correctly ranks the desired column (dob) in the right direction. In this case, to find the youngest person, you should use ORDER BY in ascending order (ASC). However, also be careful to select the appropriate column data you need (forename and surname) rather than just the driver reference. Always double-check the logical operators and ensure the query matches the intended requirements.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "hint": "race number refers to raceId; the best lap time refers to MIN(time)",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS fullName \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE r.raceId = 348 AND r.time = (SELECT MIN(time) FROM results WHERE raceId = 348);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are querying the correct table for the specific data you're interested in. In this case, the best lap times were stored in the `lapTimes` table, not the `results` table. Familiarize yourself with the schema structure to identify where the relevant information resides for more accurate queries.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 348 ORDER BY T1.time ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "hint": "Paul di Resta refers to the full name of the driver; Full name of the driver refers to drivers.forename ='Paul' and drivers.surname = 'di Resta'; race number refers to raceId; percentage = DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)) * 100 , (fastestLapSpeed(raceId = 853))",
        "error_sql": "SELECT (CAST((r1.fastestLapSpeed - r2.fastestLapSpeed) AS REAL) / r2.fastestLapSpeed * 100) AS percent_faster\nFROM results AS r1\nINNER JOIN results AS r2 ON r1.driverId = r2.driverId\nWHERE r1.raceId = 853 AND r2.raceId = 854 AND r1.fastestLapSpeed IS NOT NULL AND r2.fastestLapSpeed IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're correctly joining tables based on the specific criteria relevant to your query, and double-check that you're applying aggregate functions properly if needed. In this case, using `SUM` or `IIF` for filtered conditions helps isolate values specific to the driver and races in question. Familiarize yourself with the logic of conditional aggregation to handle complex queries involving multiple conditions or filters.",
        "ground_truth_sql": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "difficulty": "challenging"
    },
    {
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "hint": "",
        "error_sql": "SELECT COUNT(*) AS total_races, r.name \nFROM races AS r \nWHERE r.year = 2005 \nGROUP BY r.name \nORDER BY r.name DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen you want to retrieve a list of specific items (like race names), avoid using aggregate functions like `COUNT()` in the same query. Instead, focus on selecting the desired columns directly, and only apply `COUNT()` when you need to summarize data. Always ensure your `GROUP BY` clause matches the selected columns if you're using aggregate functions, which is not needed here since you're listing items rather than aggregating.",
        "ground_truth_sql": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "difficulty": "simple"
    },
    {
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "hint": "not hosted means not in;",
        "error_sql": "SELECT r.name \nFROM races AS r \nWHERE r.year = 2017 AND r.raceId NOT IN (SELECT raceId FROM races WHERE year = 2000);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the filtering criteria match the correct columns and context. When identifying non-matching elements between two sets, focus on comparing the relevant attributes (like race names, identifiers, etc.) instead of unrelated column values. Use `NOT IN` or `NOT EXISTS` carefully, ensuring you're comparing the correct field types and that your subqueries return the intended results.",
        "ground_truth_sql": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "difficulty": "simple"
    },
    {
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "hint": "the first refers to min(year);",
        "error_sql": "SELECT c.name, c.location, c.country \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE r.name = 'European Grand Prix' \nAND r.year = (SELECT MIN(year) FROM races WHERE name = 'European Grand Prix');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use the correct column and table names in your SQL queries, especially when performing join operations. Additionally, when filtering for specific conditions like the minimum year, using a subquery can prevent logical errors when dealing with aggregated data. Test your queries step by step to confirm each part produces the expected results before combining them.",
        "ground_truth_sql": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "hint": "the last refers to max(year);",
        "error_sql": "SELECT MAX(r.year) \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE r.name = 'British Grand Prix' AND c.name = 'Brands Hatch';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen formulating SQL queries, ensure that the selected columns and the necessary data are properly specified, especially for aggregations such as `MAX()`. In this case, the use of `MAX(r.year)` was correct, but to retrieve the last season accurately, it was necessary to join with the proper date or year information, ensuring to sort by year and limit results appropriately. Always validate the output requirements against the intended results, and consider using `ORDER BY` with `LIMIT` for clarity when dealing with chronological queries.",
        "ground_truth_sql": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Name all drivers in the 2010 Singapore Grand Prix order by their position stands.",
        "hint": "",
        "error_sql": "SELECT d.driverRef \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE ra.year = 2010 AND ra.name = 'Singapore Grand Prix' \nORDER BY r.positionOrder;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are referencing the correct standings table that holds the information about driver positions in races, rather than using the results table directly, as the standings may not always be in the same order or provide explicit position information. Always double-check which table contains the specific data you need for your query.",
        "ground_truth_sql": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 ORDER BY T2.position ASC",
        "difficulty": "simple"
    },
    {
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "hint": "",
        "error_sql": "SELECT d.driverRef, ds.points \nFROM driverStandings AS ds \nINNER JOIN drivers AS d ON ds.driverId = d.driverId \nINNER JOIN races AS r ON ds.raceId = r.raceId \nWHERE r.name = 'Chinese Grand Prix' AND r.year = 2017 \nORDER BY ds.points DESC \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are joining tables using adequate identifiers and verify that you are selecting the right columns. In SQL joins, it's preferable to use explicit table aliases to avoid ambiguity in column names, especially when joining multiple tables. Moreover, confirm that your filtering criteria (like race name and year) are correctly applied to the appropriate table to avoid missing relevant data.",
        "ground_truth_sql": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
        "difficulty": "simple"
    },
    {
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "hint": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name",
        "error_sql": "SELECT d.forename, d.surname, r.name \nFROM lapTimes AS l \nINNER JOIN drivers AS d ON l.driverId = d.driverId \nINNER JOIN races AS r ON l.raceId = r.raceId \nWHERE l.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the output of your query aligns with the expected result format. When using subqueries to find minimum values, verify that the main query retrieves the correct fields accordingly. Using an `ORDER BY` clause followed by `LIMIT 1` can simplify the process of retrieving the top result, as it ensures you consider all relevant data while maintaining clarity on your criteria for selection.",
        "ground_truth_sql": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; the most winning refers to MAX(COUNT(wins)); average point scores refers to MAX(points);",
        "error_sql": "SELECT d.forename, d.surname, MAX(ds.wins) AS wins, d.nationality, MAX(ds.points) AS max_points\nFROM driverStandings AS ds\nINNER JOIN drivers AS d ON ds.driverId = d.driverId\nGROUP BY ds.driverId\nORDER BY wins DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating data with `GROUP BY` and using aggregate functions like `COUNT` or `MAX`, ensure that all selected columns that are not part of an aggregate function are included in the `GROUP BY` clause. Additionally, avoid using aggregate functions that mix different levels of aggregation in the query without clear logic or conditions, as this can lead to incorrect grouping results. Always double-check the logical flow of your query when dealing with multiple aggregations and conditions.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How old is the youngest Japanese driver? What is his name?",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS name, (strftime('%Y', 'now') - strftime('%Y', d.dob)) AS age\nFROM drivers AS d\nWHERE d.nationality = 'Japanese'\nORDER BY d.dob DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the ordering condition based on the requirement of the query. If you need to find the youngest individual, you should sort the dates in ascending order (earliest to latest), as the most recent date signifies the youngest. Additionally, be cautious about using the correct columns in your calculations and ensure that your query logic aligns perfectly with the specified requirements.",
        "ground_truth_sql": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "hint": "Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;track number less than 10 refers to position < 20",
        "error_sql": "SELECT r.name \nFROM results AS res \nINNER JOIN drivers AS d ON res.driverId = d.driverId \nINNER JOIN races AS r ON res.raceId = r.raceId \nWHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.position < 20;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the relationships between tables and ensure you are joining the correct tables for the context of your query. In this case, the `results` table was not suitable for identifying the driver's standings in a race. Instead, using the `driverStandings` table allowed for the correct association between the driver and their position in a specific race.",
        "ground_truth_sql": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "difficulty": "simple"
    },
    {
        "question": "How many times did Michael Schumacher won from races hosted in Sepang International Circuit?",
        "hint": "win from races refers to max(points)",
        "error_sql": "SELECT COUNT(DISTINCT cs.wins) \nFROM constructorStandings AS cs \nINNER JOIN races AS r ON cs.raceId = r.raceId \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nINNER JOIN drivers AS d ON cs.constructorId = d.driverId \nWHERE c.name = 'Sepang International Circuit' AND d.forename = 'Michael' AND d.surname = 'Schumacher' AND cs.wins > 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, it's crucial to understand the relationships between the tables and the data you're aggregating. Ensure you're correctly joining the relevant tables and accurately selecting the columns that contribute to your desired outcomes. In your case, the original query mistakenly mixed up constructors and drivers, which led to incorrect joins. Always validate the columns used for joins and aggregate calculations, and if you're summing values or counting occurrences, ensure you're using the correct table entries that meet your criteria.",
        "ground_truth_sql": "SELECT SUM(T2.wins) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE T1.forename = 'Michael' AND T1.surname = 'Schumacher' AND T4.name = 'Sepang International Circuit'",
        "difficulty": "moderate"
    },
    {
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "hint": "fastest lap refers to min(milliseconds); Alex Yoong refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT r.name, r.year \nFROM results AS res \nINNER JOIN races AS r ON res.raceId = r.raceId \nINNER JOIN drivers AS d ON res.driverId = d.driverId \nWHERE d.forename = 'Michael' AND d.surname = 'Schumacher' \nAND res.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE driverId = d.driverId);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to find the fastest lap, ensure you are referencing the appropriate table that holds lap times rather than race results, as fastest laps are typically recorded in lap times rather than finishing results. Always confirm the schema to identify where specific data is stored to avoid incorrect joins or subqueries.",
        "ground_truth_sql": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is Eddie Irvine's average points scored in year 2000?",
        "hint": "average points = AVG(points where year = 2000)",
        "error_sql": "SELECT AVG(points) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE results.driverId = (SELECT driverId FROM drivers WHERE forename = 'Eddie' AND surname = 'Irvine') AND races.year = 2000;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating averages based on multiple related tables, ensure you're joining the correct tables that contain the relevant points data for the specified conditions. Always verify that you're using the correct type of join (INNER JOIN vs. WHERE clause filtering) to access the appropriate data, ensuring all necessary foreign key relationships are accounted for. Additionally, consider checking the table definitions to understand where specific data resides.",
        "ground_truth_sql": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Eddie' AND T1.surname = 'Irvine' AND T3.year = 2000",
        "difficulty": "simple"
    },
    {
        "question": "Which was Lewis Hamilton first race? What was his points recorded for his first race event?",
        "hint": "first race refers to min(Year); Lewis Hamiltonrefers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT r.year, ds.points \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nINNER JOIN driverStandings AS ds ON r.raceId = ds.raceId AND r.driverId = ds.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nORDER BY r.raceId ASC \nLIMIT 1;",
        "compiler_hint": "no such column: r.year",
        "reflective_cot": "### Tip:\nAlways ensure you are selecting fields from the appropriate tables that have the necessary columns to represent your intended query. When dealing with multiple tables, carefully track the relationships between tables through JOINs and ensure you're querying the right keys (like raceId or year) that align with your intended filtering and ordering criteria. Use aliasing carefully to keep track of which fields belong to which tables in complex queries.",
        "ground_truth_sql": "SELECT T1.name, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the most laps f1 races had? Name the race, year and circuit location where the races with most laps was hosted.",
        "hint": "",
        "error_sql": "SELECT r.name, r.year, c.location \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nORDER BY (SELECT MAX(laps) FROM results WHERE raceId = r.raceId) DESC \nLIMIT 1;",
        "compiler_hint": "no such column: r.laps",
        "reflective_cot": "### Tip:\nAlways ensure that you are querying the correct tables for the data you need. When faced with a specific requirement (like determining the maximum laps in races), think critically about which table holds the relevant information, such as lap data or results, rather than attempting to use columns that do not exist in the primary table you are querying. Familiarize yourself with the schema in detail to avoid overlooking necessary relations and to ensure you reference the correct columns for your calculations.",
        "ground_truth_sql": "SELECT T3.lap, T2.name, T2.year, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId INNER JOIN lapTimes AS T3 ON T3.raceId = T2.raceId ORDER BY T3.lap DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
        "hint": "higher latitude refers to max(lat)",
        "error_sql": "SELECT name, lat \nFROM circuits \nWHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') \nORDER BY lat DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SELECT statement includes all necessary columns in your final output. If you're retrieving the names of circuits, but you're also ordering by latitude and limiting the results, make sure to include only the columns needed for the specific output and not any extra data like latitude unless explicitly needed in the final result. In cases where only specific fields are required for the final output, focus on selecting those fields to avoid confusion.",
        "ground_truth_sql": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "In which country can I find the circuit with the highest altitude?",
        "hint": "highest altitude refers to max(alt)",
        "error_sql": "SELECT country FROM circuits WHERE alt = (SELECT MAX(alt) FROM circuits)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider ordering your results when looking for a single maximum value; using `ORDER BY` in conjunction with `LIMIT` is a reliable way to access top records directly, which can help avoid potential issues with duplicates or missed entries.",
        "ground_truth_sql": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which country is the oldest driver from?",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT d.nationality \nFROM drivers AS d \nORDER BY d.dob ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways include necessary conditions in your SQL queries. In this case, ensure that you're excluding any NULL values by adding a WHERE clause to avoid incorrectly processing incomplete data. For example, check for `WHERE dob IS NOT NULL` when ordering by a date field to ensure accuracy.",
        "ground_truth_sql": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "hint": "more information refers to url",
        "error_sql": "SELECT r.url \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Silverstone Circuit';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to retrieve specific columns from multiple tables, always ensure that the query adheres to the goal of obtaining distinct values explicitly if duplicates are possible. Use `SELECT DISTINCT` appropriately to avoid returning redundant data, and verify that you're selecting the correct columns based on the information needed. Additionally, carefully check if the join conditions and filtering conditions correctly represent the relationships and criteria for what you're trying to extract.",
        "ground_truth_sql": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "difficulty": "simple"
    },
    {
        "question": "What time did the the 2010's Formula_1 race took place on the Abu Dhabi Circuit?",
        "hint": "",
        "error_sql": "SELECT r.time \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Abu Dhabi Circuit' AND r.year BETWEEN 2010 AND 2019;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check the specific name of the event or circuit you are querying, including exact event titles (e.g., \"Abu Dhabi Grand Prix\" instead of just \"Abu Dhabi Circuit\"). Make sure to cross-reference with expected names in the database to avoid mismatches, especially for events that might have different titles or identifiers.",
        "ground_truth_sql": "SELECT T2.date, T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2010 AND T2.name = 'Abu Dhabi Grand Prix'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
        "hint": "",
        "error_sql": "SELECT r.date \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Barcelona-Catalunya';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the exact and full name of the circuit is used in your queries. For example, in this case, the correct name is \"Circuit de Barcelona-Catalunya\" instead of simply \"Barcelona-Catalunya.\" It's crucial to check that the string matches the data in the database to avoid issues with case sensitivity or missing words.",
        "ground_truth_sql": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "difficulty": "simple"
    },
    {
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "hint": "reference name refers to driverRef; Canadian Grand Prix refers to races.name = 'Canadian Grand Prix';",
        "error_sql": "SELECT d.driverRef \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE ra.year = 2007 AND ra.name = 'Canadian Grand Prix' AND r.position = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you correctly reference the proper columns and conditions based on the requirements. In this case, the correct ranking column was `rank` instead of `position`, and always clarify the joining and filtering criteria in your SQL queries. Also, consider cross-referencing with sample datasets or documentation to confirm your logic before finalizing the query.",
        "ground_truth_sql": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "hint": "",
        "error_sql": "SELECT r.raceId, r.year, r.name \nFROM results AS res \nINNER JOIN races AS r ON res.raceId = r.raceId \nINNER JOIN drivers AS d ON res.driverId = d.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the table aliases used in your SQL statements and ensure they are consistently applied throughout the query. Double-check that all joins between tables are correctly constructed, particularly focusing on the correct linking of primary and foreign keys.",
        "ground_truth_sql": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "difficulty": "simple"
    },
    {
        "question": "In which Formula_1 race did Lewis Hamilton rank the highest?",
        "hint": "rank the highest refers to min(rank); Lewis Hamilton refers to the full name of the driver; Full name of the driver refers to drivers.forename and drivers.surname;",
        "error_sql": "SELECT r.name, MIN(res.rank) \nFROM results AS res \nINNER JOIN drivers AS d ON res.driverId = d.driverId \nINNER JOIN races AS r ON res.raceId = r.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nGROUP BY r.name \nORDER BY MIN(res.rank) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are directly querying for the specific conditions required by the problem statement and use subqueries judiciously to achieve accurate results. Instead of aggregating results first and then filtering, consider reaching the final result through properly nested subqueries or joins that specifically check for the exact ranks or conditions needed. This helps in avoiding grouping or aggregation errors that might misinterpret the data.",
        "ground_truth_sql": "SELECT name FROM races WHERE raceId IN ( SELECT raceId FROM results WHERE rank = 1 AND driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) )",
        "difficulty": "simple"
    },
    {
        "question": "Which was the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix?",
        "hint": "",
        "error_sql": "SELECT MIN(r.fastestLapTime) \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND ra.name = 'Australian Grand Prix' AND ra.year = 2008;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you select the correct column for the desired output; in this case, the `fastestLap` column was intended for retrieval instead of `fastestLapTime`. Additionally, double-check your SQL structure to confirm you are accessing all required columns in your `SELECT` statement, especially when dealing with aggregate functions or ordering.",
        "ground_truth_sql": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "difficulty": "simple"
    },
    {
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "hint": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
        "error_sql": "SELECT r.time \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Chinese Grand Prix' AND ra.year = 2008 AND r.positionOrder = 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're referencing the correct race name and the appropriate field for the position when searching for specific results. Double-check if the column used for ranking (like `rank` or `positionOrder`) matches the required criteria in your SQL query, and confirm that your conditions correctly reflect the intended race and year.",
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "difficulty": "simple"
    },
    {
        "question": "How many points did Lewis Hamilton get in total in all the Formula_1 races he participated?",
        "hint": "",
        "error_sql": "SELECT SUM(ds.points) \nFROM driverStandings AS ds \nINNER JOIN drivers AS d ON ds.driverId = d.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for aggregated data (like total points), ensure you're referencing the correct table directly related to the metric you're calculating. In this case, `driverStandings` was used initially, but since total points are stored in the `results` table, the correct join is necessary. Always verify your data model to understand where specific information resides before constructing your SQL queries.",
        "ground_truth_sql": "SELECT SUM(T2.points) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
        "difficulty": "simple"
    },
    {
        "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
        "hint": "average fastest lap time = avg(fastestLapTime); The time is recorded on 'MM:SS.mmm'",
        "error_sql": "SELECT AVG(r.fastestLapTime) \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to account for the complete format of the time string you are working with. Use functions like `INSTR` to dynamically locate characters for extraction rather than relying on fixed positions, as this can lead to errors when the time format varies. Always test your SQL logic with smaller datasets to confirm accuracy before applying to larger sets.",
        "ground_truth_sql": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
        "difficulty": "moderate"
    },
    {
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "hint": "how much faster in percentage = divide(subtract(incremental time, champion time), last_driver time) * 100; last driver finished time = incremental time + champion time; only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null",
        "error_sql": "SELECT \n    ((CAST((SELECT r.time FROM results AS r \n             INNER JOIN races AS ra ON r.raceId = ra.raceId \n             INNER JOIN drivers AS d ON r.driverId = d.driverId \n             WHERE ra.year = 2008 AND ra.name = 'Australian Grand Prix' \n             AND r.time IS NOT NULL \n             ORDER BY r.positionOrder \n             LIMIT 1) AS INTEGER) - \n      CAST((SELECT r.time FROM results AS r \n             INNER JOIN races AS ra ON r.raceId = ra.raceId \n             WHERE ra.year = 2008 AND ra.name = 'Australian Grand Prix' \n             AND r.time IS NOT NULL \n             ORDER BY r.positionOrder DESC \n             LIMIT 1) AS INTEGER)) * 100.0 / \n     CAST((SELECT r.time FROM results AS r \n             INNER JOIN races AS ra ON r.raceId = ra.raceId \n             WHERE ra.year = 2008 AND ra.name = 'Australian Grand Prix' \n             AND r.time IS NOT NULL \n             ORDER BY r.positionOrder DESC \n             LIMIT 1) AS INTEGER)) AS speed_difference_percentage;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that time values are correctly converted and handled, taking into account the format (e.g., HH:MM:SS.mmm) and arithmetic operations. Use designated time manipulation functions or convert times to a uniform unit like seconds before performing calculations. Consider creating Common Table Expressions (CTEs) to structure your queries more clearly, which helps in validating intermediate results.",
        "ground_truth_sql": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "difficulty": "challenging"
    },
    {
        "question": "How many British drivers were born after 1980?",
        "hint": "born after 1980 refers to year (dob) >1980;",
        "error_sql": "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND dob > '1980-01-01';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that date comparisons are handled properly in SQL. Instead of comparing dates as strings, consider using date functions like `STRFTIME()` or ensure that the date format aligns with the database's expectations. This helps avoid issues with incorrect comparisons due to format mismatches.",
        "ground_truth_sql": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) > '1980'",
        "difficulty": "simple"
    },
    {
        "question": "What are the maximum points of British constructors?",
        "hint": "maximum points = MAX(points); British is a nationality",
        "error_sql": "SELECT MAX(cr.points) \nFROM constructorResults AS cr \nINNER JOIN constructors AS c ON cr.constructorId = c.constructorId \nWHERE c.nationality = 'British';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the context of your data when writing SQL queries. In this case, the initial query mistakenly used the `constructorResults` table, which tracks individual race results, instead of the `constructorStandings` table that aggregates points across races. Understand the role of each table and which one holds the relevant aggregated data for your query.",
        "ground_truth_sql": "SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'",
        "difficulty": "simple"
    },
    {
        "question": "Which constructor has the highest point?",
        "hint": "",
        "error_sql": "SELECT c.name \nFROM constructorResults AS cr \nINNER JOIN constructors AS c ON cr.constructorId = c.constructorId \nORDER BY cr.points DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the context of the data you are querying. In this case, the constructor's points are stored in the `constructorStandings` table rather than `constructorResults`. Make sure to understand the relationships and data storage within the schema before forming your query. Additionally, reviewing the schema thoroughly can help identify where specific data is kept, reducing the risk of referencing the wrong table in future queries.",
        "ground_truth_sql": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Please list the constructor names with 0 points at race 291.",
        "hint": "race at 291 refers to raceID = 291;",
        "error_sql": "SELECT c.name \nFROM constructorResults AS cr \nINNER JOIN constructors AS c ON cr.constructorId = c.constructorId \nWHERE cr.raceId = 291 AND cr.points = 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are referencing the correct tables when looking for specific data points. In this case, points earned in a race are recorded in the `constructorStandings` table for the race standings, not in the `constructorResults` table which tracks results for each constructor per race. Always check the schema and understand the relationships between tables to avoid this kind of error.",
        "ground_truth_sql": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "difficulty": "simple"
    },
    {
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "hint": "2 races refers to COUNT(raceID) = 2; Japanese refers to constructors.nationality = 'Japanese';",
        "error_sql": "SELECT COUNT(DISTINCT cr.constructorId) \nFROM constructorResults AS cr \nINNER JOIN constructors AS c ON cr.constructorId = c.constructorId \nWHERE c.nationality = 'Japanese' AND cr.points = 0 \nGROUP BY cr.constructorId \nHAVING COUNT(cr.raceId) = 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating data with `GROUP BY`, ensure that you're using unique identifiers correctly. Always verify that the conditions in the `HAVING` clause correspond accurately to the grouped results. In your original query, you mistakenly counted all races but didn't correctly filter by the total number of distinct race IDs captured within the same group. Use distinct counts appropriately to ensure you\u2019re aggregating the right set of data.",
        "ground_truth_sql": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "difficulty": "simple"
    },
    {
        "question": "Which constructors have been ranked 1?",
        "hint": "",
        "error_sql": "SELECT DISTINCT c.name \nFROM constructorStandings AS cs \nINNER JOIN constructors AS c ON cs.constructorId = c.constructorId \nWHERE cs.position = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to identify distinct records based on rankings or specific performance metrics, ensure that you are referencing the correct table that directly holds the ranking information. In this case, the mistake was using `constructorStandings` instead of `results`, which does not contain the precise ranking context for constructors. Always verify the schema to confirm that the attributes relevant to your query are available in the selected tables.",
        "ground_truth_sql": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "difficulty": "simple"
    },
    {
        "question": "How many French constructors have a lap number of over 50?",
        "hint": "lap numbers of over 50 refers to laps > 50;",
        "error_sql": "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors AS c \nINNER JOIN qualifying AS q ON c.constructorId = q.constructorId \nINNER JOIN lapTimes AS lt ON q.raceId = lt.raceId AND q.driverId = lt.driverId \nWHERE c.nationality = 'French' AND lt.lap > 50;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are filtering on the correct data sources relevant to the query context. In this case, lap counts should be taken from the `results` table rather than `lapTimes` since the requirement was to check the total laps completed by constructors, not individual lap records. Focus on understanding the schema and identifying where to pull specific attributes related to your query goal.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "difficulty": "simple"
    },
    {
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "hint": "only champion's finished time is represented by 'HH:MM:SS.mmm'; finished the game refers to time is not null; before year 1975 refers to year < 1975;",
        "error_sql": "SELECT r.year, AVG(r.milliseconds / 1000.0) AS average_time_seconds \nFROM results AS r \nINNER JOIN driverStandings AS ds ON r.raceId = ds.raceId AND r.driverId = ds.driverId \nWHERE ds.position = 1 AND r.time IS NOT NULL AND r.year < 1975 \nGROUP BY r.year;",
        "compiler_hint": "no such column: year",
        "reflective_cot": "### Tip:\nAlways ensure that you fully understand the relationships between tables and the specific columns you are referencing in your query. When joining tables, explicitly specify the necessary columns and avoid assumptions about column availability based on joins. Use common aliases or clear naming to prevent confusion, especially when working with similar column names across different tables.",
        "ground_truth_sql": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "difficulty": "challenging"
    },
    {
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "hint": "born after 1975 refers to year(dob) >1975;",
        "error_sql": "SELECT d.forename, d.surname \nFROM drivers AS d \nINNER JOIN driverStandings AS ds ON d.driverId = ds.driverId \nWHERE d.dob > '1975-01-01' AND ds.position = 2;",
        "compiler_hint": "no such function: year",
        "reflective_cot": "### Tip:\nWhen working with date fields in SQL, be sure to use the appropriate functions for your database system. In SQLite, you can use `STRFTIME()` to extract parts of a date (like the year) instead of trying to use `year()` which may not be supported. Always consult the documentation for the specific functions available in your SQL dialect to avoid errors.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "difficulty": "simple"
    },
    {
        "question": "How many Italian drivers haven't finished the race?",
        "hint": "haven't finished the race refers to time is null;",
        "error_sql": "SELECT COUNT(DISTINCT r.driverId) \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE r.time IS NULL AND d.nationality = 'Italian';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that all necessary joins include the relevant tables to avoid missing context for your queries. In the first query, an extra join with the `races` table was unnecessary since you only need driver and result data for this specific condition. Focus on the minimal data required for your query to improve efficiency and avoid potential errors.",
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Italian' AND T1.time IS NULL",
        "difficulty": "simple"
    },
    {
        "question": "Which driver has the fastest lap time? Please give their forenames and surnames.",
        "hint": "",
        "error_sql": "SELECT d.forename, d.surname \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE r.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating minimum or maximum values, ensure you account for potential `NULL` values in your dataset. Use `WHERE column_name IS NOT NULL` to filter out those entries before performing aggregation functions like `MIN()` or `MAX()`. Additionally, when seeking the fastest lap time, it's wise to retrieve the associated details (like driver information) in the same query instead of a subquery for better performance and clarity.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname, T1.fastestLapTime FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.fastestLapTime IS NOT NULL ORDER BY T1.fastestLapTime ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the fastest lap number of the champion in 2009?",
        "hint": "in 2009 refers to year = 2009; Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\"",
        "error_sql": "SELECT r.fastestLap \nFROM results AS r \nINNER JOIN driverStandings AS ds ON r.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.raceId IN (SELECT raceId FROM races WHERE year = 2009);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to check specific conditions or formats required in your query, especially when filtering results. In this case, the condition for the fastest lap time needed to match a specific time format (e.g., \"hour: minutes: seconds.millionseconds\"). Utilize the `LIKE` operator effectively to enforce format filtering in your queries, ensuring that you capture the intended results accurately.",
        "ground_truth_sql": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "simple"
    },
    {
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "hint": "lap time less than 02:00.00 refers to seconds < 120;",
        "error_sql": "SELECT COUNT(DISTINCT d.driverId) \nFROM drivers AS d \nINNER JOIN lapTimes AS l ON d.driverId = l.driverId \nWHERE d.nationality = 'French' AND l.time < '02:00.00';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that time comparisons are correctly formatted and accounted for, especially when dealing with string representations of time. Convert time strings to a consistent unit (like seconds or milliseconds) before making comparisons, and consider edge cases in formatting (e.g., leading zeros). Using functions to parse and convert time can help eliminate errors in comparisons.",
        "ground_truth_sql": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "difficulty": "moderate"
    },
    {
        "question": "List out the code for drivers who have nationality in America.",
        "hint": "nationality = 'America'",
        "error_sql": "SELECT code FROM drivers WHERE nationality = 'America';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check for the correct spelling and format of column values in your SQL queries. In this case, it was important to match the exact term used in the database (\"American\" instead of \"America\"). Additionally, familiarizing yourself with the dataset and commonly used terms will help ensure accuracy in future queries.",
        "ground_truth_sql": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "difficulty": "simple"
    },
    {
        "question": "How many driver participated in race ID number 18?",
        "hint": "",
        "error_sql": "SELECT COUNT(DISTINCT driverId) \nFROM results \nWHERE raceId = 18;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting the number of participants in a race, ensure you are querying from the table that represents participation in that event. In this case, the `driverStandings` table was more appropriate than the `results` table, as it directly reflects the standings of drivers in each race. Always verify which table holds the relevant data before crafting your SQL queries to avoid counting errors.",
        "ground_truth_sql": "SELECT COUNT(driverId) FROM driverStandings WHERE raceId = 18",
        "difficulty": "simple"
    },
    {
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "hint": "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country",
        "error_sql": "SELECT driverId, code FROM drivers ORDER BY dob DESC LIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways remember to check the actual requirement for your query. In this case, the goal was to find the top three youngest drivers based on their date of birth, but the first query only fetched their IDs without considering the actual drivers' records. The subsequent query attempted to count Dutch drivers but utilized IN with a subquery that returned dates, not driver records. To avoid such mistakes, ensure you clearly understand the data you need to extract and how to appropriately reference it in subsequent queries.",
        "ground_truth_sql": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "difficulty": "simple"
    },
    {
        "question": "How many British drivers who were born in 1980?",
        "hint": "born in 1980 refers to year(dob) = 1980;",
        "error_sql": "SELECT COUNT(*) \nFROM drivers \nWHERE nationality = 'British' AND dob = '1980-01-01';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that date comparisons account for the full date range relevant to the specific query. Instead of relying on a specific date or a range based on just the year, use functions like `STRFTIME` to extract and compare the year from a date column directly. This ensures you're accurately identifying all relevant records.",
        "ground_truth_sql": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "difficulty": "simple"
    },
    {
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "hint": "born from 1980-1990 refers to year(dob) between 1980 and 1990; earliest lap time refers to Min(time);",
        "error_sql": "SELECT d.forename, d.surname \nFROM drivers AS d \nINNER JOIN lapTimes AS l ON d.driverId = l.driverId \nWHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1990-12-31' \nORDER BY l.time ASC \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're using the correct data type for comparisons and ordering in your SQL queries. For time-related fields, use numeric or integer formats (like milliseconds) for accurate comparison. Additionally, double-check the context of the query and the aggregation needed (e.g., using `ORDER BY` appropriately on relevant columns).",
        "ground_truth_sql": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "difficulty": "moderate"
    },
    {
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "hint": "born before 1982 refers to year(dob) < 1982; latest lap time refers to Max(time);",
        "error_sql": "SELECT d.driverId, d.code, MAX(l.time) AS latest_lap_time \nFROM drivers AS d \nINNER JOIN lapTimes AS l ON d.driverId = l.driverId \nWHERE d.nationality = 'Spanish' AND d.dob < '1982-01-01' \nGROUP BY d.driverId, d.code \nORDER BY latest_lap_time DESC \nLIMIT 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are aggregating the correct values based on your query requirements. When looking for maximum values, use appropriate aggregates in your SELECT clause while also maintaining a relationship with those aggregates in your JOIN and WHERE clauses. Additionally, consider the entire context of the query, including how filters and sorting will impact your results, to ensure you are not accidentally omitting key records.",
        "ground_truth_sql": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "difficulty": "moderate"
    },
    {
        "question": "State the racing year which has the fastest lap time?",
        "hint": "'has the fastest lap time?' refers to fastestLapTime has values",
        "error_sql": "SELECT r.year \nFROM results AS res \nINNER JOIN races AS r ON res.raceId = r.raceId \nWHERE res.fastestLapTime IS NOT NULL \nORDER BY res.fastestLapTime ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check that your query retrieves the expected results regarding the context of the question. In this case, ensure that you are not only ordering by `fastestLapTime` but also correctly identifying the minimum value that represents the fastest lap time, which likely requires using functions like `MIN()` or ensuring that you properly handle time formats. Additionally, consider testing your queries incrementally to validate each part for correctness before composing the final query.",
        "ground_truth_sql": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "Which year has the lowest speed of lap time?",
        "hint": "lowest speed of lap time refers to Max(time);",
        "error_sql": "SELECT year \nFROM races AS r \nINNER JOIN lapTimes AS l ON r.raceId = l.raceId \nWHERE l.time IS NOT NULL \nGROUP BY year \nORDER BY MAX(l.time) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating and ordering results, ensure you're using the correct data type for comparisons. In this case, when evaluating lap times, it's essential to work with milliseconds (integers) instead of time strings to avoid comparison errors and misleading results. Always convert time formats to consistent numeric types when filtering or ordering data in SQL.",
        "ground_truth_sql": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "hint": "fastest time refers to Min(time);",
        "error_sql": "SELECT lt.driverId \nFROM lapTimes AS lt \nWHERE lt.lap = 1 \nORDER BY lt.milliseconds ASC \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are using the correct data type for sorting and comparison. In the context of SQL queries, especially when dealing with time data, make sure to use the appropriate column that represents the time format you need. In this case, using `milliseconds` instead of `time` would yield the correct results when sorting lap times numerically.",
        "ground_truth_sql": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "What race number has the most finishers?",
        "hint": "finisher refers to time is not null;",
        "error_sql": "SELECT raceId \nFROM results \nWHERE time IS NOT NULL \nGROUP BY raceId \nORDER BY COUNT(driverId) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen counting finisher records based on a condition, ensure that the condition is applied during the count operation itself. Instead of filtering records before the grouping and counting, directly apply the condition inside the COUNT() function to accurately account for only the relevant records.",
        "ground_truth_sql": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "hint": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; first qualifying race refers to MIN(races.date);",
        "error_sql": "SELECT d.forename, d.surname, MIN(r.date) AS race_date, r.time, strftime('%Y', MIN(r.date)) AS race_year\nFROM drivers AS d\nINNER JOIN qualifying AS q ON d.driverId = q.driverId\nINNER JOIN races AS r ON q.raceId = r.raceId\nGROUP BY d.driverId\nORDER BY d.dob DESC\nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for the youngest driver and their first qualifying race, ensure that you're correctly identifying the driver based on their date of birth before selecting the race data. Use subqueries or CTEs (Common Table Expressions) to first isolate the youngest driver and then join to find their qualifying race. Always verify your grouping and ordering logic aligns with the criteria you're aiming to achieve.",
        "ground_truth_sql": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the website of the constructor who tallied the most total wins.",
        "hint": "introduction website refers to url;",
        "error_sql": "SELECT c.url \nFROM constructorStandings AS cs \nINNER JOIN constructors AS c ON cs.constructorId = c.constructorId \nGROUP BY cs.constructorId \nORDER BY SUM(cs.wins) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure the correct aggregation and ordering of wins occurs directly on the relevant table. When performing joins and grouping, check whether you are summarizing the correct fields and that the group by clause matches your aggregation strategy. Additionally, confirm that the table being ordered contains the summary values you're interested in.",
        "ground_truth_sql": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the drivers who participated in the French Grand Prix, who has the slowest time in the 3rd lap.",
        "hint": "slowest time refers to Max(time);",
        "error_sql": "SELECT d.forename, d.surname, lt.time \nFROM lapTimes AS lt \nINNER JOIN races AS r ON lt.raceId = r.raceId \nINNER JOIN drivers AS d ON lt.driverId = d.driverId \nWHERE lt.lap = 3 AND r.name = 'French Grand Prix' \nORDER BY lt.time DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you understand the goal of the query thoroughly. In this case, the goal was to find the driver with the slowest lap time, which requires selecting the maximum lap time rather than ordering results in ascending or descending order. When facing similar queries, consider using aggregation functions directly related to your specific requirement instead of relying solely on sorting.",
        "ground_truth_sql": "SELECT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 ORDER BY T1.time DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "In which race did the fastest 1st lap time was recorded? Please indicate the time in milliseconds.",
        "hint": "fastest refers to Min(time);",
        "error_sql": "SELECT r.name, r.year, MIN(lap.time) AS fastestLapTime \nFROM lapTimes AS lap \nINNER JOIN races AS r ON lap.raceId = r.raceId \nGROUP BY lap.raceId \nORDER BY MIN(lap.milliseconds) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are filtering your queries based on the specific requirements outlined in the question. In this case, it was essential to specify that you are looking for the fastest lap time of the first lap (lap = 1). Additionally, validate your aggregate functions and their context in the SQL statement to avoid grouping and ordering mistakes.",
        "ground_truth_sql": "SELECT T1.milliseconds FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.lap = 1 ORDER BY T1.time LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "hint": "Full name of the driver refers to drivers.forename and drivers.surname; born between 1980-1985 refers to 1980< year(dob)>1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name\nFROM drivers AS d\nINNER JOIN pitStops AS p ON d.driverId = p.driverId\nWHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN '1980' AND '1985'\nGROUP BY d.driverId\nORDER BY AVG(p.milliseconds) ASC\nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the aggregation functions such as `AVG()` are applied after grouping the results, and double-check the GROUP BY clause to ensure it includes all necessary columns that are not aggregated. In the first attempt, you used `GROUP BY d.driverId` which is fine, but the ordering and average calculation on the wrong column and potentially missed the need for precise duration handling can lead to incorrect results. Additionally, verify that you have the right column data types and fields for your calculations before executing the query.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "difficulty": "challenging"
    },
    {
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "hint": "Only the time of the champion shows in the format of \"hour: minutes: seconds.millionsecond\";",
        "error_sql": "SELECT d.forename, d.surname, r.time \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE ra.year = 2008 AND ra.name = 'Canadian Grand Prix' AND r.positionOrder = 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check if the data types and formats in your queries match the expected output, especially for specific formats like time. Additionally, ensure that you accurately incorporate all necessary conditions for filtering results to avoid retrieving unintended records.",
        "ground_truth_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "hint": "Full name refers to forname, surname; Date of birth refers to dob; year(dob) BETWEEN '1981' AND '1991'; Austrian is a nationality",
        "error_sql": "SELECT CONCAT(forename, ' ', surname) AS fullName, dob \nFROM drivers \nWHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you understand the SQL functions you use, such as `CONCAT` and `STRFTIME`, and know their availability and syntax in the SQL dialect you're working with. In many SQL databases, `CONCAT` may not be available or could require a different syntax; also, be cautious with date functions and formatting to correctly compare dates or extract parts of them. Always refer to the specific documentation for the SQL dialect in use to avoid errors.",
        "ground_truth_sql": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "difficulty": "simple"
    },
    {
        "question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "hint": "FFull name refers to forname+surname; Nationality refers to German; Date of birth refers to dob; year(dob) BETWEEN '1971' AND '1985'",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name, d.url, d.dob \nFROM drivers AS d \nWHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN '1971' AND '1985' \nORDER BY d.dob DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that date comparisons are performed correctly by using the appropriate functions or formats. In SQLite, use the `strftime()` function to extract the year directly from the date string for reliable comparisons, or cast the date to an appropriate format for comparisons. Remember to validate against the actual data types and formats used in your database schema to avoid syntax errors.",
        "ground_truth_sql": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "difficulty": "moderate"
    },
    {
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "hint": "coordinates expressed in latitude and longitude refers to (lat, lng)",
        "error_sql": "SELECT location, country, lat, lng \nFROM circuits \nWHERE name = 'Hungaroring';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you fully understand the schema and the names used in the database, particularly the distinction between `name` and identifiers like `circuitRef`. It's crucial to verify which column contains the specific value you're searching for to avoid incorrect queries. When in doubt, review the structure of the table or consider using `LIKE` for partial matches.",
        "ground_truth_sql": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "difficulty": "simple"
    },
    {
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "hint": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
        "error_sql": "SELECT cr.points, c.name, c.nationality \nFROM constructorResults AS cr \nINNER JOIN races AS ra ON cr.raceId = ra.raceId \nINNER JOIN constructors AS c ON cr.constructorId = c.constructorId \nWHERE ra.name = 'Monaco Grand Prix' AND ra.year BETWEEN 1980 AND 2010 \nORDER BY cr.points DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you include the correct grouping and aggregation functions when querying for summarized data. Specifically, when you need to aggregate points from multiple rows, remember to group by the appropriate unique identifier (like the constructor's `constructorId` or `name`) and apply aggregate functions correctly (e.g., `SUM()`) to achieve the desired results. Additionally, ensure that you're consistently referencing the correct table aliases when writing complex SQL queries.",
        "ground_truth_sql": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What is the annual average number of races held during the first 10 years of the 21st century?",
        "hint": "races in date between '2000-01-01' and '2010-12-31'",
        "error_sql": "SELECT AVG(race_count) AS annual_average_races\nFROM (\n    SELECT year, COUNT(raceId) AS race_count\n    FROM races\n    WHERE date BETWEEN '2000-01-01' AND '2010-12-31'\n    GROUP BY year\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the logic of your grouping and counting aligns with the requirements of the query. In this case, you need to account for the number of unique races per year and then average them over the specific range of years explicitly. Double-checking the filtering conditions and how the aggregation functions are applied can help avoid similar mistakes.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'",
        "difficulty": "simple"
    },
    {
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "hint": "victories refer to wins; 91st refers to points\n\n",
        "error_sql": "SELECT wins \nFROM driverStandings \nWHERE position = 91;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are correctly interpreting ranking and point criteria specified in the query. Instead of directly filtering by position, make sure to understand the contextual relationship between points and wins, especially when using aggregate functions or conditions that may filter out the relevant data. Always clarify whether you're looking for an absolute value or a specific ranking context before constructing your SQL statements.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "difficulty": "simple"
    },
    {
        "question": "In terms of the fastest lap time, what is the name of the race which recorded the fastest lap speed by a racer?",
        "hint": "Fastest lap speed refers to MIN(fastestLapTime)\n\n",
        "error_sql": "SELECT ra.name \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE r.fastestLapSpeed = (SELECT MIN(fastestLapSpeed) FROM results);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're considering the appropriate columns when referencing conditions, particularly when dealing with aggregate values like MIN(). Additionally, validate that the condition reflects the actual metric you want to analyze; in this case, `fastestLapTime` should be the focus rather than `fastestLapSpeed`. Implement safeguards to ensure you're not comparing them incorrectly by structuring queries that precisely target the required outcomes.",
        "ground_truth_sql": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "hint": "full location refers to location+country; most recent race = MAX(date)\n\n",
        "error_sql": "SELECT c.name, c.location || ', ' || c.country AS full_location \nFROM races AS r \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE r.date = (SELECT MAX(date) FROM races);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you include all required columns in your SELECT statement for the final output. If you need specific data (like the full location in this case), make sure to construct the query accordingly from the start instead of relying on ordering and limiting, which can lead to incomplete results.",
        "ground_truth_sql": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "hint": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
        "error_sql": "SELECT d.forename, d.surname \nFROM qualifying AS q \nINNER JOIN races AS r ON q.raceId = r.raceId \nINNER JOIN drivers AS d ON q.driverId = d.driverId \nWHERE r.year = 2008 AND r.name = 'Marina Bay Street Circuit' AND q.q3 IS NOT NULL \nORDER BY q.q3 ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you reference all necessary tables and include the correct identifiers for filtering. Additionally, when dealing with time values stored as text, convert them into seconds or milliseconds for accurate comparisons. Use subqueries to properly identify related records, especially for cases where names or values may not match exactly.",
        "ground_truth_sql": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "hint": "full name refers to forename+surname; Youngest racer = MAX(dob)",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name, d.nationality, r.name AS race_name \nFROM drivers AS d \nINNER JOIN results AS res ON d.driverId = res.driverId \nINNER JOIN races AS r ON res.raceId = r.raceId \nWHERE d.dob = (SELECT MIN(dob) FROM drivers) \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are using the correct aggregate function to identify the desired record. In this case, you needed the maximum (youngest) date of birth (`MAX(dob)`) rather than the minimum (`MIN(dob)`). Additionally, when determining the first race a driver participated in, consider the race date order instead of just one relationship in the join. This helps to ensure that your conditions and logic accurately reflect the requirements of the query.",
        "ground_truth_sql": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many wins was achieved by the oldest racer? Indicate his/her full name.",
        "hint": "oldest racer refers to MIN(dob); full name refers to forename, surname.",
        "error_sql": "SELECT d.forename || ' ' || d.surname AS full_name, ds.wins \nFROM drivers AS d \nINNER JOIN driverStandings AS ds ON d.driverId = ds.driverId \nWHERE d.dob = (SELECT MIN(dob) FROM drivers);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to aggregate data correctly when required. In scenarios where you're looking for a sum or a count, make sure to use the appropriate aggregate function (like SUM or COUNT) in your SQL query. Additionally, it\u2019s important to clearly verify which columns are needed for display versus which ones pertain to conditional logic or aggregations, ensuring alignment with your query objectives.",
        "ground_truth_sql": "SELECT SUM(T1.wins),T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId ORDER BY T2.dob ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "hint": "",
        "error_sql": "SELECT MIN(milliseconds) \nFROM lapTimes;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're considering the data type and format of the fields in your database, especially when working with time values. In this case, the lap time was stored as a string rather than a straightforward numerical value, so simple functions like `MIN()` won\u2019t yield correct results without proper conversion. Familiarize yourself with functions like `CAST()` to convert string representations of time into numerical formats that can be accurately compared. Additionally, when performing operations on strings, use string manipulation functions carefully to ensure proper parsing of time formats.",
        "ground_truth_sql": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "hint": "time spent at pit stop refers to duration",
        "error_sql": "SELECT d.forename, d.surname, p.duration \nFROM pitStops AS p \nINNER JOIN races AS r ON p.raceId = r.raceId \nINNER JOIN drivers AS d ON p.driverId = d.driverId \nWHERE r.name = 'Australian Grand Prix' AND r.year = 2011;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that you're using the correct table and field names, and be mindful of any additional filtering conditions that may be necessary. In this case, ensure the race's name matches exactly as it appears in the database, and double-check that joins are made correctly to gather all required columns. Use SQL tools to test queries incrementally to isolate issues effectively.",
        "ground_truth_sql": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "difficulty": "simple"
    },
    {
        "question": "What is the lap record set by Lewis Hamilton in a Formula_1 race?",
        "hint": "lap recod means the fastest time recorded which refers to time",
        "error_sql": "SELECT MIN(lt.time) \nFROM lapTimes AS lt \nINNER JOIN races AS r ON lt.raceId = r.raceId \nINNER JOIN drivers AS d ON lt.driverId = d.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are selecting the appropriate data types and fields when querying the database. In the first query, the use of `MIN(lt.time)` directly may not return the fastest lap time accurately if the time format is not properly defined or converted to a comparable format. Instead, query the relevant fields directly and filter based on conditions, such as those provided in the Ground Truth SQL. Always verify how time values are stored and consider their data types when performing calculations or comparisons.",
        "ground_truth_sql": "SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "difficulty": "simple"
    },
    {
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "hint": "shortest lap time refers to MIN(time); the time format for the shortest lap time is 'MM:SS.mmm' or 'M:SS.mmm'; full name of the driver refers to forename, surname",
        "error_sql": "SELECT d.forename, d.surname \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE r.time = (SELECT MIN(time) FROM results) \nORDER BY r.milliseconds ASC \nLIMIT 20;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that time values are converted into a consistent unit for comparison, such as seconds, before using aggregate functions like MIN(). This helps avoid issues with formatting and enables accurate comparisons across different rows.",
        "ground_truth_sql": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "difficulty": "challenging"
    },
    {
        "question": "What was the position of the circuits during Lewis Hamilton's fastest lap in a Formula_1 race?",
        "hint": "fastest lap refers to MIN(time)",
        "error_sql": "SELECT r.position \nFROM results AS r \nINNER JOIN drivers AS d ON r.driverId = d.driverId \nWHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' \nAND r.fastestLapTime = (SELECT MIN(fastestLapTime) \n                        FROM results \n                        WHERE driverId = d.driverId);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nTo avoid mistakes when constructing SQL queries, ensure that you are querying the correct tables for the data you need. In this case, the fastest lap time was recorded in the `lapTimes` table, not in the `results` table. Always verify where the relevant information is stored and review the relationships between tables to select the right join paths.",
        "ground_truth_sql": "SELECT T1.position FROM lapTimes AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' ORDER BY T1.time ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the lap record for the Austrian Grand Prix Circuit?",
        "hint": "lap record means the fastest time recorded which refers to time",
        "error_sql": "SELECT MIN(r.time) \nFROM results AS r \nINNER JOIN races AS ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Austrian Grand Prix';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the columns you are referencing exist and are accurately used in your SQL queries. Check for NULL values and make sure to include necessary joins that relate the data across tables, especially when dealing with aggregated or filtered results. Using subqueries or common table expressions (CTEs) can help simplify complex queries and improve clarity.",
        "ground_truth_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the lap records for the circuits in Italy.",
        "hint": "lap record means the fastest time recorded which refers to time",
        "error_sql": "SELECT r.raceId, l.driverId, l.lap, l.time \nFROM lapTimes AS l \nINNER JOIN races AS r ON l.raceId = r.raceId \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.country = 'Italy' \nORDER BY l.time ASC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nTo avoid making mistakes in SQL queries that involve calculating minimum values or aggregating results, always ensure to convert the time format into a consistent numerical representation (like seconds) before performing any aggregations. This ensures accurate comparisons and calculations. Additionally, be cautious with the use of `GROUP BY` and the functions you apply in the `SELECT` clause to ensure you're grouping correctly without losing important data.",
        "ground_truth_sql": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
        "hint": "lap record means the fastest time recorded which refers to time",
        "error_sql": "SELECT r.name, r.year \nFROM races AS r \nINNER JOIN lapTimes AS lt ON r.raceId = lt.raceId \nINNER JOIN circuits AS c ON r.circuitId = c.circuitId \nWHERE c.name = 'Austrian Grand Prix Circuit' \nORDER BY lt.milliseconds ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to accurately identify and extract the fastest lap time using the correct attributes and calculations. Utilize subqueries or common table expressions to preprocess data, such as converting lap time formats to a standard unit (like seconds) before performing computations or comparisons.",
        "ground_truth_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
        "difficulty": "moderate"
    },
    {
        "question": "In the race a driver set the lap record for the Austrian Grand Prix Circuit, how long did he spent at the pit stop at that same race?",
        "hint": "lap record means the fastest time recorded which refers to time, how long spent at pitstop refers to duration",
        "error_sql": "SELECT p.duration \nFROM lapTimes AS l \nINNER JOIN races AS r ON l.raceId = r.raceId \nINNER JOIN pitStops AS p ON p.raceId = r.raceId AND p.driverId = l.driverId \nWHERE r.name = 'Austrian Grand Prix' \nAND l.time = (SELECT MIN(time) FROM lapTimes WHERE raceId = r.raceId);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the subqueries or conditions in your SQL statements are appropriately scoped and related to the main query context. Specifically, when filtering the fastest lap time, explicitly specify which driver\u2019s lap times are being referred to in the subquery. Additionally, consider using table aliases judiciously to avoid ambiguity, and verify that the join conditions correctly correspond to the correct relationships between the tables involved.",
        "ground_truth_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT T4.duration FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "difficulty": "challenging"
    },
    {
        "question": "Please list the location coordinates of the circuits whose lap record is 1:29.488.",
        "hint": "lap records means the fastest time recorded which refers to time; coordinates are expressed as latitude and longitude which refers to (lat, lng)",
        "error_sql": "SELECT c.lat, c.lng \nFROM results AS r \nINNER JOIN circuits AS c ON r.raceId = (SELECT raceId FROM lapTimes WHERE time = '1:29.488' LIMIT 1) \nWHERE r.raceId = (SELECT raceId FROM lapTimes WHERE time = '1:29.488' LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are using the correct relationships between tables. In the first SQL query, the connection between lap times and races was not properly established. In the second query, using `IN` instead of `JOIN` led to misalignment. Utilize `JOIN` to establish direct relationships, ensuring values from different tables accurately correlate with each other based on their foreign keys.",
        "ground_truth_sql": "SELECT T3.lat, T3.lng FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T1.time = '1:29.488'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the height of the tallest player? Indicate his name.",
        "hint": "tallest player refers to MAX(height);",
        "error_sql": "SELECT T1.player_name, MAX(T1.height) \nFROM Player AS T1 \nGROUP BY T1.player_name \nORDER BY T1.height DESC \nLIMIT 1",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when using aggregate functions like MAX(), you avoid grouping by non-aggregated columns unless you want distinct groupings. Instead, use a subquery or directly order by the desired column to retrieve the single row with the maximum value.",
        "ground_truth_sql": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "hint": "overall_rating > = 60 AND overall_rating < 65; players whose going to be in all of your attack moves instead of defensing refers to defensive_work_rate = 'low';",
        "error_sql": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE overall_rating >= 60 AND overall_rating < 65 AND defensive_work_rate = 'low';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that string comparisons in SQL are case-sensitive based on your database\u2019s configuration. Use consistent casing for string values, such as 'low' instead of 'Low', to avoid mismatches and ensure accurate results. When uncertain, refer to the database documentation or execute a query to check the exact case used in the data.",
        "ground_truth_sql": "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "hint": "perform better in crossing actions refers to MAX(crossing)",
        "error_sql": "SELECT player_api_id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to select the correct columns that match the database schema when writing your SQL queries. Double-check the table definitions to confirm which fields are uniquely identifying the records you need, especially if you are using fields like `id` versus `player_api_id`. This helps avoid confusion about which identifier to retrieve for your results.",
        "ground_truth_sql": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "hint": "home team lost the matches refers to SUBTRACT(home_team_goal, away_team_goal) < 0; 2016 season refers to season = '2015/2016';",
        "error_sql": "SELECT home_team_api_id \nFROM Match \nWHERE season = '2015/2016' AND (home_team_goal - away_team_goal) < 0 \nGROUP BY home_team_api_id \nORDER BY COUNT(*) ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you have a clear understanding of the conditions you are trying to implement in your SQL queries. For example, when counting losses, remember to check your logic (e.g., `< 0` for losses versus `> 0` for wins). It's beneficial to break down the query into smaller parts and verify each condition before combining them. Implementing test counts or checks in a separate run can also help clarify the expected outcome and reduce errors in logic.",
        "ground_truth_sql": "SELECT teamDetails.team_long_name FROM Match AS matchData INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "hint": "full name refers to player_name; players with highest number of penalties refers to MAX(penalties);",
        "error_sql": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id ORDER BY T2.penalties DESC LIMIT 10",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you join tables on the correct foreign keys. In the context of Player and Player_Attributes, joining on the player_api_id is correct, but be cautious of using other keys or values that might not establish a direct relationship. Double-check table schemas and key relationships before writing your SQL queries.",
        "ground_truth_sql": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "difficulty": "simple"
    },
    {
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "hint": "Final result should return the Team.team_long_name; Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2009/2010'; won the most refers to MAX(COUNT(*));",
        "error_sql": "SELECT T.team_long_name \nFROM Team AS T \nJOIN Match AS M ON T.team_api_id = M.away_team_api_id \nJOIN League AS L ON M.league_id = L.id \nWHERE L.name = 'Scotland Premier League' AND M.season = '2009/2010' AND M.away_team_goal > M.home_team_goal \nGROUP BY T.team_long_name \nORDER BY COUNT(*) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are grouping by the correct identifier related to the desired output. When counting occurrences (like match wins), group by the unique identifier of the teams (e.g., `matchData.away_team_api_id`) rather than the descriptive name of the team. This avoids discrepancies in the aggregation, ensuring accurate results from the `COUNT(*)` operation.",
        "ground_truth_sql": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "hint": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
        "error_sql": "SELECT ta.team_fifa_id, ta.buildUpPlaySpeed \nFROM Team_Attributes AS ta \nORDER BY ta.buildUpPlaySpeed DESC \nLIMIT 4;",
        "compiler_hint": "no such column: team_fifa_id",
        "reflective_cot": "### Tip:\nAlways double-check the column names and their corresponding tables before writing your SQL queries, particularly when using aliases. Also, ensure to properly join tables to access related data, especially when you want to retrieve specific attributes from different tables.",
        "ground_truth_sql": "SELECT t1.buildUpPlaySpeed FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.buildUpPlaySpeed ASC LIMIT 4",
        "difficulty": "moderate"
    },
    {
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "hint": "most matches end as draw refers to MAX(SUM(home_team_goal = away_team_goal)); 2016 season refers to season = '2015/2016';",
        "error_sql": "SELECT L.name \nFROM League AS L \nJOIN Match AS M ON L.id = M.league_id \nWHERE M.season = '2015/2016' \nGROUP BY L.name \nHAVING SUM(CASE WHEN M.home_team_goal = M.away_team_goal THEN 1 ELSE 0 END) = (\n    SELECT MAX(draws) \n    FROM (SELECT COUNT(*) AS draws \n          FROM Match \n          WHERE season = '2015/2016' \n          GROUP BY league_id)\n) \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you clearly understand the aggregation and filtering requirements of your SQL queries. Specifically, when using subqueries for conditions like `HAVING`, ensure you're properly structuring your aggregate functions. In this case, directly counting the draws in the main query context rather than checking against a maximum from a subquery simplified the logic. It's often helpful to break down the logic step by step to verify that each piece aligns with the intended output.",
        "ground_truth_sql": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "hint": " league with highest matches of all time refers to MAX(COUNT(league_id));",
        "error_sql": "SELECT L.name, COUNT(M.id) AS total_matches \nFROM League AS L \nJOIN Match AS M ON L.id = M.league_id \nGROUP BY L.name \nORDER BY COUNT(M.id) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen determining the maximum count of records related to a specific grouping, it's essential to use a subquery to aggregate the counts first before joining with other tables. This avoids incorrect groupings or joins that may lead to inaccurate results. Always ensure that the aggregation and filtering logic is encapsulated properly to get the correct data before applying joins.",
        "ground_truth_sql": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "difficulty": "moderate"
    },
    {
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "hint": "highest above average overall ratings refers to MAX(overall_rating); in 2010 refers to substr(date,1,4) = '2010';",
        "error_sql": "SELECT player_api_id FROM Player_Attributes WHERE overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes WHERE substr(date, 1, 4) = '2010');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you clearly understand the requirements of the query before constructing it. Specifically, distinguish between querying for the maximum value and for players above the average overall rating. Also, explicitly specify any necessary filters (like the year) up front to avoid unintended results. Always validate the logic against sample data before finalizing the query.",
        "ground_truth_sql": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "hint": "players who prefer left foot refers to preferred_foot = 'left'; percentage of players who prefer left foot = DIVIDE(MULTIPLY((SUM(preferred_foot = 'left'), 100)), COUNT(player_fifa_api_id)); born between 1987 and 1992 refers to YEAR(birthday) BETWEEN '1987' AND '1992';",
        "error_sql": "SELECT (SUM(CASE WHEN pa.preferred_foot = 'left' THEN 1 ELSE 0 END) * 100.0) / COUNT(p.player_fifa_api_id) AS percentage_left_foot \nFROM Player p \nJOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id \nWHERE p.birthday BETWEEN '1987-01-01' AND '1992-12-31';",
        "compiler_hint": "no such column: preferred_foot",
        "reflective_cot": "### Tip:\nAlways ensure to check the correct references and field names in your SQL queries, especially when joining tables. Cross-reference the schema to confirm that the columns exist in the respective tables being queried, and make sure you are using the correct aliases to avoid ambiguity. Additionally, be mindful of data types and formats when applying conditions (like dates) to ensure accurate filtering of results.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "difficulty": "challenging"
    },
    {
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "hint": "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);",
        "error_sql": "SELECT L.name \nFROM League AS L \nJOIN Match AS M ON L.id = M.league_id \nGROUP BY L.name \nORDER BY SUM(home_team_goal + away_team_goal) ASC \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating data from multiple columns, ensure you are summing them correctly in your SQL query. In the first two queries, the incorrect syntax of `SUM(home_team_goal + away_team_goal)` was used instead of separating the SUM operations: `SUM(home_team_goal) + SUM(away_team_goal)`. Always double-check the aggregation logic and structure to avoid unintended errors.",
        "ground_truth_sql": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "hint": "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;",
        "error_sql": "SELECT T.team_long_name \nFROM Team_Attributes AS TA \nJOIN Team AS T ON TA.team_fifa_api_id = T.team_fifa_api_id \nWHERE TA.buildUpPlayDribblingClass = 'Normal' \nAND TA.date >= '2014-01-01 00:00:00' \nAND TA.date <= '2014-01-31 00:00:00' \nAND TA.chanceCreationPassing < (\n    SELECT AVG(chanceCreationPassing) \n    FROM Team_Attributes \n    WHERE date >= '2014-01-01 00:00:00' \n    AND date <= '2014-01-31 00:00:00' \n) \nORDER BY TA.chanceCreationPassing DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure your date ranges are correctly specified for the entire period you intend to analyze, and be cautious about understanding the aggregation logic, such as using `SUM` and `COUNT` to calculate average values properly in subqueries. Additionally, confirm that join conditions match correctly based on the primary and foreign keys to avoid mismatches in the datasets. Consider using `CAST` for averaging to ensure correct data type handling.",
        "ground_truth_sql": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "difficulty": "challenging"
    },
    {
        "question": "List all the football player with the highest potential score.",
        "hint": "potential score refers to potential; highest potential score refers to MAX(potential);",
        "error_sql": "SELECT player_api_id FROM Player_Attributes WHERE potential = (SELECT MAX(potential) FROM Player_Attributes);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for information that links multiple tables, ensure to join the necessary tables to retrieve relevant columns correctly. In this case, the player names needed to be retrieved from the `Player` table, which requires a proper join with the `Player_Attributes` table based on the common `player_api_id`. Always verify relationships between the tables to include additional data you need in your final result.",
        "ground_truth_sql": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "difficulty": "simple"
    },
    {
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "hint": "weight < 130; preferred foot in attacking refers to preferred_foot; preferred_foot = 'left';",
        "error_sql": "SELECT COUNT(*) FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE P.weight < 130 AND PA.preferred_foot = 'left';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are counting distinct players or entries when necessary, especially in situations where multiple records might exist for each player in the related tables. Use `COUNT(DISTINCT ...)` to avoid over-counting due to duplicate entries from JOINs.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "difficulty": "moderate"
    },
    {
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "hint": "finishing rate refers to finishing; highest average finishing rate = MAX(AVG(finishing)); highest football player refers to MAX(height); shortest football player refers to MIN(height);",
        "error_sql": "SELECT AVG(finishing) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height IN (SELECT MAX(height) FROM Player UNION SELECT MIN(height) FROM Player) GROUP BY P.height ORDER BY AVG(finishing) DESC LIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen dealing with multiple aggregate functions and specific conditions, ensure you have a clear understanding of the logical relationships among your queries. Use distinct table aliases for clarity and construct your SQL queries step-by-step to validate each condition independently before combining them. This prevents logical errors arising from complex joins or nested queries. Always carefully analyze the structure and purpose of subqueries to ensure they are providing the intended results.",
        "ground_truth_sql": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM Player ) UNION SELECT AVG(finishing) result, 'Min' A FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM Player ) ) ORDER BY result DESC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "List out of players whose preferred foot is left.",
        "hint": "preferred_foot = 'left';",
        "error_sql": "SELECT player_name FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes WHERE preferred_foot = 'left');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying data that requires joining multiple tables, ensure to use proper JOIN statements instead of relying solely on subqueries with `IN`. This often simplifies the query and reduces the chance of missing relevant records. Always check if the attributes used in the condition are from the correct table in the join.",
        "ground_truth_sql": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "difficulty": "simple"
    },
    {
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "hint": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
        "error_sql": "SELECT AVG(PA.overall_rating) AS average_rating \nFROM Player AS P \nINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \nWHERE P.height > 170 \nAND strftime('%Y', PA.date) BETWEEN '2010' AND '2015';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways check the logical conditions used in your WHERE clause. Ensure that date filtering uses comparison operators correctly (e.g., using >= for the start and <= for the end) instead of relying solely on BETWEEN, which does not account for edge cases in some contexts. Furthermore, be cautious with data type conversions, ensuring calculations are applied to the correct types.",
        "ground_truth_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "hint": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye')); AVG(ball_control WHERE player_name = 'XX XX') = SUM(CASE WHEN player_name = 'XX XX' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'XX XX' THEN id ELSE NULL END)",
        "error_sql": "SELECT \n    (SUM(CASE WHEN P.player_name = 'Abdou Diallo' THEN PA.ball_control ELSE 0 END) / COUNT(CASE WHEN P.player_name = 'Abdou Diallo' THEN PA.id ELSE NULL END)) - \n    (SUM(CASE WHEN P.player_name = 'Aaron Appindangoye' THEN PA.ball_control ELSE 0 END) / COUNT(CASE WHEN P.player_name = 'Aaron Appindangoye' THEN PA.id ELSE NULL END)) AS ball_control_difference\nFROM Player AS P \nINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways cast integers to a REAL type when performing division to avoid integer division, which can lead to incorrect results. This ensures that the calculation retains the necessary precision, especially when dealing with averages. Using `CAST(... AS REAL)` explicitly before performing the division will help achieve accurate results.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "hint": "The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT player_name FROM Player WHERE birthday = (SELECT MIN(birthday) FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada'));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen seeking to compare dates or other ordered values in SQL, use ordering functions such as `ORDER BY` with `LIMIT` to directly retrieve the desired result instead of relying on equality checks with subqueries. This approach ensures that you correctly identify the minimum or maximum values without assuming equal values will yield correct selections. Always verify the logical flow of your queries when dealing with comparisons.",
        "ground_truth_sql": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "hint": "player who perform best in crossing actions refers to MAX(crossing);",
        "error_sql": "SELECT player_name FROM Player WHERE player_api_id = (SELECT player_api_id FROM Player_Attributes WHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes WHERE player_api_id IN (SELECT player_api_id FROM Player WHERE player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone'))));",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL queries correctly join relevant tables and apply filters or aggregations in a clear and systematic way. In the initial attempts, the failure to perform a proper join between the `Player` and `Player_Attributes` tables led to incorrect filtering and subquery issues. To avoid this, outline the columns needed from each table first, and then progressively build the query by incorporating joins and conditions step by step, validating each part against the expected output.",
        "ground_truth_sql": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
        "hint": "height > 180; volley score refers to volleys; volleys > 70;",
        "error_sql": "SELECT COUNT(id) FROM Player_Attributes WHERE player_fifa_api_id IN (SELECT player_fifa_api_id FROM Player WHERE height > 180) AND volleys > 70;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're using the correct foreign key relationships and column names when joining tables. In particular, double-check the join conditions; for example, ensure that you are joining on the appropriate IDs (like `player_api_id` in this case) as different tables may use different keys for the same entity. Additionally, when counting distinct entities, use `DISTINCT` for accurate results, especially when multiple records may exist for a single entity across joined tables.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
        "difficulty": "simple"
    },
    {
        "question": "What is the long passing score of the oldest player?",
        "hint": "long passing score refers to long_passing; oldest player refers to oldest birthday;",
        "error_sql": "SELECT long_passing FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player ORDER BY birthday ASC LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you join related tables when querying for information that exists in both. In this case, since the `long_passing` score is in the `Player_Attributes` table and player information (like `birthday`) is in the `Player` table, you must perform a join to link them and retrieve the correct attribute associated with the oldest player.",
        "ground_truth_sql": "SELECT t2.long_passing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "hint": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
        "error_sql": "SELECT L.name \nFROM League AS L \nJOIN Match AS M ON L.id = M.league_id \nWHERE M.season = '2008/2009' \nGROUP BY L.name \nORDER BY COUNT(M.id) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen needing to find the maximum of a grouped aggregate, ensure to use a subquery in the `HAVING` clause to filter results based on the aggregated count. This allows you to accurately compare counts derived from a specific grouping, rather than attempting to find the maximum count directly in the `ORDER BY` clause. Always validate that your conditions account for all necessary cases to avoid skewed results.",
        "ground_truth_sql": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "difficulty": "simple"
    },
    {
        "question": "What is the average overall rating of the players born before the year 1986?",
        "hint": "average overall rating = DIVIDE(SUM(overall_rating), COUNT(id)); born before the year 1986 refers to strftime('%Y', birthday) < '1986';",
        "error_sql": "SELECT AVG(overall_rating) AS average_overall_rating \nFROM Player AS P \nINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \nWHERE strftime('%Y', P.birthday) < '1986';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the aggregate function and the conditions used in your SQL query. In cases requiring averages, ensure to use `SUM()` and `COUNT()` explicitly instead of `AVG()`, especially when dealing with specific conditions or transformations on your data. Using `SUBSTR()` for extracting specific parts of a string can be more reliable than using `strftime()` for date manipulations.",
        "ground_truth_sql": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "difficulty": "moderate"
    },
    {
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "hint": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);",
        "error_sql": "SELECT \n    ((SELECT overall_rating FROM Player AS P \n      INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \n      WHERE P.player_name = 'Ariel Borysiuk') - \n    (SELECT overall_rating FROM Player AS P \n      INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \n      WHERE P.player_name = 'Paulin Puel')) * 100.0 /\n    (SELECT overall_rating FROM Player AS P \n      INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \n      WHERE P.player_name = 'Paulin Puel') AS percentage_difference;",
        "compiler_hint": "no such column: rating_difference",
        "reflective_cot": "### Tip:\nAlways ensure that you maintain the correct scope for your variables in SQL. In SQL, you cannot reference alias or derived column names (like `rating_difference`) directly in the same SELECT clause where they were defined. Instead, consider using subqueries or CTEs (Common Table Expressions) to calculate intermediate results separately, or restructure your query to encapsulate the entire logic within a single select statement without relying on cross-references in the same level.",
        "ground_truth_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging"
    },
    {
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "hint": "Parma refers to team_long_name = 'Parma'; average number of goals refers to AVG(away_team_goal)",
        "error_sql": "SELECT AVG(away_team_goal) \nFROM Match AS M \nJOIN Team AS T ON M.away_team_api_id = T.team_api_id \nJOIN League AS L ON M.league_id = L.id \nWHERE T.team_long_name = 'Parma' AND L.name = 'Italy';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nCarefully review the joins and ensure that all necessary tables are included. In this case, the first SQL query lacked the join with the Country table, which is essential to filter by the country name. Always verify that all required relationships in the schema are represented in your query to avoid missing criteria.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "difficulty": "moderate"
    },
    {
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "hint": "Kevin Constant refers to player_name = 'Kevin Constant'; highest crossing score refers to MAX(crossing)",
        "error_sql": "SELECT date FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Kevin Constant' AND PA.crossing = (SELECT MAX(crossing) FROM Player_Attributes AS PA2 INNER JOIN Player AS P2 ON PA2.player_api_id = P2.player_api_id WHERE P2.player_name = 'Kevin Constant');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when querying for a specific attribute's maximum value, you not only check for that value but also consider the entire context in which it occurs. Use a subquery to select the maximum value along with the associated data (like date), and leverage ordering to focus on the earliest occurrence. This avoids the pitfall of potentially retrieving the wrong date when multiple records share the same maximum score.",
        "ground_truth_sql": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
        "hint": "\"Willem II\" refers to team_long_name = 'Willem II'; on 2011/2/22 refers to date = '2012-02-22'",
        "error_sql": "SELECT TA.buildUpPlaySpeedClass \nFROM Team AS T \nJOIN Team_Attributes AS TA ON T.team_fifa_api_id = TA.team_fifa_api_id \nWHERE T.team_long_name = 'Willem II' AND TA.date = '2012-02-22';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that dates are formatted consistently in your queries. Additionally, verify that you are using the correct columns and tables based on their relationships, especially when joining tables. When comparing dates, consider checking the format and ensure you are using the right extraction functions if necessary.",
        "ground_truth_sql": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
        "difficulty": "moderate"
    },
    {
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "hint": "\"Hannover 96\" refers to team_long_name = 'Hannover 96'; on 2015/9/10 refers to date LIKE '2015-09-10%';",
        "error_sql": "SELECT TA.defenceAggressionClass \nFROM Team_Attributes AS TA \nJOIN Team AS T ON TA.team_fifa_api_id = T.team_fifa_api_id \nWHERE T.team_long_name = 'Hannover 96' AND TA.date LIKE '2015-09-10%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the correct use of the JOIN condition and ensure that you're referencing the appropriate columns from the tables involved. Also, be careful with date comparisons; using `LIKE` for exact matches can lead to unexpected results. Instead, when looking for a specific date, use `=` for an exact match or ensure to format the condition correctly for ranges (e.g., starting or ending with a specific pattern).",
        "ground_truth_sql": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "difficulty": "moderate"
    },
    {
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "hint": "average overall rating refers to avg(overall_rating); Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to the first 10 characters of date BETWEEN '2007-02-22' and '2016-04-21'",
        "error_sql": "SELECT AVG(PA.overall_rating) \nFROM Player AS P \nINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \nWHERE P.player_name = 'Marko Arnautovic' \nAND PA.date BETWEEN '2007-02-22' AND '2016-04-21';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that date comparisons are done using the correct format and granularity required by the dataset. When filtering dates, if the date includes time information and you are looking for string comparisons (which might not include time), consider using string functions like `SUBSTR` to extract the relevant parts. This prevents errors in date comparisons and ensures accurate results.",
        "ground_truth_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "difficulty": "challenging"
    },
    {
        "question": "List down the name of players who are 35 years old and above.",
        "hint": "35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(birthday) > 34",
        "error_sql": "SELECT player_name FROM Player WHERE datetime('now', 'localtime') - datetime(birthday) > 34 * 365.25;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the calculations involving date differences are expressed in the correct units and context, such as accurately converting the difference into years rather than just relying on days. Always validate your logic against known functions or conversions available in the database engine being used to avoid discrepancies in calculations involving dates.",
        "ground_truth_sql": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "difficulty": "simple"
    },
    {
        "question": "How many home team goal have been scored by Aaron Lennon?",
        "hint": "Aaron Lennon refers to player_name = 'Aaron Lennon'",
        "error_sql": "SELECT SUM(M.home_team_goal) \nFROM Match AS M \nJOIN Player AS P ON M.home_player_1 = P.player_api_id OR \n                    M.home_player_2 = P.player_api_id OR \n                    M.home_player_3 = P.player_api_id OR \n                    M.home_player_4 = P.player_api_id OR \n                    M.home_player_5 = P.player_api_id OR \n                    M.home_player_6 = P.player_api_id OR \n                    M.home_player_7 = P.player_api_id OR \n                    M.home_player_8 = P.player_api_id OR \n                    M.home_player_9 = P.player_api_id OR \n                    M.home_player_10 = P.player_api_id OR \n                    M.home_player_11 = P.player_api_id \nWHERE P.player_name = 'Aaron Lennon';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating statistics for a specific player, ensure you consider both home and away player positions in the match. Always verify if the player can appear in different roles (home or away), and check whether you're aggregating the correct goal data based on those roles. Having a broader perspective on potential player positions will help avoid overlooking scoring opportunities and lead to more accurate queries.",
        "ground_truth_sql": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE t1.player_name = 'Aaron Lennon'",
        "difficulty": "simple"
    },
    {
        "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
        "hint": "Daan Smith refers to player_name = 'Daan Smith'; Filipe Ferreira refers to player_name = 'Filipe Ferreira'",
        "error_sql": "SELECT SUM(M.away_team_goal) \nFROM Match AS M \nJOIN Player AS P1 ON M.away_player_1 = P1.player_api_id \nJOIN Player AS P2 ON M.away_player_2 = P2.player_api_id \nJOIN Player AS P3 ON M.away_player_3 = P3.player_api_id \nJOIN Player AS P4 ON M.away_player_4 = P4.player_api_id \nJOIN Player AS P5 ON M.away_player_5 = P5.player_api_id \nJOIN Player AS P6 ON M.away_player_6 = P6.player_api_id \nJOIN Player AS P7 ON M.away_player_7 = P7.player_api_id \nJOIN Player AS P8 ON M.away_player_8 = P8.player_api_id \nJOIN Player AS P9 ON M.away_player_9 = P9.player_api_id \nJOIN Player AS P10 ON M.away_player_10 = P10.player_api_id \nJOIN Player AS P11 ON M.away_player_11 = P11.player_api_id \nWHERE P1.player_name = 'Daan Smith' OR P2.player_name = 'Daan Smith' \nOR P3.player_name = 'Daan Smith' OR P4.player_name = 'Daan Smith'\nOR P5.player_name = 'Daan Smith' OR P6.player_name = 'Daan Smith' \nOR P7.player_name = 'Daan Smith' OR P8.player_name = 'Daan Smith' \nOR P9.player_name = 'Daan Smith' OR P10.player_name = 'Daan Smith' \nOR P11.player_name = 'Daan Smith' \nOR P1.player_name = 'Filipe Ferreira' OR P2.player_name = 'Filipe Ferreira' \nOR P3.player_name = 'Filipe Ferreira' OR P4.player_name = 'Filipe Ferreira' \nOR P5.player_name = 'Filipe Ferreira' OR P6.player_name = 'Filipe Ferreira' \nOR P7.player_name = 'Filipe Ferreira' OR P8.player_name = 'Filipe Ferreira' \nOR P9.player_name = 'Filipe Ferreira' OR P10.player_name = 'Filipe Ferreira' \nOR P11.player_name = 'Filipe Ferreira';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nUse a more systematic approach to associate players with their respective teams by leveraging a single join operation for all the players on the same team. Instead of multiple joins for each player position, consider using a `UNION` or simplifying the join clauses to check if the player's ID is in any of the away player slots, which reduces complexity and potential errors.",
        "ground_truth_sql": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
        "difficulty": "moderate"
    },
    {
        "question": "Calculate the total home team goal scored by players whose age are 30 years old and below.",
        "hint": "age are 30 years old and below refers to SUBTRACT(datetime(CURRENT_TIMESTAMP,'localtime'), datetime(birthday) < 31)",
        "error_sql": "SELECT SUM(M.home_team_goal) \nFROM Match AS M \nJOIN Player AS P ON M.home_player_1 = P.player_api_id \n   OR M.home_player_2 = P.player_api_id \n   OR M.home_player_3 = P.player_api_id \n   OR M.home_player_4 = P.player_api_id \n   OR M.home_player_5 = P.player_api_id \n   OR M.home_player_6 = P.player_api_id \n   OR M.home_player_7 = P.player_api_id \n   OR M.home_player_8 = P.player_api_id \n   OR M.home_player_9 = P.player_api_id \n   OR M.home_player_10 = P.player_api_id \n   OR M.home_player_11 = P.player_api_id \nWHERE (strftime('%Y', 'now') - strftime('%Y', P.birthday)) < 31;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the logic used in SQL queries, especially when calculating age or comparing dates. Make sure to account for the entire dataset and use appropriate JOIN operations to include all relevant player positions correctly. Additionally, verify the birthday comparison logic to ensure it accurately reflects the age condition you want to impose. Use detailed conditions and structured joins to avoid overlooking any players.",
        "ground_truth_sql": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31",
        "difficulty": "moderate"
    },
    {
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "hint": "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';",
        "error_sql": "SELECT player_name \nFROM Player P \nJOIN Player_Attributes PA ON P.player_fifa_api_id = PA.player_fifa_api_id \nWHERE PA.attacking_work_rate = 'high';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are using the correct foreign key in your JOIN conditions. In this case, `PA.player_api_id` should refer to the unique identifier in the `Player` table instead of `PA.player_fifa_api_id`. Double-check the schema relationships and ensure that the columns being joined match correctly to avoid such errors.",
        "ground_truth_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "difficulty": "moderate"
    },
    {
        "question": "State the name of players who came from Belgium.",
        "hint": "name of players refers to player_name; Belgium is name of country",
        "error_sql": "SELECT P.player_name \nFROM Player AS P \nJOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \nJOIN Country AS C ON P.player_fifa_api_id = C.id \nWHERE C.name = 'Belgium';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to analyze the relationships between tables thoroughly before writing queries. In this case, the `Country` table was not directly linked to the `Player` table, but rather through the `Match` table, which associates players with their respective countries based on the matches they participated in. Always check the foreign key relationships to appropriately navigate through the relevant tables.",
        "ground_truth_sql": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "difficulty": "simple"
    },
    {
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "hint": "vision scores of 90 and above refers to vision > 89",
        "error_sql": "SELECT P.player_name, C.name AS country \nFROM Player AS P \nINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id \nINNER JOIN Team AS T ON P.player_api_id = T.team_api_id \nINNER JOIN League AS L ON T.team_api_id = L.id \nINNER JOIN Country AS C ON L.country_id = C.id \nWHERE PA.vision > 89;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the relationships and foreign key references between tables. Ensure you're joining the correct keys that represent the intended relationships. Additionally, when attempting to retrieve associated attributes, make sure to join tables that directly relate to the queried data, rather than indirectly, to avoid missing pertinent connections or leading to incorrect results.",
        "ground_truth_sql": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "difficulty": "moderate"
    },
    {
        "question": "Which country's players have the heaviest average weights?",
        "hint": "heaviest average weights refers to MAX(AVG(weight))",
        "error_sql": "SELECT C.name FROM Country AS C JOIN Player AS P ON C.id = P.player_api_id GROUP BY C.id ORDER BY AVG(P.weight) DESC LIMIT 1;",
        "compiler_hint": "no such column: country_name",
        "reflective_cot": "### Tip:\nWhen joining multiple tables, ensure that you are using the correct foreign keys and mapping relationships accurately. Verify which column from each table holds the relevant foreign key and ensure that you are referencing the right fields when performing joins. Additionally, always confirm that the columns you are selecting from the tables actually exist and are spelled correctly to prevent \"no such column\" errors. Debugging your query incrementally can help in identifying where the logic may be flawed.",
        "ground_truth_sql": "SELECT t1.name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY t1.name ORDER BY AVG(t3.weight) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the average heights of Italy players?",
        "hint": "average heights refers to Avg(height); Italy is name of country",
        "error_sql": "SELECT AVG(height) \nFROM Player \nWHERE player_fifa_api_id IN (SELECT team_fifa_api_id FROM Team WHERE team_long_name = 'Italy')",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you're joining the correct tables to access related data. In this case, the Player table should be linked to the Match table and Country table, as the height data is not directly linked to the Player's country through the Team table. Always verify the relationships and foreign keys in the schema to retrieve the necessary data accurately.",
        "ground_truth_sql": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "difficulty": "simple"
    },
    {
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "hint": "difference between players 6 and 23's jumping scores refers to SUBTRACT(jumping AND id = 6,jumping AND id = 23)",
        "error_sql": "SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to perform operations involving multiple rows based on specific conditions, always ensure to aggregate the values appropriately (e.g., using `SUM`, `COUNT`, etc.). Using subqueries directly for specific row values without aggregation can lead to errors or unexpected results. Always check if you need to aggregate multiple potential results to ensure the final value is computed correctly.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "difficulty": "simple"
    },
    {
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "hint": "lowest potential players refers to MIN(potential); prefer to use the right foot when attacking refers to preferred_foot = 'right'",
        "error_sql": "SELECT player_api_id FROM Player_Attributes WHERE potential = (SELECT MIN(potential) FROM Player_Attributes) AND preferred_foot = 'right' LIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you clearly understand the requirements of the query before constructing it. In this case, the goal was to find the lowest potential players who prefer the right foot. Your initial approach focused only on the absolute minimum potential, neglecting to consider that multiple players might share the same low potential. Instead, the correct approach was to order by potential and properly filter for those who use the right foot, capturing the lowest potentials among that subset. Always reflect on whether the SQL logic matches the query intention by breaking it down into smaller logical components.",
        "ground_truth_sql": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "What percentage of players have a strength and stamina score of more than 80?",
        "hint": "strength and stamina score of more than 80 refers to stamina > 80 and strength > 80",
        "error_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Player)) AS percentage\nFROM Player_Attributes\nWHERE strength > 80 AND stamina > 80;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the denominator in percentage calculations reflects the total number of relevant records. In this case, the total count should be `COUNT(*) FROM Player_Attributes`, as you are specifically interested in player attributes, not the overall player count. Double-check the context of your data and adjust your SQL accordingly to avoid similar mistakes.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t",
        "difficulty": "simple"
    },
    {
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "hint": "In the 2015\u20132016 season refers to season = '2015/2016'",
        "error_sql": "SELECT COUNT(*) \nFROM Match AS M \nJOIN League AS L ON M.league_id = L.id \nWHERE M.season = '2015/2016' AND L.name = 'Italian Serie A';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the exact naming conventions used in the database, including spaces and punctuation, when formulating your SQL queries. Double-check to ensure that the league names or other identifiers are referenced accurately to avoid syntax errors or mismatches.",
        "ground_truth_sql": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "difficulty": "simple"
    },
    {
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "hint": "finishing rate refer to finishing; curve score refer to curve; heaviest weight refers to MAX(weight)",
        "error_sql": "SELECT finishing, curve FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that the final data you are trying to retrieve correlates correctly with the identifiers used in subqueries. In this case, ensure you are selecting data from the correct attributes table associated with the player\u2019s maximum weight. Using the player's `id` from the `Player` table as a reference can help ensure you're retrieving the precise attributes needed.",
        "ground_truth_sql": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
        "hint": "percentage refers to DIVIDE(COUNT(height < 180 AND overall_rating > 70),COUNT(id)) * 100",
        "error_sql": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Player)) AS percentage\nFROM Player P \nJOIN Player_Attributes PA ON P.player_api_id = PA.player_api_id \nWHERE P.height < 180 AND PA.overall_rating > 70;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to use the correct aggregation function and conditionally count the relevant cases accurately. Using `COUNT(CASE ...)` allows you to selectively count only the rows that meet a certain condition while still having overall counts correct. Additionally, verifying the semantics of the SQL function used (like `COUNT`, `SUM`, etc.) in relation to null values or conditions can prevent logical errors in queries.",
        "ground_truth_sql": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180",
        "difficulty": "moderate"
    },
    {
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "hint": "male refers to SEX = 'M'; in-patient refers to Admission = '+'; outpatient refers to Admission = '-'; percentage = DIVIDE(COUNT(ID) where SEX = 'M' and Admission = '+', COUNT(ID) where SEX\u00a0 = 'M' and Admission = '-')",
        "error_sql": "SELECT \n    COUNT(CASE WHEN SEX = 'M' AND Admission = '+' THEN 1 END) AS male_inpatients,\n    COUNT(CASE WHEN SEX = 'M' AND Admission = '-' THEN 1 END) AS male_outpatients,\n    ROUND(CAST(COUNT(CASE WHEN SEX = 'M' AND Admission = '+' THEN 1 END) AS REAL) * 100 / NULLIF(COUNT(CASE WHEN SEX = 'M' AND Admission = '-' THEN 1 END), 0), 2) AS inpatient_percentage\nFROM Patient;",
        "compiler_hint": "near \")\": syntax error",
        "reflective_cot": "### Tip:\nAlways ensure that your SQL syntax is correct, particularly with parentheses and commas. When using aggregate functions like `ROUND()`, make sure to close all opened parentheses properly. Additionally, it can be helpful to break your query into smaller parts and test them individually to isolate errors before combining them into a final query.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of female patient were born after 1930?",
        "hint": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
        "error_sql": "SELECT (COUNT(CASE WHEN p.Birthday > '1930-01-01' AND p.SEX = 'F' THEN 1 END) * 100.0 / COUNT(CASE WHEN p.SEX = 'F' THEN 1 END)) AS female_percentage \nFROM Patient AS p;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you're accurately filtering and counting rows in your queries. When calculating percentages, specifically consider how you're counting the total relevant group instead of the entire dataset. Using aggregates correctly and properly scoping your `WHERE` clauses can help prevent incorrect results. Also, remember to convert your data types appropriately to avoid any issues with numeric comparisons.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "difficulty": "moderate"
    },
    {
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "hint": "who were born in 1937 refers to year(birthday) = '1937'; total cholesterol was beyond the normal range refers to `T-CHO` > = '250'",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE strftime('%Y', P.Birthday) = '1937' AND L.`T-CHO` >= 250;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when filtering for distinct records, you use `SELECT DISTINCT` to avoid duplicate entries in your results. Additionally, double-check the conditions in your `WHERE` clause for completeness, especially when dealing with ranges or specific criteria.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "difficulty": "moderate"
    },
    {
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "hint": "age refers to SUBTRACT(YEAR(`First Date`),YEAR(Birthday))",
        "error_sql": "SELECT MIN(JULIANDAY(`First Date`) - JULIANDAY(Birthday)) / 365.25 AS youngest_age \nFROM Patient;",
        "compiler_hint": "no such function: YEAR",
        "reflective_cot": "### Tip:\nAlways verify the functions and syntax supported by the SQL database you are using. Functions such as `YEAR()` or `STRFTIME()` have specific implementations in different SQL dialects. Refer to the official documentation to confirm supported functions and syntax for date manipulation. Use generic operations like `JULIANDAY()` carefully, ensuring they align with requirements for date calculations in your given SQL type.",
        "ground_truth_sql": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "difficulty": "simple"
    },
    {
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "hint": "the most serious thrombosis refers to Thrombosis = '1' (the most severe one); women refers to sex = 'F'",
        "error_sql": "SELECT COUNT(P.ID) AS female_thrombosis_count \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE E.Thrombosis = 1 AND P.SEX = 'F' AND strftime('%Y', P.Description) = '1997';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the date filtering is applied to the correct table and column to avoid mismatches. Review which table contains the relevant date information, and verify that the join conditions and filtering criteria align with the correct data relationships. This can prevent logical errors in your SQL queries.",
        "ground_truth_sql": "SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1",
        "difficulty": "moderate"
    },
    {
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; symptoms observed refers to the symptoms is not NULL",
        "error_sql": "SELECT E.Symptoms, E.Diagnosis \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE P.Birthday = (SELECT MAX(Birthday) FROM Patient) AND E.Symptoms IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're aiming to select the correct aggregation condition based on the requirement. In cases where you need to find the youngest patient, use `MAX(Birthday)` or sort by `Birthday` in descending order, and incorporate appropriate filtering for NULL values. Cross-check subqueries for logical consistency with the main query's goal to avoid mismatched conditions.",
        "ground_truth_sql": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "hint": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)",
        "error_sql": "SELECT MAX(L.Date) AS latest_lab_date, (strftime('%Y', P.`First Date`) - strftime('%Y', P.Birthday)) AS age_at_arrival \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Diagnosis = 'SJS';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you consider how to properly aggregate data when dealing with multiple records. Use `GROUP BY` correctly along with aggregate functions to prevent losing relevant context or data uniqueness. Be mindful of data filtering to ensure valid conditions (like checking for NULL values) that might affect your results. Always validate the ordering of your results when looking for minimum or maximum values.",
        "ground_truth_sql": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "hint": "hadn't undergone a medical examination until at least a year refers to SUBTRACT(year(`Examination Date`), year(`First Date`)) > = 1",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS patients_without_exam \nFROM Patient AS P \nWHERE NOT EXISTS (\n    SELECT 1 \n    FROM Examination AS E \n    WHERE E.ID = P.ID \n    AND (strftime('%Y', E.`Examination Date`) - strftime('%Y', P.`First Date`)) >= 1\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to clearly understand the condition you are checking for in subqueries. In this case, the focus should be on counting patients who did not have an examination after a specific duration, rather than incorrectly including those who had an examination before that period. Always validate the logic of your conditions before formulating the SQL query. Additionally, double-check for any additional filters (like the Admission status) that may affect the counting logic.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '+' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "hint": "underage patients refers to year(Birthday) < 18; three-year period from 1990 to 1993 refers to year(`Examination Date`) between '1990' and '1993'",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS underage_patients_count \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE strftime('%Y', P.Birthday) > strftime('%Y', E.`Examination Date`) - 18 \nAND strftime('%Y', E.`Examination Date`) BETWEEN '1990' AND '1993';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are correctly comparing values in the context of the SQL query. When calculating ages or any derived values based on dates, be mindful of how comparisons are structured, especially regarding the order of subtraction. Additionally, thoroughly review logical conditions to ensure they align with the intended criteria, such as direct comparisons rather than a transformation that might lead to logical errors. Validate your calculations by considering boundary cases and double-checking the year extraction logic.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "difficulty": "challenging"
    },
    {
        "question": "How many male patients have elevated total bilirubin count?",
        "hint": "male refers to SEX = 'M'; elevated means above the normal range; total bilirubin above the normal range refers to `T-BIL` >= '2.0'",
        "error_sql": "SELECT COUNT(P.ID) AS male_patients_with_elevated_tbil \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-BIL` >= 2.0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to use `COUNT(DISTINCT ...)` when counting unique patient IDs to avoid double counting in cases where a patient has multiple lab records. Always verify the aggregation method needed based on the context of the data being queried.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "difficulty": "simple"
    },
    {
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "hint": "How old the patient refers to SUBTRACT(year(`Examination Date`), year(Birthday)); the highest hemoglobin count refers to MAX(HGB)",
        "error_sql": "SELECT (STRFTIME('%Y', E.`Examination Date`) - STRFTIME('%Y', P.Birthday)) AS age, E.Diagnosis \nFROM Examination AS E \nINNER JOIN Patient AS P ON E.ID = P.ID \nINNER JOIN Laboratory AS L ON E.ID = L.ID \nWHERE L.HGB = (SELECT MAX(HGB) FROM Laboratory);",
        "compiler_hint": "no such column: E.HGB",
        "reflective_cot": "### Tip:\nAlways ensure that you are referencing the correct table or alias when accessing columns in SQL queries, especially when joining multiple tables. In your initial attempt, you tried to access `E.HGB`, but `HGB` was located in the `Laboratory` table, leading to the \"no such column\" error. To avoid this, double-check column origins and correctly join the necessary tables to access the required data. Additionally, use aliases meaningfully to maintain clarity on which table is being referred to at all times.",
        "ground_truth_sql": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "hint": "diagnosed with SLE refers to Diagnosis = 'SLE'; 1994/2/19 refers to Description = '1994-02-19'; anti-Cardiolipin refers to aCL IgM; 1993/11/12 refers to Examination Date = '1993/11/12'",
        "error_sql": "SELECT CASE WHEN E.`aCL IgM` < 12 THEN 'Normal' ELSE 'Not Normal' END AS aCL_IgM_Status \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE P.Diagnosis = 'SLE' AND P.Description = '1994-02-19' AND E.`Examination Date` = '1993-11-12';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, particularly those involving multiple conditions and joins, ensure that you retrieve the relevant columns from the correct tables. Always verify that the necessary data exists in the specified table and use subqueries or joins effectively to filter results based on specific criteria. Checking intermediate results can help identify whether you are querying the correct information from the appropriate tables.",
        "ground_truth_sql": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "hint": "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN `T-CHO`), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`))",
        "error_sql": "SELECT (SUM(CASE WHEN L.Date LIKE '1981-11-%' THEN L.`T-CHO` END) - SUM(CASE WHEN L.Date LIKE '1981-12-%' THEN L.`T-CHO` END)) AS Cholesterol_Decrease_Rate\nFROM Patient AS P\nINNER JOIN Laboratory AS L ON P.ID = L.ID\nWHERE P.Birthday = '1959-02-18';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you handle null values properly in aggregate functions like SUM. Instead of just checking for conditions, use `ELSE 0` in your CASE statements to avoid summing null results, which can lead to inaccurate calculations. Additionally, when calculating rates or percentages, divide by a total that has a valid denominator to avoid division by zero issues.",
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "difficulty": "challenging"
    },
    {
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "hint": "'Behcet' refers to diagnosis; exam between 01/01/1997 and 12/31/1997 refers to YEAR(Description) > = '1997-1-1' AND YEAR(Description) < '1998-1-1'",
        "error_sql": "SELECT P.ID \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE P.Diagnosis = 'Behcet' AND E.`Examination Date` BETWEEN '1997-01-01' AND '1997-12-31';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you reference the correct table and column for the conditions in your SQL queries. In this case, the `Diagnosis` column should be queried from the `Examination` table, not the `Patient` table. Always double-check which table contains the fields you need, especially when using `JOIN` statements, to prevent confusion and ensure accurate results.",
        "ground_truth_sql": "SELECT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet'",
        "difficulty": "moderate"
    },
    {
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "hint": "thrombosis level 2 refers to Thrombosis = 2; ANA pattern of only S refers to ANA = 'S'; average anti-Cardiolip in antibody (IgM) refers to AVG(`aCL IgM`); calculation = MULTIPLY(AVG + AVG, 0.2)",
        "error_sql": "SELECT COUNT(P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE E.Thrombosis = 2 AND E.ANA = 'S' AND E.`aCL IgM` > (SELECT AVG(E2.`aCL IgM`) * 1.2 FROM Examination AS E2);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the column names used in the SQL query match those in the database schema precisely, especially when dealing with conditions and subqueries. Additionally, it's important to check the context of the aggregation in subqueries to ensure they accurately reflect the intended dataset. Use consistent naming conventions to avoid confusion, and always validate conditions against potential NULL values where applicable.",
        "ground_truth_sql": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "difficulty": "challenging"
    },
    {
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "hint": "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to UA < = 6.5; calculation = MULTIPLY(DIVIDE(UA < = 6.5, `U-PRO` > 0 AND `U-PRO` < 30)\uff0c100)",
        "error_sql": "SELECT (COUNT(CASE WHEN L.UA <= 6.5 THEN L.ID END) * 100.0 / COUNT(CASE WHEN L.`U-PRO` > 0 AND L.`U-PRO` < 30 THEN L.ID END)) AS percentage \nFROM Laboratory AS L \nINNER JOIN Patient AS P ON L.ID = P.ID;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the SQL query correctly filters the data before performing any calculations. Use aggregate functions and conditional counting in a way that ensures you only consider the relevant records. Additionally, always validate the logic of how the conditions are applied to ensure the correct data subsets are being used for calculations.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "difficulty": "challenging"
    },
    {
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "hint": "followed up at the outpatient clinic refers to Admission = '-'; laboratory test in April 1981 refers to Date like '1991-10%'; blood bilirubin level within the normal range refers to T-BIL < 2.0; ",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday, P.`First Date`, P.Diagnosis \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Admission = '-' AND L.Date LIKE '1991-10%' AND L.`T-BIL` < 2.0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying databases, it's essential to be precise with date comparisons and formats. Instead of using `BETWEEN` for a specific month, using the `LIKE` clause allows for matching the exact string format of the date you're after, especially when considering the variations in date representation across different SQL dialects. Always verify that your date conditions and other constraints align exactly with the intended criteria.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "difficulty": "challenging"
    },
    {
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "hint": "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id",
        "error_sql": "SELECT P.Description, P.Diagnosis \nFROM Patient AS P \nWHERE P.ID = 48473;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are selecting the correct columns that directly answer the question. In this case, the question specifically asked for the date the medical information was first documented (`First Date`) and the diagnosis, but the initial queries incorrectly focused on other columns like `Description` instead of precisely addressing the requirements. Always double-check the query specifications against the question to avoid such misunderstandings.",
        "ground_truth_sql": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "difficulty": "simple"
    },
    {
        "question": "How many patients who underwent testing in 1997 had protein levels outside the normal range?",
        "hint": "underwent testing in 1997 refers to YEAR(DATE) = '1997'; protein levels within the normal range refers to tp > 6 and tp < 8.5",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Laboratory AS L \nINNER JOIN Patient AS P ON L.ID = P.ID \nWHERE L.Date BETWEEN '1997-01-01' AND '1997-12-31' AND (L.TP < 6.0 OR L.TP > 8.5);",
        "compiler_hint": "no such function: YEAR",
        "reflective_cot": "### Tip:\nWhen working with SQL, especially in databases that don't support specific functions like `YEAR()`, always check the available date functions and string formatting options. Use standard methods such as date ranges or string manipulation functions (e.g., `STRFTIME()`) to extract parts of dates. This will enhance compatibility across different SQL dialects and help avoid common pitfalls related to date handling.",
        "ground_truth_sql": "SELECT COUNT(ID) FROM Laboratory WHERE (ALB <= 6.0 OR ALB >= 8.5) AND STRFTIME('%Y', Date) = '1997'",
        "difficulty": "simple"
    },
    {
        "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
        "hint": "thrombocytopenia' refers to symptoms; 'SLE' refers to diagnosis; calculation =  DIVIDE(SUM(DIAGNOSIS LIKE '%ITP%'), SUM(DIAGNOSIS LIKE '%SLE%')) MULTIPLY 100",
        "error_sql": "SELECT \n    CAST(SUM(CASE WHEN E.Symptoms LIKE '%thrombocytopenia%' AND P.Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN E.Symptoms LIKE '%thrombocytopenia%' THEN 1 ELSE 0 END) AS REAL) * 100 AS proportion_of_SLE_diagnosed \nFROM \n    Patient AS P \nJOIN \n    Examination AS E ON P.ID = E.ID;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating proportions or percentages, ensure that you correctly reference the columns and context in your queries. Specifically, if you need to check how many patients with a certain symptom were diagnosed with a particular condition, ensure that you're aggregating based on the relevant conditions and that you're using appropriate filters. Additionally, be cautious with your logical checks (e.g., using COUNT vs. SUM) to avoid skewed results\u2014always validate your logic against the conditions you're analyzing.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
        "difficulty": "moderate"
    },
    {
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment?",
        "hint": "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; Behcet refers to diagnosis; did not stay in the hospital refers to Admission = '-'",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS male_behcet_outpatients \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE P.SEX = 'M' AND E.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31' \nAND P.Diagnosis = 'Behcet' AND P.Admission = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you're consistently referencing the correct table for each field when constructing your SQL queries. In your case, the `Diagnosis` field should be referenced from the `Patient` table instead of the `Examination` table, as that is where the patient diagnosis is recorded. Always verify that the columns you are accessing belong to the intended tables, especially when using joins.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "difficulty": "challenging"
    },
    {
        "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
        "hint": "DATEDIFF(`Examination Date`, `First Date`)",
        "error_sql": "SELECT JULIANDAY(E.`Examination Date`) - JULIANDAY(P.`First Date`) AS days_between \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE P.ID = 821298 \nORDER BY E.`Examination Date` ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating date differences, ensure you're using the correct date functions that return results suitable for your needs. In the first two queries, the JULIANDAY function was appropriate for calculating date differences, but the selection of formatting and the way the result was retrieved may have led to confusion. For clear results, using date and time functions like DATEDIFF (if supported) or directly manipulating the dates in a consistent format, as seen in the ground truth, can help avoid errors. Always verify that the data types involved in calculations are compatible and simplify your queries to catch any logical errors early on.",
        "ground_truth_sql": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
        "difficulty": "simple"
    },
    {
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "hint": "uric acid within a normal range refers to UA > 8.0 and SEX = 'M'OR UA > 6.5 and SEX = 'F'",
        "error_sql": "SELECT CASE \n    WHEN (P.SEX = 'M' AND L.UA > 8.0) OR (P.SEX = 'F' AND L.UA > 6.5) THEN 'Normal' \n    ELSE 'Not Normal' \nEND AS Uric_Acid_Status \nFROM Laboratory AS L \nINNER JOIN Patient AS P ON L.ID = P.ID \nWHERE P.ID = 57266;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure the logical conditions reflect the criteria accurately. In this case, \"within a normal range\" should check for values exceeding the thresholds, not the opposite. Double-check that your SQL logic aligns directly with the requirements stated in the question before executing queries.",
        "ground_truth_sql": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "difficulty": "moderate"
    },
    {
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "hint": "AST glutamic oxaloacetic transaminase (GOT) index is within normal range refers to GOT < 60; examination in 1994 refers to year(Date) = 1994",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.GOT < 60 AND strftime('%Y', L.Date) = '1994';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use `DISTINCT` when you want to avoid duplicate results in your query, especially when selecting specific columns from multiple tables. This ensures that your output is unique and meets the intended criteria.",
        "ground_truth_sql": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "difficulty": "moderate"
    },
    {
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "hint": "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); lactate dehydrogenase (LDH) between 100-300 index above the normal range refers to LDH between 600 and 800;",
        "error_sql": "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.LDH BETWEEN 600 AND 800;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use the correct range operators when filtering numerical values and ensure to consider inclusive and exclusive boundaries as required. Also, double-check joins and make sure that you're selecting the correct columns and using the right aliases to avoid confusion. In particular, be aware of using `>` and `<` compared to `BETWEEN`, as `BETWEEN` includes the boundary values.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "difficulty": "moderate"
    },
    {
        "question": "For patients with alkaliphophatase (ALP) within normal range, were they treated as inpatient or outpatient?",
        "hint": "alkaliphophatase (ALP) within normal range refers to ALP < 300; inpatient refers to admission = '+'; outpatient refers to admission = '-'",
        "error_sql": "SELECT P.Admission, COUNT(P.ID) AS patient_count \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.ALP < 300 \nGROUP BY P.Admission;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to include all required output columns in the SELECT statement, especially when the objective is to group or aggregate data. Additionally, be cautious about the distinction between grouping and selecting the necessary fields; a mismatch can lead to incorrect or incomplete results.",
        "ground_truth_sql": "SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300",
        "difficulty": "moderate"
    },
    {
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "hint": "alkaliphophatase (ALP) within normal range refers to ALP < 300",
        "error_sql": "SELECT P.ID, CASE WHEN L.ALP < 300 THEN 'Yes' ELSE 'No' END AS ALP_within_normal \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Birthday = '1982-04-01';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the possibility of null values in your joins and use LEFT JOIN when you want to ensure that all records from the primary table (Patient) are included, even if there are no corresponding matches in the secondary table (Laboratory). Additionally, ensure you are filtering based on relevant conditions to avoid missing potential records.",
        "ground_truth_sql": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "difficulty": "moderate"
    },
    {
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "hint": "female refers to SEX = 'F'; total protein (TP) beyond the normal index refers to TP > 8.5; deviation of TP index from normal refers to SUBTRACT(TP, 8.5)",
        "error_sql": "SELECT P.ID, (L.TP - 8.5) AS TP_Deviation \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'F' AND L.TP > 8.5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are selecting the correct columns and applying the required calculations in the main SELECT statement. Be cautious with aliases and reference them correctly in your queries. Additionally, verify the logical sequence of your SQL query before execution, especially when it involves arithmetic operations; review if all referenced columns are part of the SELECT clause. This can prevent oversights and help ensure your query aligns with what you're intending to retrieve.",
        "ground_truth_sql": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "difficulty": "moderate"
    },
    {
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "hint": "male = SEX = 'M'; albumin not within range refers to ALB < = 3.5 or ALB > = 5.5",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND (L.ALB <= 3.5 OR L.ALB >= 5.5) \nORDER BY P.Birthday DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you select the appropriate columns and consider the use of `DISTINCT` when necessary. Additionally, double-check JOIN operations to ensure all required fields are present in the final output. When formulating queries, think through the logic to determine if you're filtering or displaying everything needed to meet the criteria of the requirements.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "difficulty": "simple"
    },
    {
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "hint": "Year(Birthday) = '1982'; albumin is within normal range refers to ALB between 3.5 and 5.5",
        "error_sql": "SELECT P.ID, \n       CASE WHEN L.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range' \n            ELSE 'Outside Normal Range' END AS Albumin_Status \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Birthday BETWEEN '1982-01-01' AND '1982-12-31';",
        "compiler_hint": "no such function: YEAR",
        "reflective_cot": "### Tip:\nWhen working with date functions in SQL, always check the documentation for the specific SQL dialect you are using. Functions like `YEAR()` may not be available, and instead, you might need to use string manipulation functions like `STRFTIME()` to extract year information. Additionally, ensure to use proper data range comparisons when filtering dates.",
        "ground_truth_sql": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "difficulty": "moderate"
    },
    {
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "hint": "uric acid (UA) with normal range refers to UA < 8.0 and SEX = 'M' or UA < 6.5 and SEX = 'F'; average UA index refers to AVG(UA)",
        "error_sql": "SELECT AVG(L.UA) AS average_ua \nFROM Laboratory AS L \nINNER JOIN Patient AS P ON L.ID = P.ID \nWHERE (P.SEX = 'M' AND L.UA < 8.0) OR (P.SEX = 'F' AND L.UA < 6.5) \nAND L.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = P.ID);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nBe cautious with the placement of parentheses in your SQL query conditions. When combining multiple conditions with `AND` and `OR`, ensure that you clearly define the order of operations. Use parentheses to group conditions to avoid logical errors in your WHERE clause. Additionally, when using subqueries to get the latest date, ensure that it accurately corresponds to the specific patient being referenced. Always double-check the logic and structure of your SQL queries before running them.",
        "ground_truth_sql": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "difficulty": "moderate"
    },
    {
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "hint": "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5",
        "error_sql": "SELECT (SUM(CASE WHEN P.SEX = 'M' AND L.CRE >= 1.5 THEN 1 ELSE 0 END) > SUM(CASE WHEN P.SEX = 'F' AND L.CRE >= 1.5 THEN 1 ELSE 0 END)) AS more_male_patients \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID;",
        "compiler_hint": "no such column: P.SEX",
        "reflective_cot": "### Tip:\nAlways ensure your SQL queries account for the filtering criteria before performing aggregations. In your initial queries, the join conditions were correct, but you did not include a WHERE clause to filter the creatinine values prior to counting the patients. This caused your aggregation to potentially include non-relevant rows. Always double-check the order of operations in SQL to ensure that filters are applied before aggregation.",
        "ground_truth_sql": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "difficulty": "challenging"
    },
    {
        "question": "What is the highest total bilirubin level recorded? List out the patient details with ID, sex and birthday with that index.",
        "hint": "the highest total bilirubin refers to MAX(T-BIL)",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to include necessary columns in the SELECT statement from the beginning, especially when working with aggregate functions like MAX(). Additionally, using ORDER BY with LIMIT can simplify fetching the highest value along with associated details directly, rather than relying on subqueries which might not handle NULLs or require multiple joins effectively.",
        "ground_truth_sql": "SELECT T2.`T-BIL`, T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "hint": "List refers to GROUP_CONCAT(DISTINCT ID); total bilirubin (T-BIL) not within normal range refers to T-BIL > = 2.0",
        "error_sql": "SELECT P.SEX, GROUP_CONCAT(DISTINCT P.ID) AS Patient_IDs \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.`T-BIL` >= 2.0 \nGROUP BY P.SEX;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the groupings in your SQL query align with your aggregation requirements. When grouping by a column (e.g., SEX), make sure to include any necessary columns in the `SELECT` statement to ensure valid grouping, or to eliminate repetition. In cases where distinct values are required, use `GROUP_CONCAT` appropriately and verify the groupings do not introduce ambiguity or unintended results. It's also helpful to review the grouping strategy after constructing the query to confirm it accurately reflects the dataset's structure.",
        "ground_truth_sql": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "difficulty": "moderate"
    },
    {
        "question": "Who is the oldest patient with the highest total cholesterol (T-CHO). State the patient ID and T-CHO index.",
        "hint": "oldest patient refers to MIN(birthday); highest total cholesterol refers to MAX(T-CHO);",
        "error_sql": "SELECT P.ID, MAX(L.`T-CHO`) AS Highest_T_CHO \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Birthday = (SELECT MIN(Birthday) FROM Patient) \nGROUP BY P.ID;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to obtain a specific record based on multiple criteria (like fetching the oldest patient with the highest cholesterol), ensure you are correctly ordering and selecting records based on all necessary conditions in one query. Instead of filtering on a single criterion first, try joining and sorting directly to allow the database to handle the complexity efficiently. Always verify that aggregation functions like MAX or conditions (like filtering by birthday) correspond correctly to the result you desire.",
        "ground_truth_sql": "SELECT T1.ID, T2.`T-CHO` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-CHO` DESC, T1.Birthday ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the average age of the male patient with high cholesterol?",
        "hint": "average age = DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(birthday))), COUNT(ID)); male patient refers to sex = 'M'; high cholesterol refers to `T-CHO` > = 250;",
        "error_sql": "SELECT SUM(strftime('%Y', 'now') - strftime('%Y', P.Birthday)) / COUNT(P.ID) AS average_age \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.`T-CHO` >= 250;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're using the correct functions and syntax for date calculations. Instead of calculating ages by manipulating years directly, consider using functions that account for the specific date formats involved and provide correct date arithmetic. Additionally, ensure you're verifying the output format of date functions to align with the expected results.",
        "ground_truth_sql": "SELECT AVG(STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-CHO` >= 250 AND T1.SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "hint": "blood glucose (GLU) index that were within normal range refers to GLU < 180; data that was first recorded in 1991 refers to year(Description) = 1991;",
        "error_sql": "SELECT P.ID, L.GLU \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.GLU < 180 AND strftime('%Y', P.Description) = '1991';",
        "compiler_hint": "no such function: year",
        "reflective_cot": "### Tip:\nAlways verify the columns being used for filtering conditions in your SQL queries. Ensure that you are using the correct column specified in the database schema and logic outlined in the requirements. Use consistent naming conventions and remain aware of datatype discrepancies, which can lead to issues with functions like `strftime`. When unsure about a function's applicability, check the SQL documentation or error messages for guidance on available functions in your SQL dialect.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "difficulty": "moderate"
    },
    {
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "hint": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); ",
        "error_sql": "SELECT P.ID, (STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday)) AS Age, P.Diagnosis \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.RBC < 3.5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are not incorrectly joining tables when not necessary for the information you need. In the initial query, you included the `Examination` table without needing its data, which can lead to confusion. Always validate whether all joins are essential to achieve the desired result and focus on the specific columns required from each table. Additionally, use `DISTINCT` if you need to avoid duplicate records in your query results when combining data from multiple tables.",
        "ground_truth_sql": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "difficulty": "moderate"
    },
    {
        "question": "For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",
        "hint": "female patient refers to Sex = 'F'; age 50 and above = SUBTRACT(year(current_timestamp), year(Birthday)) > = 50; abnormal red blood cell count refers to RBC < = 3.5 or RBC > = 6.0; Admission = '+' means the patient was admitted to the hospital; Admission = '-' means the patient was not admitted to the hospital;",
        "error_sql": "SELECT P.ID, P.SEX, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age, P.Admission \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'F' AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) >= 50 \nAND (L.RBC <= 3.5 OR L.RBC >= 6.0);",
        "compiler_hint": "near \";\": syntax error",
        "reflective_cot": "### Tip:\nAlways ensure that every opening parenthesis has a corresponding closing parenthesis. Additionally, check that your SQL statements are correctly structured and that you're not missing any syntax elements, like the closing parenthesis for your WHERE clause. Using proper formatting and indentation can significantly help in recognizing such issues.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50",
        "difficulty": "challenging"
    },
    {
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "hint": "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;",
        "error_sql": "SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age\nFROM Patient AS P\nINNER JOIN Laboratory AS L ON P.ID = L.ID\nWHERE L.HCT >= 52\nGROUP BY P.ID\nHAVING COUNT(L.ID) > 2;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying databases, ensure that your conditions for counting records are accurate and reflect the requirements of the task. Specifically, use subqueries to isolate counts that meet specific criteria before grouping and filtering results. This helps to avoid incorrect aggregations by filtering records at the right stage in the SQL query. Additionally, remember to double-check the logical relationships between your filtering conditions and grouping to ensure they meet all specified criteria.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "difficulty": "challenging"
    },
    {
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "hint": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;",
        "error_sql": "SELECT (SUM(L.PLT < 100) - SUM(L.PLT > 400)) AS Abnormal_PLT_Comparison \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.PLT <= 100 OR L.PLT >= 400;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen evaluating conditions in SQL, especially in aggregate functions like SUM, be careful with the boundaries of ranges. Ensure you are using the correct conditional logic (e.g., using `<=` or `>=` appropriately based on the context) and double-check your conditions to avoid miscounting. Always clarify the intended inclusivity or exclusivity of the thresholds in your conditions.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "difficulty": "challenging"
    },
    {
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "hint": "laboratory examinations take in 1984 refers to YEAR(Date) = '1984'; below 50 years old = SUBTRACT(year(current_timestamp), year(Birthday)) < 50; normal platelet level refers to PLT between 100 and 400; ",
        "error_sql": "SELECT P.ID \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE strftime('%Y', L.Date) = '1984' \nAND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 50 \nAND L.PLT BETWEEN 100 AND 400;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the year calculation for age and the comparison for filtering data are done using the same reference date, especially when dealing with timestamps. In your case, use the date of the laboratory examination (`L.Date`) to calculate age, rather than the current date, to accurately reflect the age at the time of the examination. Additionally, consider using explicit date comparisons for clarity, rather than relying solely on strftime functions, as this may lead to unexpected results.",
        "ground_truth_sql": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "difficulty": "challenging"
    },
    {
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "hint": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
        "error_sql": "SELECT (SUM(CASE WHEN P.SEX = 'F' AND L.PT >= 14 THEN 1 END) * 100.0 / NULLIF(SUM(CASE WHEN L.PT >= 14 THEN 1 END), 0)) AS female_abnormal_pt_percentage \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that the calculation for percentages uses the correct denominators and consider the overall count of relevant cases. In particular, make sure to count all relevant entries rather than exclusively those that match a specific condition. Always verify your aggregates to avoid excluding necessary data points.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "difficulty": "challenging"
    },
    {
        "question": "List all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal.",
        "hint": "first came to the hospital after year 1992 refers to year(`First Date`) > 1992; prothrombin time (PT) level that are normal refers to PT < 14;",
        "error_sql": "SELECT P.ID, P.SEX, P.Birthday \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.`First Date` > '1992-12-31' AND L.PT < 14;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the logic of comparison operations in your WHERE clause carefully. For conditions like checking dates or measurement levels, ensure you are using the correct comparison symbols. In this case, you needed to check for PT levels that are **less than 14** (normal) instead of greater than or equal to 14. Additionally, when dealing with date comparisons, consider using functions (like `STRFTIME()` for formatting) to ensure accuracy, especially with different date types.",
        "ground_truth_sql": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) > '1992' AND T2.PT < 14",
        "difficulty": "moderate"
    },
    {
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "hint": "examinations done after 1997/1/1 refers to `Examination Date` > '1997-01-01'; normal activated partial prothrom bin time refesr to APTT < 45;",
        "error_sql": "SELECT COUNT(E.ID) AS inactivated_partial_prothrom_bin_time_count \nFROM Examination AS E \nINNER JOIN Laboratory AS L ON E.ID = L.ID \nWHERE E.`Examination Date` > '1997-01-01' AND L.APTT < 45;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are correctly joining the relevant tables with appropriate conditions for dates and results. Verify that your query accurately reflects the logic of your requirements, such as counting the examinations that meet specific criteria, instead of mistakenly counting the wrong records or using the wrong columns for conditions. Double-check the conditions for inclusion (e.g., using `>=` or `<`) and ensure you're referencing the correct tables and fields in your query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "hint": "abnormal activated partial prothrom bin time refers to APTT > 45; does not have thrombosis refers to Thrombosis = 0; Only count ones without repetitive.",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS non_thrombosis_count \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.APTT > 45 AND P.ID NOT IN (SELECT ID FROM Examination WHERE Thrombosis = 1);",
        "compiler_hint": "no such column: E.APTT",
        "reflective_cot": "### Tip:\nAlways verify the available columns in each table before writing queries. If a column name is not present in the table, it can lead to errors like \"no such column.\" Additionally, ensure that you understand the relationships between tables and include all necessary joins to access the required data correctly.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "difficulty": "moderate"
    },
    {
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "hint": "male patients refers to Sex = 'M'; normal level of white blood cells refers to WBC > 3.5 and WBC <9.0; abnormal fibrinogen level refers to FG < = 150 or FG > = 450; Don't compute repetitive ones.",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' \nAND L.WBC > 3.5 AND L.WBC < 9.0 \nAND (L.FG <= 150 OR L.FG >= 450);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the order of your conditions in the WHERE clause for clarity. In complex queries, ensure that filters are logically grouped and unambiguous, focusing on the required selections first. This helps maintain the intended logic when identifying subsets of data, particularly with multiple conditions involving logical operators.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients born after 1980/1/1 have an abnormal fibrinogen level?",
        "hint": "born after 1980/1/1 refers to Birthday > '1980-01-01'; normal fibrinogen level refers to FG between 150 and 450; Should return the number of distinct patients.",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Birthday > '1980-01-01' AND (L.FG < 150 OR L.FG > 450);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the conditions in your WHERE clause are correctly defined to match the data requirements. In this case, the condition specified for fibrinogen levels should have been `L.FG <= 150 OR L.FG >= 450` instead of an incorrect range check (`L.FG < 150 OR L.FG > 450`). Double-checking logical conditions, especially when dealing with ranges, can help avoid similar mistakes in the future.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T1.Birthday > '1980-01-01'",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with an Ig G higher than normal?",
        "hint": "Ig G higher than normal refers to IGG >= 2000; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.IGG >= 2000;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways confirm if additional joins are required to incorporate all relevant conditions and tables based on your query needs. In this case, the `Examination` table was necessary to ensure all patient data was correctly aggregated. Double-check that all related entities and their relationships are accounted for before finalizing your query.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG >= 2000",
        "difficulty": "simple"
    },
    {
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "hint": "normal Ig G level refers to IGG > 900 and IGG < 2000; have symptoms refers to Symptoms IS NOT NULL;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.IGG > 900 AND L.IGG < 2000 AND EXISTS (SELECT 1 FROM Examination AS E WHERE E.ID = P.ID AND E.Symptoms IS NOT NULL);",
        "compiler_hint": "no such column: E.IGG",
        "reflective_cot": "### Tip:\nAlways verify the field names and which table they belong to before writing the SQL query. When dealing with multiple tables, ensure that reference columns are from the correct table and are properly joined, especially when using aliases. Additionally, double-check that all conditions are applying to the intended columns in the right tables to avoid misreference errors.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "hint": "normal Ig A level refers to IGA > 80 AND IGA < 500; came to the hospital after 1990/1/1 refers to YEAR(`First Date`) > = 1990;",
        "error_sql": "SELECT COUNT(P.ID) AS normal_iga_patients \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.IGA > 80 AND L.IGA < 500 AND strftime('%Y', P.`First Date`) >= '1990';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're using the correct data types and functions for comparing date values. Instead of using string functions like `strftime` for date comparisons, use date literals in the proper format (YYYY-MM-DD) to simplify the query and avoid potential type issues. Additionally, for range checks, use `BETWEEN` for clarity and accuracy.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "hint": "creatinine level is abnormal refers to CRE >= 1.5; aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 70; ",
        "error_sql": "SELECT COUNT(P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.CRE >= 1.5 AND (CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', P.Birthday) AS INTEGER)) < 70;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that any calculations or comparisons involving dates consider data types properly and use appropriate functions to handle distinct values, especially when aggregating results like counting or summing. In this case, using `DISTINCT` is crucial to avoid counting the same patient multiple times if they have multiple lab records. Additionally, confirm that the date calculations correctly account for the year difference without casting errors.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "difficulty": "challenging"
    },
    {
        "question": "How many patients with a normal RF don't have thrombosis?",
        "hint": "normal RF refers to RF < 20; don't have thrombosis refers to Thrombosis = '0';",
        "error_sql": "SELECT COUNT(P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE L.RF < 20 AND E.Thrombosis = 0;",
        "compiler_hint": "no such column: E.Thrombosis",
        "reflective_cot": "### Tip:\nWhen writing SQL queries, ensure that all the necessary tables and columns are correctly referenced and included in the JOIN conditions. Pay close attention to the aliases used for each table and make sure to reference them consistently throughout the query. Additionally, when checking for specific conditions, verify that the fields you are querying exist within the context of the tables being joined. Always double-check the relationships between tables and the specific fields you need to include in your WHERE clause.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
        "difficulty": "simple"
    },
    {
        "question": "Among the patients have blood clots in veins, how many of them have a normal level of complement 4?",
        "hint": "APS will result in Blood Clots in veins; normal level of complement 4 refers to C4 > 10; Should compute the number of different ones",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE E.Diagnosis = 'APS' AND L.C4 > 10;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the filtering criteria for your query are correctly applied to the appropriate tables, and verify that you are not inadvertently filtering out relevant records through JOIN conditions or WHERE clauses. Start by defining your filtering conditions for each table clearly before constructing your SQL query.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.C4 > 10 AND T1.Diagnosis = 'APS'",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "hint": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.RNP IN ('-', '+-') AND P.Admission = '+';",
        "compiler_hint": "no such column: E.RNP",
        "reflective_cot": "### Tip:\nAlways ensure that you're referencing the correct columns from the right tables. Double-check the schema for available columns and their respective tables before constructing your SQL queries. Additionally, consider using SQL aliases consistently to clarify which tables the columns belong to, thereby reducing confusion and potential errors.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "difficulty": "moderate"
    },
    {
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "hint": "youngest patient refers to MAX(Birthday); abnormal anti-ribonuclear protein level refers to RNP NOT IN('-', '+-'); date of birth refers to Birthday;",
        "error_sql": "SELECT P.Birthday \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE E.RNP NOT IN ('-', '+-') \nORDER BY P.Birthday DESC \nLIMIT 1;",
        "compiler_hint": "no such column: E.RNP",
        "reflective_cot": "### Tip:\nAlways verify the columns available in the tables you're querying. In the initial queries, attempting to reference the `RNP` column from the `Examination` table instead of the `Laboratory` table led to errors. Ensure to understand the schema fully and check for specific columns in the correct tables before writing SQL queries.",
        "ground_truth_sql": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "hint": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE E.`ANA Pattern` IN ('-', '+-') AND E.Thrombosis = 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to include all relevant tables and columns that directly address the question. In this case, consider the specific criteria for \"normal anti-SM\" by looking for the correct field in the appropriate table (`Laboratory`), and ensure that all necessary joins are correctly included to reflect these conditions in your query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "difficulty": "moderate"
    },
    {
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "hint": "examination done after 1997/1/1 refers to `Examination Date` >  1997-01-01; normal anti-scl70 refers to SC170 IN('negative','0');",
        "error_sql": "SELECT P.ID \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.Date > '1997-01-01' AND L.SC170 IN ('negative', '0');",
        "compiler_hint": "no such column: E.SC170",
        "reflective_cot": "### Tip:\nWhen querying across multiple tables, always ensure that you're referencing the correct columns for the relevant tables. It\u2019s crucial to verify that the column you are accessing exists in the table you are joining. Check the schema documentation carefully to avoid referencing non-existent columns, which can lead to errors such as \"no such column.\" Furthermore, be diligent about which table\u2019s columns you need based on the specific conditions of your query.",
        "ground_truth_sql": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients with a normal anti-SSA came to the hospital before 2000?",
        "hint": "normal anti-SSA refers to SSA IN('-','+-'); came to the hospital before 2000 refers to YEAR(`First Date`) < 2000; Should compute the number of distinct ones",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS normal_anti_SSA_patients \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.SSA IN ('-', '+-') AND strftime('%Y', P.`First Date`) < '2000';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, be cautious about the specific conditions and field references you use. Ensure that you are checking the correct field values and names against the appropriate criteria related to the data you want to filter. In particular, verify that you are considering the correct date field for conditions involving dates and are using the expected value notations (e.g., check the allowed values in the database rather than assuming the representations).",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '2000'",
        "difficulty": "moderate"
    },
    {
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "hint": "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nJOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.SSB IN ('-', '+-') AND P.Diagnosis = 'SLE';",
        "compiler_hint": "no such column: E.SSB",
        "reflective_cot": "### Tip:\nAlways verify that the columns you are querying exist in the tables you are joining. Use the schema to confirm which table each column belongs to, and ensure that logical conditions are framed correctly, especially when checking for multiple values (using `AND`, `OR`, etc.). Additionally, be cautious with logical operators in conditions; for instance, `WHERE L.SSB = 'negative' OR '0'` is incorrect and should explicitly compare `L.SSB` with '0' using `L.SSB = '0'`.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "hint": "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS distinct_patients_with_symptoms_count \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE L.SSB IN ('negative', '0') AND E.Symptoms IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen using SQL conditions with multiple values, ensure to compare the column against each value appropriately. The correct syntax should be structured as `column IN (value1, value2)` rather than using `column = value OR value`. Also, maintain proper parentheses and logical operators to avoid ambiguity.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "hint": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS male_normal_centromere_ssb_count \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.CENTROMEA IN ('-', '+-') AND L.SSB IN ('-', '+-');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the specific values that indicate \"normal\" levels for each test from the database schema or accompanying documentation. Additionally, ensure that you're using the right terms or conventions (like 'negative' or '0') instead of generic placeholders ('-' or '+-') where applicable. This helps avoid misinterpretation of data conditions in your SQL queries.",
        "ground_truth_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "difficulty": "moderate"
    },
    {
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "hint": "normal level of IGG refers to 900 < IGG < 2000; admitted to the hospital refers to Admission = '+';",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.IGG > 900 AND L.IGG < 2000 AND P.Admission = '+';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that the SQL logic aligns with the underlying database schema and ensure that column names and conditions are accurately implemented. Pay close attention to the logical conditions, such as comparison ranges, ensuring they reflect the requirements correctly. Additionally, test the queries with sample data to confirm their accuracy before finalizing the syntax.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of patient who has a abnormal level of glutamic oxaloacetic transaminase level, yet he or she is diagnosed with SLE?",
        "hint": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; percentage = MULTIPLY(DIVIDE(COUNT(ID WHERE GOT > = 60 AND Diagnosis = 'SLE'), COUNT(ID WHERE GOT > = 60)), 1.0);",
        "error_sql": "SELECT (COUNT(CASE WHEN L.GOT >= 60 AND P.Diagnosis = 'SLE' THEN P.ID END) * 1.0 / COUNT(CASE WHEN L.GOT >= 60 THEN P.ID END)) * 100 AS Percentage\nFROM Patient AS P\nJOIN Laboratory AS L ON P.ID = L.ID;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your conditions align with the desired criteria for both COUNT clauses. Instead of using `COUNT(CASE WHEN ... THEN P.ID END)` in both cases, consider using a simpler structure for clarity. In your counts, ensure that both numerator and denominator are counting valid entries from the same filtered dataset, as it helps prevent discrepancies in data retrieval. It\u2019s often helpful to create CTEs or subqueries to better organize complex conditions and aggregate functions.",
        "ground_truth_sql": "SELECT COUNT(CASE WHEN T1.Diagnosis LIKE '%SLE%' THEN T1.ID ELSE 0 END) / COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`GOT` >= 60",
        "difficulty": "moderate"
    },
    {
        "question": "How many male patients have their glutamic oxaloacetic transaminase in the normal range?",
        "hint": "male refers to Sex = 'M'; glutamic oxaloacetic transaminase in the normal range refers to GOT < 60;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.GOT < 60;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the filtering conditions in your SQL queries are structured correctly, especially the order of conditions. Logical grouping can change the result set, so verify the logic of joins and where clauses carefully before finalizing your query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "difficulty": "simple"
    },
    {
        "question": "Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?",
        "hint": "abnormal level of glutamic oxaloacetic transaminase refers to GOT > = 60; The larger the birthday value, the younger the person is, and vice versa;",
        "error_sql": "SELECT MIN(P.Birthday) \nFROM Patient AS P \nJOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.GOT >= 60;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your query logic aligns with the requirement of finding the correct data. When looking for the youngest patient, you should focus on retrieving the maximum date (i.e., the most recent birthday) instead of the minimum. To avoid similar mistakes in the future, take the time to clarify the requirements and think through the implications of functions like MIN and MAX in the context of what you're trying to achieve.",
        "ground_truth_sql": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60 ORDER BY T1.Birthday DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "hint": "normal glutamic pylvic transaminase level refers to GOT < 60; male refers to Sex = 'M';",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nJOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.SEX = 'M' AND L.GOT < 60;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query adheres to the correct syntax and logic flow. Specifically, when counting distinct values or filtering data, verify the sequence of conditions and make sure your join clauses are correctly structured to avoid missing relevant records. Testing with smaller datasets or using `LIMIT` can help catch logic errors before running larger queries.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "difficulty": "simple"
    },
    {
        "question": "For the patient with the highest lactate dehydrogenase in the normal range, when was his or her data first recorded?",
        "hint": "highest lactate dehydrogenase in the normal range refers to MAX(LDH < 500); when the data first recorded refers to MIN(First Date);",
        "error_sql": "SELECT MIN(P.`First Date`) \nFROM Laboratory AS L \nINNER JOIN Patient AS P ON L.ID = P.ID \nWHERE L.LDH = (SELECT MAX(LDH) FROM Laboratory WHERE LDH < 500);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen formulating SQL queries, always ensure that your inner queries correctly reflect the desired condition by selecting the appropriate fields and ensuring they align with the outer query's logic. In this case, instead of looking for an exact match on LDH, consider using a query that finds the maximum LDH value within the specified range and then filters the results accordingly. Additionally, pay attention to whether you need to apply any conditions that may inadvertently exclude valid results.",
        "ground_truth_sql": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 500 ORDER BY T2.LDH ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patient with an abnormal alkaliphophatase level, how many of them are admitted to the hospital?",
        "hint": "abnormal alkaliphophatase level refers to ALP > = 300; admitted to the hospital refers to Admission = '+';",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.ALP >= 300 AND P.Admission = '+';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that the conditions specified in your SQL query are aligned with the requirements of the problem. In particular, ensure that you're correctly referencing the right columns and tables, and consider any potential implications of using DISTINCT versus COUNT in your queries. Pay attention to SQL aggregation functions and confirm that your joins accurately reflect the data you're intending to analyze.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP >= 300 AND T1.Admission = '+'",
        "difficulty": "simple"
    },
    {
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "hint": "followed at the outpatient clinic refers to Admission = '-'; normal level of alkaliphophatase refers to ALP < 300;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Admission = '-' AND L.ALP < 300;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the order of conditions in the WHERE clause, as SQL evaluates them without regard to how they are written. Ensuring that you clearly articulate your conditions logically can help avoid misinterpretation. Additionally, testing smaller queries first can help isolate issues before integrating complex JOIN and COUNT functions.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients who are diagnosed with SJS, how many of them have a normal level of total protein?",
        "hint": "diagnosed with SJS refers to Diagnosis = 'SJS'; normal level of total protein refers to TP > 6.0 and TP < 8.5;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) AS normal_tp_count \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE P.Diagnosis = 'SJS' AND L.TP > 6.0 AND L.TP < 8.5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways validate your SQL query by ensuring that the join conditions and filtering criteria are correctly applied according to the logic required. It's also beneficial to run smaller, simpler queries to test individual components before combining them into a more complex query. Additionally, be mindful of any potential nuances related to the data types and constraints that may be in place for the fields involved in the query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients whose total bilirubin is over the normal range, how many of them have a peripheral pattern observed in the sheet of ANA examination?",
        "hint": "total bilirubin is over the normal range refers to `T-BIL` > = 2.0; peripheral pattern is observed in the sheet of ANA examination refers to that ANA Pattern contains 'P';",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.`T-BIL` >= 2.0 AND E.`ANA Pattern` LIKE '%P%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries that involve multiple tables, it's important to carefully verify the join conditions and the WHERE clause to ensure the correct logical relationships are established. In particular, ensure the appropriate columns are used in conditions, and be cautious about column names to avoid confusion. Always test each inner join step by step to confirm expected results before combining them into the final query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2 AND T3.`ANA Pattern` LIKE '%P%'",
        "difficulty": "challenging"
    },
    {
        "question": "For the patients whose total cholesterol is higher than normal, how many of them have a negative measure of degree of coagulation?",
        "hint": "total cholesterol is higher than normal refers to `T-CHO` > = 250; negative measure of degree of coagulation refers to KCT = '-' ;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.`T-CHO` >= 250 AND E.KCT = '-';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the logical conditions against the database schema and ensure that you're using the correct operators for comparisons. Additionally, double-check the join conditions to ensure that all necessary relationships between tables are properly established, especially when filtering records based on attributes from different tables.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` >= 250 AND T3.KCT = '-'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients whose total cholesterol is within the normal range, how many of them have a P pattern observed in the sheet of ANA examination?",
        "hint": "total cholesterol is within the normal range refers to `T-CHO` < 250; P pattern observed in the sheet of ANA examination refers to ANA Pattern = 'P';",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.`T-CHO` < 250 AND E.`ANA Pattern` = 'P';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries that involve multiple tables, always ensure that the logical relationships and conditions are accurately represented, especially in the `WHERE` clause. In cases where specific attributes from one table depend on the presence of values from another table, verify that the conditions appropriately reflect the required filtering criteria. Additionally, be cautious about the sequence of joins and ensure you use the correct alias names consistently throughout the query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.`ANA Pattern` = 'P' AND T2.`T-CHO` < 250",
        "difficulty": "moderate"
    },
    {
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "hint": "normal level of triglyceride refers to TG < 200; have other symptoms refers to Symptoms is not null;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE L.TG < 200 AND E.Symptoms IS NOT NULL;",
        "compiler_hint": "no such column: L.Symptoms",
        "reflective_cot": "### Tip:\nAlways double-check the available columns in the tables you are working with, as well as the relationships between them. If a column you're trying to access doesn't exist in the table you've joined, you'll receive errors. Keep track of which tables contain which data and think carefully about the logic of your joins to ensure you're pulling from the correct sources.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "hint": "disease name referse to Diagnosis; highest level of triglyceride within the normal range refers to MAX(TG < 200);",
        "error_sql": "SELECT P.Diagnosis \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.TG < 200 \nORDER BY L.TG DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you are using the correct tables and their relationships as outlined in the schema when formulating your queries. Double-check that you\u2019re selecting from the appropriate tables that contain the relevant fields and information. Additionally, pay attention to the context of the question, such as whether it pertains to a patient\u2019s examination or laboratory results, to avoid missing key data or connections between entities.",
        "ground_truth_sql": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "hint": "normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+' ;",
        "error_sql": "SELECT COUNT(DISTINCT P.ID) \nFROM Patient AS P \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nINNER JOIN Examination AS E ON P.ID = E.ID \nWHERE L.CPK < 250 AND (E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the join conditions and table references are correctly aligned with the primary and foreign keys. Pay attention to SQL syntax and structure, particularly when using aliases, to avoid ambiguity and ensure clarity in the query's execution. Additionally, validate that all column names and data types are correctly matched according to the schema before running the query.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "difficulty": "challenging"
    },
    {
        "question": "Among the patients who have a normal platelet level, how many of them have other symptoms observed?",
        "hint": "normal platelet level refers to PLT > 100 and PLT < 400; have other symptoms refers to Diagnosis is not null;",
        "error_sql": "SELECT COUNT(P.ID) \nFROM Patient AS P \nINNER JOIN Examination AS E ON P.ID = E.ID \nINNER JOIN Laboratory AS L ON P.ID = L.ID \nWHERE L.PLT > 100 AND L.PLT < 400 AND E.Diagnosis IS NOT NULL;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are referencing the correct columns from the appropriate tables when formulating your SQL queries. In this case, you needed to check for the `Diagnosis` column from the `Patient` table to determine if the patient has symptoms, rather than using the `Symptoms` column from the `Examination` table. Double-checking table structure and relationships can help avoid such mistakes.",
        "ground_truth_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 100 AND T2.PLT < 400 AND T1.Diagnosis IS NOT NULL",
        "difficulty": "moderate"
    },
    {
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "hint": "",
        "error_sql": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'Engineering';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you're using the exact names of tables and columns as defined in the database schema, including any specific phrasing or capitalization. In this case, \"College of Engineering\" needed to match the schema description for the college accurately to avoid discrepancies in the query results. Double-check for typos or variations in naming conventions.",
        "ground_truth_sql": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "hint": "full name refers to first_name, last_name;",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nWHERE link_to_major IN (SELECT major_id FROM major WHERE department = 'Art and Design');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the exact wording and criteria specified in the question, especially when filtering by categories like departments. Pay attention to the full names of departments or other entities, as well as the need for proper joins when dealing with related tables. In this case, using an INNER JOIN directly connects the necessary tables and allows for accurate filtering.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "difficulty": "simple"
    },
    {
        "question": "Which college is the vice president of the Student_Club from?",
        "hint": "Vice President is a position of the Student Club",
        "error_sql": "SELECT m.link_to_major \nFROM member m \nWHERE m.position = 'Vice President';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are selecting the correct columns from joined tables and using `LIKE` for partial matches when necessary. Additionally, verify that your join conditions correctly relate the tables based on their foreign key relationships.",
        "ground_truth_sql": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "difficulty": "simple"
    },
    {
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "hint": "meetings events refers to type = 'Meeting'; attended by more than 10 members refers to COUNT(event_id) > 10",
        "error_sql": "SELECT COUNT(e.event_id) \nFROM event e \nJOIN attendance a ON e.event_id = a.link_to_event \nGROUP BY e.event_id \nHAVING COUNT(a.link_to_member) > 10 AND e.type = 'Meeting';",
        "compiler_hint": null,
        "reflective_cot": "### Tip: \nWhen constructing SQL queries, it's important to pay attention to the order of operations, especially with `HAVING` and `WHERE` clauses. Use the `WHERE` clause to filter records before any grouping occurs, and reserve `HAVING` for conditions on aggregated results. Additionally, make sure that your logical conditions are structured properly to ensure the intended filtering happens at the correct stage in the query execution.",
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "hint": "name of events refers to event_name; attendance of over 20 students COUNT(event_id) > 20.",
        "error_sql": "SELECT e.event_name \nFROM attendance a \nJOIN event e ON a.link_to_event = e.event_id \nGROUP BY e.event_name \nHAVING COUNT(a.link_to_event) > 20 AND e.type != 'fundraiser';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering a grouped dataset in SQL, ensure that your filtering conditions are set correctly in the `HAVING` clause and that any specific exclusions are handled through a separate query or an appropriate `WHERE` clause. Specifically, be cautious when applying conditions directly alongside aggregate functions, as this can lead to incorrect results.",
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
        "difficulty": "moderate"
    },
    {
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "hint": "full name of members refers to first_name, last_name; 'Laugh Out Loud' is an event name;",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name \nFROM attendance a \nJOIN event e ON a.link_to_event = e.event_id \nJOIN member m ON a.link_to_member = m.member_id \nWHERE e.event_name = 'Laugh Out Loud';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your join conditions use the correct aliases for clarity. Consistency in naming conventions helps avoid confusion, especially when referencing columns from different tables. Always double-check that the column names and their associated tables are used accurately in the join statements.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "difficulty": "moderate"
    },
    {
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "hint": "full name of member refers to first_name, last_name",
        "error_sql": "SELECT CONCAT(m.first_name, ' ', m.last_name) AS full_name \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.state = 'Illinois';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to validate your JOIN syntax and table aliases, as well as the specific columns being selected. It's helpful to either start with simpler queries to ensure the join conditions are correct before adding complexity, and remember to refer to the table aliases in both the SELECT and the WHERE clauses accurately to avoid confusion.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
        "difficulty": "simple"
    },
    {
        "question": "What department offers the major that Pierce and Guidi took?",
        "hint": "",
        "error_sql": "SELECT J.department FROM major AS J INNER JOIN member AS M ON M.link_to_major = J.major_id WHERE M.first_name = 'Pierce' AND M.last_name = 'Guidi'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are correctly identifying and retrieving the required data for all individuals involved in a query by focusing on their relationships and using appropriate conditions. Instead of assuming pairing members by their first and last names, ensure to query based on unique identifiers like member IDs or combine conditions correctly without unnecessary constraints.",
        "ground_truth_sql": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
        "difficulty": "simple"
    },
    {
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "hint": "event_name = 'October Meeting' where event_date = '2019-10-08'; approved = True means expenses was approved; approved = False means expenses was not approved",
        "error_sql": "SELECT e.event_name, e.event_date, e2.approved \nFROM event e \nJOIN budget b ON e.event_id = b.link_to_event \nJOIN expense e2 ON b.budget_id = e2.link_to_budget \nWHERE e.event_name = 'October Meeting' AND e.event_date = '2019-10-08';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering results in SQL queries, ensure that you are using the correct data type and format for comparisons. In the case of boolean fields like \"approved,\" confirm whether the values are stored as strings ('True', 'False') or as actual boolean values. Avoid using fixed string comparisons if the data might not match exactly, and be aware of case sensitivity in your comparisons. Always check the database schema to confirm data types before applying filters.",
        "ground_truth_sql": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "difficulty": "moderate"
    },
    {
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "hint": "'Poster' is an event description; on 2019/9/14 refers to event_date = '2019-09-04'",
        "error_sql": "SELECT e.event_id, e.event_name, ex.cost \nFROM event e \nJOIN expense ex ON e.event_id = ex.link_to_budget \nWHERE ex.expense_description = 'Posters' AND e.event_date = '2019-09-04';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways double-check the relationships and keys used in your JOIN statements. Ensure that you're joining on the correct foreign keys relevant to your query's context. In this case, recognizing that the `expense` table should directly relate to its description and date, rather than needing to go through the `budget` and `event` tables, could prevent unnecessary complications and errors. Simplifying your approach often leads to more accurate results.",
        "ground_truth_sql": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "difficulty": "simple"
    },
    {
        "question": "State the major name for the Vice President of the club.",
        "hint": "'Vice President' is a position of Student Club",
        "error_sql": "SELECT m.first_name, m.last_name, maj.major_name \nFROM member m \nJOIN major maj ON m.link_to_major = maj.major_id \nWHERE m.position = 'Vice President';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the SQL query's structure aligns with the intended output. In this case, since only the major name was needed, using a `SELECT` statement that specifies the exact columns required instead of including additional columns (like `first_name` and `last_name`) can help avoid confusion about the output. Additionally, consider the academic context and scope of the intended query to prevent extraneous details.",
        "ground_truth_sql": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "difficulty": "simple"
    },
    {
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "hint": "full name refers to first_name, last_name; first paid dues refers to MIN(received_date) where source = 'Dues'",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nWHERE member_id = (SELECT link_to_member \n                   FROM income \n                   WHERE source = 'Dues' \n                   ORDER BY date_received \n                   LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to join related tables when querying for attributes that are not present in the main table being queried. In this case, to retrieve member details based on income data, an INNER JOIN between the `member` and `income` tables is necessary to accurately correlate members with their dues payments.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "How many cities are there in Orange County, Virginia?",
        "hint": "Orange County is the county name, Virginia is the state name",
        "error_sql": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange' AND state = 'VA'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the exact spelling and format of identifiers such as county and state names in your database. Use a query to sample the data for possible values before formulating your queries to ensure you are referencing them correctly.",
        "ground_truth_sql": "SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'",
        "difficulty": "simple"
    },
    {
        "question": "What are the expenses of the budget with the lowest remaining?",
        "hint": "expense of budget refers to expense_description; lowest remaining refers to MIN(remaining)",
        "error_sql": "SELECT e.expense_description\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nWHERE b.remaining = (SELECT MIN(remaining) FROM budget);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that when querying for related data, you're not only filtering based on the minimum value but also selecting all relevant records. Using `LIMIT` with `ORDER BY` can help retrieve the right expense associated with the lowest remaining budget, instead of just checking for equality with the minimum value which may not always match exactly.",
        "ground_truth_sql": "SELECT T2.expense_description FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "List all the members who attended the event \"October Meeting\".",
        "hint": "'October Meeting' is an event name;",
        "error_sql": "SELECT m.first_name, m.last_name \nFROM member m \nJOIN attendance a ON m.member_id = a.link_to_member \nJOIN event e ON a.link_to_event = e.event_id \nWHERE e.event_name = 'October Meeting';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the JOIN conditions use the correct column names as defined in the schema. Double-check foreign key references and ensure that they match the corresponding primary keys in related tables. This prevents mismatches and ensures the resulting dataset accurately reflects the relationships defined in the database.",
        "ground_truth_sql": "SELECT DISTINCT T3.member_id FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'October Meeting'",
        "difficulty": "simple"
    },
    {
        "question": "List all the expenses incurred by the vice president.",
        "hint": "expense refers to expense_description; 'Vice President' is a position of the Student Club",
        "error_sql": "SELECT E.expense_description \nFROM expense AS E \nINNER JOIN member AS M ON E.link_to_member = M.member_id \nWHERE M.position = 'Vice President';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, always review the structure of your tables and the relationships between them. Ensure that you're including all necessary columns in the SELECT statement, especially when using multiple tables. In cases where you require specific identifying information (like `expense_id` along with `expense_description`), explicitly include all relevant columns in your final output to avoid omitting crucial details.",
        "ground_truth_sql": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "difficulty": "simple"
    },
    {
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "hint": "list all members means to list all the full name; full name refers to first_name, last_name;",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nWHERE link_to_major IN (SELECT major_id FROM major WHERE department = 'School of Applied Sciences, Technology and Education');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to join related tables when querying data that relies on relationships between them. In this case, the initial query did not properly join the `member` and `major` tables, missing the necessary connection to fetch members from a specific department. Utilize `INNER JOIN` to clearly define the relationship, ensuring all relevant fields from interconnected tables are included in the selection criteria.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "difficulty": "moderate"
    },
    {
        "question": "List the name of students that have attended more than 7 events.",
        "hint": "name of students means the full name; full name refers to first_name, last_name; attended more than 7 events refers to COUNT(link_to_event) > 7",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM attendance a \nJOIN member m ON a.link_to_member = m.member_id \nGROUP BY m.member_id \nHAVING COUNT(a.link_to_event) > 7;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you include all necessary columns in the `GROUP BY` clause that you are selecting with aggregate functions. In cases where you want to retrieve specific fields (like names), all non-aggregated fields in the `SELECT` statement must also be included in the `GROUP BY`. Additionally, consider using table aliases to enhance clarity and consistency in your SQL queries.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "difficulty": "moderate"
    },
    {
        "question": "State the name of students from Georgetown, South Carolina.",
        "hint": "name of students means the full name; full name refers to first_name, last_name; Georgetown is a city; South Carolina is a state",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name \nFROM member m \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE z.city = 'Georgetown' AND z.state = 'South Carolina';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the structure and relationships of the tables in your database. Specifically, verify that you are using the correct join types and that your table references match the expected schema. Also, consider using aliases to improve clarity, and ensure your column selections align with your intended output formatting.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'",
        "difficulty": "simple"
    },
    {
        "question": "Which student was able to generate income more than $40?",
        "hint": "name of students means the full name; full name refers to first_name, last_name; generate income more than $50 refers to income.amount > 40",
        "error_sql": "SELECT CONCAT(T2.first_name, ' ', T2.last_name) AS full_name \nFROM income AS T1 \nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id \nWHERE T1.amount > 40;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are using the correct table aliases for the columns you are selecting. In your first SQL query, you mistakenly attempted to retrieve `first_name` and `last_name` from the `income` table (aliased as T1) instead of the `member` table (aliased as T2). It's crucial to double-check the source of the columns in the SELECT clause to match the corresponding table in the JOIN condition.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40",
        "difficulty": "simple"
    },
    {
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "hint": "name of students means the full name; full name refers to first_name, last_name;'Yearly Kickoff' is an event name;",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nJOIN event e ON a.link_to_event = e.event_id\nJOIN budget b ON e.event_id = b.link_to_event\nWHERE e.event_name = 'Yearly Kickoff';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are correctly linking all necessary tables and accounting for all relationships in the database schema. In your case, you needed to include the `expense` table to find members who are specifically responsible for managing the budget, as expenses are tied to members through the budget. Double-check the schema and consider the logical connections between tables to avoid missing key relationships when constructing your queries.",
        "ground_truth_sql": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "difficulty": "moderate"
    },
    {
        "question": "Which students manage to generate the highest income. State his/her full name along with the income source.",
        "hint": "name of students means the full name; full name refers to first_name, last_name; generate the highest income refers to MAX(income.amount);",
        "error_sql": "SELECT T2.first_name || ' ' || T2.last_name AS full_name, T1.source FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.amount = (SELECT MAX(amount) FROM income)",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating aggregates like maximum income, ensure you are using a grouping method correctly. Instead of checking for a single value match, use a `GROUP BY` clause to aggregate data by the desired fields and then order the results based on the aggregate values to identify the top entries.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T2.source ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which event has the lowest cost?",
        "hint": "event refers to event_name; lowest cost means MIN(cost)",
        "error_sql": "SELECT e.event_name \nFROM expense ex \nJOIN budget b ON ex.link_to_budget = b.budget_id \nJOIN event e ON b.link_to_event = e.event_id \nWHERE ex.cost = (SELECT MIN(cost) FROM expense);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries that involve aggregating functions like MIN, it's important to ensure that the query accurately represents the relationship between the tables. Instead of trying to match against a scalar value from an inner query, consider using an ORDER BY clause combined with LIMIT to directly retrieve the row with the desired minimum value. This approach is typically more efficient and straightforward.",
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the ratio between students majored in finance and physics?",
        "hint": "DIVDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN j.major_name = 'Finance' THEN m.member_id END) AS REAL) / NULLIF(COUNT(CASE WHEN j.major_name = 'Physics' THEN m.member_id END), 0) AS ratio \nFROM member m \nJOIN major j ON m.link_to_major = j.major_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:                 \nAlways ensure that your calculations are aligned with the logic of the query. In the context of calculating ratios, it's crucial to use `SUM` instead of `COUNT`, as `SUM` allows you to count the instances of specific conditions directly (e.g., in the Ground Truth SQL). Additionally, when dividing, make sure to handle zero values appropriately to avoid division errors. Familiarizing yourself with aggregation functions and their behavior can help prevent such mistakes.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
        "difficulty": "simple"
    },
    {
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "hint": "full name refers to first_name, last_name; 'Secretary' is a position of Student Club",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, m.email \nFROM member m \nWHERE m.position = 'Secretary';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the SQL query returns all necessary columns directly specified in the `SELECT` statement. If you are combining columns or transforming them (like concatenating first and last names), make sure that you check the output requirements carefully. In cases where output structure is critical, differentiate between direct column selection and derived columns to avoid confusion.",
        "ground_truth_sql": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "difficulty": "simple"
    },
    {
        "question": "Did Maya Mclean attend the 'Women's Soccer' event?",
        "hint": "Maya Mclean is the full name; full name refers to first_name, last_name; 'Women's Soccer' is an event_name",
        "error_sql": "SELECT COUNT(*) > 0 \nFROM attendance a \nJOIN event e ON a.link_to_event = e.event_id \nJOIN member m ON a.link_to_member = m.member_id \nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean' AND e.event_name = \"Women's Soccer\";",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways use single quotes for string literals in SQL, as double quotes are generally reserved for identifiers such as table and column names. This common error can lead to syntax problems and unexpected results.",
        "ground_truth_sql": "SELECT CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END AS result FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.first_name = 'Maya' AND T1.last_name = 'Mclean'",
        "difficulty": "moderate"
    },
    {
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "hint": "total value refers to SUM(cost); 'October Meeting' is an event name;",
        "error_sql": "SELECT SUM(e.cost) \nFROM expense e \nJOIN budget b ON e.link_to_budget = b.budget_id \nJOIN event ev ON b.link_to_event = ev.event_id \nWHERE ev.event_name = 'October Meeting' AND e.approved = 'Yes';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you are selecting the appropriate columns that align with your query's main objective, especially when dealing with aggregates. In this case, if you want to know the total value of approved expenses grouped by type, you need to include the correct column (`type`) from the desired table (in this case, the `zip_code` or related tables) before performing the aggregation. Additionally, carefully structure your joins to ensure you are correctly linking relevant tables to retrieve all necessary information.",
        "ground_truth_sql": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "difficulty": "moderate"
    },
    {
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "hint": "MAX(amount) where category = 'Food'",
        "error_sql": "SELECT MAX(amount) \nFROM budget \nWHERE category = 'Food';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for a specific subset of data (like the highest budgeted amount), ensure that your `WHERE` clause accurately targets that subset and that you're referencing the correct column in the subquery to compare against. In this case, using a specific condition related to the category directly in the subquery would avoid confusion. Always validate the logic of your queries by considering what data you're selecting and from which table.",
        "ground_truth_sql": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "difficulty": "simple"
    },
    {
        "question": "Among the budgets for Advertising, list out top three which have the most budgeted amount?",
        "hint": "MAX(amount) where category = 'Advertisement'",
        "error_sql": "SELECT e.event_name, b.amount \nFROM budget b \nJOIN event e ON b.link_to_event = e.event_id \nWHERE b.category = 'Advertisement' \nORDER BY b.amount DESC \nLIMIT 3;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways review the requirements of the query carefully. In this case, the original query intended to retrieve the top three budgets specifically for Advertising, but it incorrectly focused on the event name instead of prioritizing the budget ID itself. After identifying the specific data needed, ensure that the selected columns align with the query's goal. When dealing with totals or summaries, it's vital to understand if you're required to aggregate or merely list specific identifiers. Consider double-checking the desired outputs against the tables and their relationships for clarity.",
        "ground_truth_sql": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "difficulty": "simple"
    },
    {
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "hint": "full name refers to first_name, last name",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_cost \nFROM member m \nLEFT JOIN expense e ON m.member_id = e.link_to_member \nWHERE m.member_id = 'rec4BLdZHS2Blfp4v' \nGROUP BY m.member_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you are using the correct aggregation function and grouping columns based strictly on the fields that are being selected in the final output. When you aggregate data, all non-aggregated fields in the SELECT statement must be included in the GROUP BY clause. Additionally, consider using INNER JOIN instead of LEFT JOIN if you need to ensure that the results only include members who have incurred expenses. This avoids potential NULL values in the results.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "difficulty": "simple"
    },
    {
        "question": "Mention the category of events which were held at MU 215.",
        "hint": "held at MU 215 refers to location = 'MU 215'",
        "error_sql": "SELECT DISTINCT type FROM event WHERE location = 'MU 215';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the relationships between tables in your database schema. When querying for specific data, consider using appropriate JOINs to access related information across different tables, especially when dealing with foreign keys and specific conditions.",
        "ground_truth_sql": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "difficulty": "simple"
    },
    {
        "question": "Calculate the percentage of members who are major Business in the list?",
        "hint": "DIVIDE(SUM(position = 'Member' and major_name = 'Business'), COUNT(member_id)) * 100",
        "error_sql": "SELECT (SUM(CASE WHEN T1.position = 'Member' AND T2.major_name = 'Business' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.member_id)) AS business_percentage\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:  \nWhen calculating conditional aggregates, ensure that you're correctly applying both the condition and the counting logic. It's important to keep in mind the context of filters; for instance, consider filtering on conditions in the `WHERE` clause rather than in the aggregate functions. This helps maintain clarity and ensures that all counts are accurate before applying any conditional logic.",
        "ground_truth_sql": "SELECT CAST(SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member'",
        "difficulty": "moderate"
    },
    {
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "hint": "budget category refers to category; events located at refers to location; type = 'Guest Speaker'; 0 budget spent refers to spent = 0; ",
        "error_sql": "SELECT b.category \nFROM budget b \nJOIN event e ON b.link_to_event = e.event_id \nWHERE e.location = 'MU 215' AND e.type = 'Guest Speaker' AND b.spent = 0;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen writing SQL queries, it's crucial to verify the join conditions and the selected columns. Always ensure that you include all necessary fields in the SELECT clause that you might want to analyze or filter on. Additionally, consider using `DISTINCT` if your query might return duplicate results. Double-check the aliases you use for tables and the fields you're filtering on to ensure clarity and correctness.",
        "ground_truth_sql": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "difficulty": "moderate"
    },
    {
        "question": "List the city and state of members enrolled under electrical and computer engineering department.",
        "hint": "'Electrical and Computer Engineering Department' is the department; members enrolled refers to position = 'Member'",
        "error_sql": "SELECT z.city, z.state \nFROM member m \nJOIN major j ON m.link_to_major = j.major_id \nJOIN zip_code z ON m.zip = z.zip_code \nWHERE j.department = 'Electrical and Computer Engineering' AND m.position = 'Member';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you verify the exact values being used in your SQL queries, especially for string comparisons. Be mindful of exact phrasing, including spaces and punctuations, for conditions like department names. Use careful review or testing of smaller queries to confirm correctness before combining them into more complex queries.",
        "ground_truth_sql": "SELECT city, state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE department = 'Electrical and Computer Engineering Department' AND position = 'Member'",
        "difficulty": "moderate"
    },
    {
        "question": "Which countries have zip codes with post office boxes?",
        "hint": "zip codes that have post office boxes refers to type = 'PO Box'",
        "error_sql": "SELECT city FROM zip_code WHERE type = 'PO Box'",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways consider the context of the query and the requirements specified. In this case, analyzing the geographical hierarchy\u2014like countries and counties\u2014was essential. When filtering data, ensure you select fields that accurately represent the desired outcome. Using DISTINCT can help eliminate duplicates, but be mindful of which columns are relevant for that uniqueness. Always verify the data model and look for additional constraints, such as NULL values, that could affect results.",
        "ground_truth_sql": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL",
        "difficulty": "simple"
    },
    {
        "question": "What are the zip codes that have post office boxes in the country of the country of San Juan Municipio whose state is Puerto Rico?",
        "hint": "zip codes that have post office boxes refers to type = 'PO Box'",
        "error_sql": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND city = 'San Juan Municipio' AND state = 'Puerto Rico';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the specific attributes required for filtering data in your queries. Pay close attention to the information provided in the schema, especially regarding how geographical locations are structured (e.g., distinguishing between city and county). When in doubt, consult the schema or documentation to clarify which column corresponds to the data you intend to query.",
        "ground_truth_sql": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'",
        "difficulty": "simple"
    },
    {
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "hint": "approved from 1/10/2019 to 11/19/2019 refers to approved = 'true' and expense_date BETWEEN '2019-01-10' and '2019-11-19'",
        "error_sql": "SELECT DISTINCT m.member_id, m.first_name, m.last_name, a.link_to_event \nFROM expense e \nJOIN member m ON e.link_to_member = m.member_id \nJOIN attendance a ON a.link_to_member = m.member_id \nWHERE e.approved = 'true' AND e.expense_date BETWEEN '2019-01-10' AND '2019-11-19';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the date format in your SQL queries matches the stored format in the database. Additionally, check if there are any missing clauses or conditions that may affect the results, such as the correct referencing of date functions or expressions when the date is stored as a string. Consider using proper date functions to avoid format discrepancies.",
        "ground_truth_sql": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "difficulty": "challenging"
    },
    {
        "question": "How many members have education major in the College of Education & Human Services?",
        "hint": "'education' is the major name; 'Member' is a position of club;",
        "error_sql": "SELECT COUNT(DISTINCT m.member_id) \nFROM member m \nJOIN major j ON m.link_to_major = j.major_id \nWHERE j.major_name = 'education' AND m.position = 'Member' AND j.college = 'College of Education & Human Services';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that column names and string comparisons in your SQL queries are correctly typed and precise, especially with respect to case sensitivity and exact matching. Additionally, consider the use of `LIKE` with wildcards judiciously to ensure you're capturing variations (e.g., lowercase vs. uppercase) without unintentionally expanding your search criteria too broadly. When you encounter an error, review the logic carefully and test with a narrower set of data first to isolate the issue.",
        "ground_truth_sql": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "difficulty": "moderate"
    },
    {
        "question": "Find the full name of members whose t-shirt size is extra large.",
        "hint": "full name refers to first_name, last_name; t_shirt_size = 'X-Large'",
        "error_sql": "SELECT first_name || ' ' || last_name AS full_name \nFROM member \nWHERE t_shirt_size = 'X-Large';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways review the criteria specified in the question carefully. Ensure that you're fully utilizing any hints provided (like specific values) and that you're correctly formatting any output as required. In this instance, the correct output should have included just the `first_name` and `last_name` columns instead of combining them.",
        "ground_truth_sql": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
        "difficulty": "simple"
    },
    {
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "hint": "name of event refers to event_name; date of event refers to event_date; expenses for pizza refers to expense_description = 'Pizza' where cost > 50 and cost < 100",
        "error_sql": "SELECT e.event_name, e.event_date \nFROM event e \nJOIN expense ex ON e.event_id = ex.link_to_budget \nWHERE ex.expense_description = 'Pizza' AND ex.cost > 50 AND ex.cost < 100;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the join conditions correctly match the foreign keys to their corresponding primary keys. Double-check the relationships between the tables and make sure to reference the correct columns when forming join conditions to avoid linking tables incorrectly.",
        "ground_truth_sql": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "difficulty": "challenging"
    },
    {
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "hint": "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, maj.major_name \nFROM expense e \nJOIN member m ON e.link_to_member = m.member_id \nJOIN major maj ON m.link_to_major = maj.major_id \nWHERE e.cost > 100;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, especially with multiple tables, ensure to use `DISTINCT` to eliminate potential duplicate rows in the result set when retrieving information from joins. Always carefully analyze the expected outcome, especially when joining on primary and foreign keys, to ensure that the joins are set up correctly to prevent unintended duplications.",
        "ground_truth_sql": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "difficulty": "moderate"
    },
    {
        "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
        "hint": "more than fifty incomes refers to income > 40",
        "error_sql": "SELECT z.city, z.county \nFROM income i \nJOIN event e ON i.link_to_member = e.event_id \nJOIN zip_code z ON e.location = z.short_state \nGROUP BY e.event_id \nHAVING COUNT(i.income_id) > 40;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you join the correct tables based on their relations and verify that you are aggregating the correct fields for your desired results. Double-check the keys used in your JOIN statements to maintain the integrity of the data relationships, and ensure that your GROUP BY and HAVING clauses align with the intended filtering criteria.",
        "ground_truth_sql": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
        "difficulty": "simple"
    },
    {
        "question": "List the name of events with less than average parking cost.",
        "hint": "name of events refers to event_name; less than average parking cost refers to cost < DIVIDE(SUM(cost), COUNT(event_id)) where category = 'Parking'",
        "error_sql": "SELECT e.event_name \nFROM event e \nJOIN budget b ON e.event_id = b.link_to_event \nWHERE b.budget_id IN (SELECT eb.link_to_budget \n                       FROM expense eb \n                       WHERE eb.expense_description = 'Parking') \nGROUP BY e.event_name \nHAVING AVG((SELECT cost FROM expense WHERE link_to_budget = b.budget_id AND expense_description = 'Parking')) < \n           (SELECT AVG(cost) \n            FROM expense \n            WHERE expense_description = 'Parking');",
        "compiler_hint": "no such column: eb.cost",
        "reflective_cot": "### Tip:\nWhen constructing SQL queries involving multiple tables and subqueries, ensure that you correctly reference columns from the intended tables. Use explicit joins to connect all relevant tables and clearly specify conditions in your `WHERE` clause. Additionally, when using aggregate functions like `AVG()`, make sure they are calculated within the correct context of the query and consider how the grouping affects the aggregation. Always validate that the intended columns exist in the tables you've referenced.",
        "ground_truth_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "difficulty": "moderate"
    },
    {
        "question": "What is the percentage of the cost for the meeting events?",
        "hint": "meeting events refers to type = 'Meeting'; percentage = DIVIDE( SUM(cost), COUNT(event_id)) * 100",
        "error_sql": "SELECT (SUM(e.cost) / (SELECT COUNT(ev.event_id) FROM event ev WHERE ev.type = 'Meeting') * 100) AS percentage\nFROM expense e \nJOIN budget b ON e.link_to_budget = b.budget_id \nJOIN event ev ON b.link_to_event = ev.event_id \nWHERE ev.type = 'Meeting';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating aggregated values, ensure that you're using a consistent and correct denominator. In your initial queries, you were trying to calculate the percentage based on the count of event IDs rather than the total cost, which led to incorrect results. Always verify that your numerator corresponds accurately with the denominator to maintain the meaning of the metric you are trying to calculate. Using conditional aggregation with `SUM` and `CASE` can also simplify these calculations and ensure you're aggregating the right values.",
        "ground_truth_sql": "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "difficulty": "moderate"
    },
    {
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "hint": "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)",
        "error_sql": "SELECT MAX(cost) \nFROM expense \nWHERE expense_description = 'Water, chips, cookies';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nMake sure to understand the relationship between tables and the required outputs before writing your SQL queries. Incorporate joins when necessary to pull related data from different tables, and always verify if you need to return additional identifiers (like budget IDs) along with aggregated values.",
        "ground_truth_sql": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "List the full name of the top five members who spend the most money in the descending order of spending.",
        "hint": "full name refers to first_name, last_name; spend the most money refers to MAX(expense.cost)",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name \nFROM expense e \nJOIN member m ON e.link_to_member = m.member_id \nGROUP BY m.member_id \nORDER BY SUM(e.cost) DESC \nLIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you're aggregating expenditure correctly by considering the relationships between tables. In this case, expenses are linked to budgets, which track the total spending, rather than summing costs directly from the expense table. Reflecting on the database schema can help clarify relationships and guide the correct SQL joins needed for accurate results.",
        "ground_truth_sql": "SELECT T3.first_name, T3.last_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id ORDER BY T2.spent DESC LIMIT 5",
        "difficulty": "moderate"
    },
    {
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "hint": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone \nFROM member m \nJOIN expense e ON m.member_id = e.link_to_member \nGROUP BY e.expense_description \nHAVING AVG(e.cost) < MAX(e.cost);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen dealing with aggregate functions like AVG(), ensure your subquery calculates the average in the context you want it. Additionally, make sure to join only necessary tables and apply filters appropriately within the WHERE clause before aggregation to maintain clarity in your logic. Always verify if you need to correlate subqueries with outer queries correctly to avoid redundancy and incorrect results.",
        "ground_truth_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "difficulty": "challenging"
    },
    {
        "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
        "hint": "SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )",
        "error_sql": "SELECT \n    (SUM(CASE WHEN z.state = 'New Jersey' THEN 1 ELSE 0 END) * 100.0 / COUNT(CASE WHEN m.position = 'Member' THEN 1 END)) - \n    (SUM(CASE WHEN z.state = 'Vermont' THEN 1 ELSE 0 END) * 100.0 / COUNT(CASE WHEN m.position = 'Member' THEN 1 END)) AS percentage_difference\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE m.position = 'Member';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you clearly understand the differences in numerator and denominator when calculating percentages, and be cautious of using functions like COUNT and SUM in your calculations. Using `NULLIF` to prevent division by zero is helpful, but ensure you are correctly representing the numerator contextually. Consider whether you need the total `COUNT` for all members or just those matching specific criteria in your calculations.",
        "ground_truth_sql": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
        "difficulty": "moderate"
    },
    {
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "hint": "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_cost \nFROM member m \nJOIN expense e ON m.member_id = e.link_to_member \nWHERE e.expense_description IN ('Water', 'Veggie tray', 'Supplies') \nGROUP BY m.member_id;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your conditions in the `WHERE` clause match the exact criteria specified in the prompt. In this case, since the expense descriptions were combined ('Water, Veggie tray, supplies'), using `IN` with separate items caused a mismatch. Instead, use the exact string as specified in the requirement. Additionally, make sure to check that your aggregation (`SUM`) and grouping match your intended results.",
        "ground_truth_sql": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "difficulty": "challenging"
    },
    {
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "hint": "full name refers to first_name, last_name, amount of funds received refers to amount, received funds on date refers to date_received",
        "error_sql": "SELECT M.first_name || ' ' || M.last_name AS full_name, I.amount \nFROM income AS I \nINNER JOIN member AS M ON I.link_to_member = M.member_id \nWHERE I.date_received = '2019-09-09';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that you understand the relationships between tables and identify any joins you may need to include in your SQL query. In this case, the income is linked to members through their IDs, but that information was only partially incorporated in the initial queries without considering the attendance context. Always consider if additional relationships or joins are needed based on the requirements of the query.",
        "ground_truth_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "difficulty": "challenging"
    },
    {
        "question": "Write the full name of the club member with the position of 'Secretary' and list which college the club member belongs to.",
        "hint": "full name refers to first_name, last name",
        "error_sql": "SELECT m.first_name || ' ' || m.last_name AS full_name, j.college \nFROM member m \nJOIN major j ON m.link_to_major = j.major_id \nWHERE m.position = 'Secretary';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify that your SQL joins and column references accurately reflect the structure of your database schema. Use aliases consistently to avoid confusion, and ensure that you are selecting all required columns correctly in the output. Test your queries incrementally to catch any logical errors early on.",
        "ground_truth_sql": "SELECT T1.first_name, T1.last_name, college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'",
        "difficulty": "simple"
    },
    {
        "question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "hint": "total amount spent = SUM(spent) where category = 'Speaker Gifts'",
        "error_sql": "SELECT e.event_name, SUM(b.spent) AS total_spent\nFROM budget b \nJOIN event e ON b.link_to_event = e.event_id \nWHERE b.category = 'Speaker Gifts'\nGROUP BY e.event_name;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your SQL query includes all necessary conditions and properly alias your tables when performing joins, as it enhances clarity and avoids ambiguity. Double-check that the aggregate functions are correctly applied to the specified columns, and consider using the `INNER JOIN` keyword for clearer intent when joining tables, especially in aggregate queries.",
        "ground_truth_sql": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "difficulty": "simple"
    },
    {
        "question": "In 2012, who had the least consumption in LAM?",
        "hint": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT CustomerID, SUM(Consumption) AS TotalConsumption \nFROM yearmonth \nWHERE Date BETWEEN '201201' AND '201212' \nGROUP BY CustomerID \nORDER BY TotalConsumption ASC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to incorporate relevant filtering conditions from associated tables when aggregating data. In this scenario, the initial queries didn't filter customer segments to 'LAM', which was crucial for identifying the correct data set. Always review the relationships between tables and include necessary conditions to achieve accurate results.",
        "ground_truth_sql": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "hint": "Year 2011 can be presented as Between 201101 And 201112, which means between January and December in 2011",
        "error_sql": "SELECT T1.CustomerID, SUM(T2.Consumption) AS TotalConsumption \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Currency = 'CZK' AND T2.Date BETWEEN '201101' AND '201112' \nGROUP BY T1.CustomerID \nORDER BY TotalConsumption DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure to include a limit in your query if you are looking for a specific record, such as the customer with the highest consumption. This helps to narrow down the results effectively and prevents you from retrieving more data than necessary, which can lead to confusion or misinterpretation. In this case, using `LIMIT 1` would have provided the customer with the most gas consumption directly.",
        "ground_truth_sql": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Date BETWEEN 201101 AND 201112 GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "hint": "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012",
        "error_sql": "SELECT COUNT(DISTINCT CustomerID) \nFROM yearmonth \nWHERE Consumption < 30000 \nAND Date BETWEEN '201201' AND '201212' \nAND CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'KAM');",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to aggregate results properly when dealing with consumption over a period. Use `SUM()` to compute total consumption for each customer before applying conditions like 'less than 30,000'. Additionally, always validate that your `WHERE` clause appropriately reflects the criteria for aggregating the data correctly.",
        "ground_truth_sql": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "difficulty": "moderate"
    },
    {
        "question": "Which year recorded the most gas use paid in EUR?",
        "hint": "",
        "error_sql": "SELECT SUBSTR(Date, 1, 4) AS Year, SUM(Consumption) AS TotalConsumption \nFROM yearmonth ym \nJOIN customers c ON ym.CustomerID = c.CustomerID \nWHERE c.Currency = 'EUR' \nGROUP BY Year \nORDER BY TotalConsumption DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify column names and ensure consistent use of functions for string manipulation across different SQL dialects. Use `SUBSTRING` instead of `SUBSTR` if working with SQL standards or ensure the function used is compatible with your SQL database. Additionally, consider schema constraints and test queries for both accuracy and performance before finalizing them.",
        "ground_truth_sql": "SELECT SUBSTRING(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY SUBSTRING(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which segment had the least consumption?",
        "hint": "",
        "error_sql": "SELECT Segment \nFROM customers \nWHERE CustomerID IN (SELECT CustomerID \n                     FROM yearmonth \n                     GROUP BY CustomerID \n                     ORDER BY SUM(Consumption) ASC \n                     LIMIT 1);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen trying to aggregate data across multiple related tables, ensure that you join the tables correctly before performing group operations. Using subqueries without joining can lead to incomplete or incorrect results, as it may only consider the returned IDs without aggregating the required values across the entire related dataset. Always validate the relationships and the data flow between tables to capture the intended results.",
        "ground_truth_sql": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT SUBSTR(Date, 1, 4) AS Year, SUM(Consumption) AS TotalConsumption \nFROM yearmonth ym \nJOIN customers c ON ym.CustomerID = c.CustomerID \nWHERE c.Currency = 'CZK' \nGROUP BY Year \nORDER BY TotalConsumption DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, ensure that all table aliases are consistently used throughout the query. In your initial query, you mistakenly referenced the `Date` field without a proper alias after joining the tables, which could lead to ambiguities or errors. Always double-check the use of aliases to ensure clarity and correctness, especially in longer queries involving multiple tables.",
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' GROUP BY SUBSTR(T2.Date, 1, 4) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "hint": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT Date, SUM(Consumption) AS total_consumption \nFROM yearmonth \nWHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'SME') \nAND Date BETWEEN '201301' AND '201312' \nGROUP BY Date \nORDER BY total_consumption DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen working with date formats, ensure that your queries correctly handle string manipulation to accurately extract components like year and month. Use functions like `SUBSTR()` or `STRFTIME()` to isolate date parts appropriately, and always confirm that your grouping and filtering criteria align with the intended logic of the query.",
        "ground_truth_sql": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "hint": "annual average consumption of customer with the lowest consumption in each segment = total consumption per year / the number of customer with lowest consumption in each segment; Difference in annual average = SME's annual average - LAM's annual average; Difference in annual average = LAM's annual average - KAM's annual average; Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year.",
        "error_sql": "SELECT \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'SME' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') - \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'LAM' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') AS SME_LAM_difference,\n    \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'LAM' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') - \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'KAM' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') AS LAM_KAM_difference,\n    \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'KAM' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') - \n    (SELECT AVG(Consumption) \n     FROM yearmonth \n     WHERE CustomerID IN \n         (SELECT CustomerID \n          FROM customers \n          WHERE Segment = 'SME' AND Currency = 'CZK') \n     AND Date BETWEEN '201301' AND '201312') AS KAM_SME_difference;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating averages or other aggregate functions, ensure that you first identify the appropriate grouping and filtering criteria. Specifically, make sure to correctly isolate the customers with the least consumption in each segment rather than averaging all customers in that segment. Additionally, consider using subqueries strategically to return specific values, like the minimum consumption, instead of an overall average without proper conditions. This will help prevent miscalculations that can arise from including unintended data in the result set.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "difficulty": "challenging"
    },
    {
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "hint": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
        "error_sql": "SELECT \n    Segment,\n    (SUM(CASE WHEN Date BETWEEN '201301' AND '201312' THEN Consumption END) - \n     SUM(CASE WHEN Date BETWEEN '201201' AND '201212' THEN Consumption END)) / \n    NULLIF(SUM(CASE WHEN Date BETWEEN '201301' AND '201312' THEN Consumption END), 0) * 100 AS percentage_increase\nFROM \n    yearmonth \nJOIN \n    customers ON yearmonth.CustomerID = customers.CustomerID \nWHERE \n    customers.Currency = 'EUR' \nGROUP BY \n    Segment \nORDER BY \n    percentage_increase DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen calculating percentage increases, ensure that the numerator and denominator are clearly defined and correctly structured. Avoid using `NULLIF` if it can lead to division by zero errors; instead, explicitly handle cases where the consumption for the base year (e.g., 2012) is zero to prevent unexpected results or invalid calculations. Additionally, consider using conditional aggregation to collect data for different segments in a more straightforward manner, similar to the IIF function in the Ground Truth SQL. This can simplify your expressions and improve readability.",
        "ground_truth_sql": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "difficulty": "challenging"
    },
    {
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "hint": "October 2013 refers to 201310 in the yearmonth.date",
        "error_sql": "SELECT CustomerID, MAX(Consumption) AS highest_consumption \nFROM yearmonth \nWHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'LAM' AND Currency = 'EUR') \nAND Date = '201310' \nGROUP BY CustomerID \nORDER BY highest_consumption DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when aggregating data, such as using `MAX()` or `SUM()`, you group by the appropriate columns to obtain the correct results. In cases where you need to find the highest value across grouped data, make sure to join the necessary tables first and apply aggregation appropriately after filtering the results. Also, remember to consider the context of your query to ensure that you're calculating the desired values based on the correct parameters.",
        "ground_truth_sql": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date = '201310' AND T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "difficulty": "moderate"
    },
    {
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "hint": "",
        "error_sql": "SELECT Country, COUNT(GasStationID) AS value_for_money_count \nFROM gasstations \nWHERE Segment = 'Value for Money' \nGROUP BY Country \nORDER BY value_for_money_count DESC;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that the `WHERE` clause criteria exactly match the conditions specified in the problem statement, paying attention to spelling and case sensitivity (e.g., \"Value for Money\" vs \"Value for money\"). Additionally, review the aggregation logic to confirm that it aligns with the intended analysis, such as ensuring you're counting the correct entities and grouping properly. Consider testing individual components of your query to validate results step by step.",
        "ground_truth_sql": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the highest monthly consumption in the year 2012?",
        "hint": "The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT MAX(Consumption) \nFROM yearmonth \nWHERE Date BETWEEN '201201' AND '201212';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen filtering data based on specific criteria like year and month in a string format, ensure that you properly isolate and evaluate each component of the string. Instead of using a simple range check, consider parsing the string to extract the year and month explicitly, allowing you to group and aggregate data correctly for accurate results.",
        "ground_truth_sql": "SELECT SUM(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "Please list the product description of the products consumed in September, 2013.",
        "hint": "September 2013 refers to 201309; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
        "error_sql": "SELECT DISTINCT T2.Description \nFROM transactions_1k AS T1 \nINNER JOIN products AS T2 ON T1.ProductID = T2.ProductID \nWHERE T1.Date LIKE '2013-09%';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure you understand the relationships between tables and the specific fields needed for your query. In this case, the transactions table doesn't contain the date formatted as YYYYMM, so joining with the `yearmonth` table was necessary to filter by the correct format. Take the time to break down the query requirements and verify that you are using the correct fields and joining the necessary tables to achieve the desired result.",
        "ground_truth_sql": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "difficulty": "simple"
    },
    {
        "question": "Please list the product description of the products bought in transactions in euro.",
        "hint": "",
        "error_sql": "SELECT DISTINCT P.Description \nFROM products AS P \nJOIN transactions_1k AS T ON P.ProductID = T.ProductID \nJOIN customers AS C ON T.CustomerID = C.CustomerID \nWHERE C.Currency = 'EUR';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that when referencing tables in your SQL query, the aliases used for both tables and columns match consistently throughout the query. Additionally, double-check the join order to confirm that the relationships between the tables are being accurately represented, as errors can occur if the join conditions and selections don't properly reflect the intended logic.",
        "ground_truth_sql": "SELECT DISTINCT T1.ProductID, T3.Description FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Currency = 'EUR'",
        "difficulty": "simple"
    },
    {
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "hint": "Pays in euro = Currency = 'EUR'.",
        "error_sql": "SELECT COUNT(*) \nFROM (\n    SELECT SUM(Consumption) / 12 AS MonthlyConsumption\n    FROM yearmonth \n    WHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Currency = 'EUR') \n    GROUP BY CustomerID\n    HAVING MonthlyConsumption > 1000\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways ensure that your aggregate functions (like SUM) are being applied correctly, and double-check how you are calculating metrics like monthly consumption. Also, if you're filtering data based on specific conditions, make sure to apply those conditions after the aggregation, not before, to avoid confusion in your results. Consider using JOINs effectively to combine related data and filter simultaneously.",
        "ground_truth_sql": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "difficulty": "simple"
    },
    {
        "question": "Which customer paid the most in 2012/8/25?",
        "hint": "'2012/8/25' can be represented by '2012-08-25'",
        "error_sql": "SELECT CustomerID \nFROM transactions_1k \nWHERE Date = '2012-08-25' \nORDER BY Amount * Price DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen aggregating financial data to determine totals, remember to use the `SUM()` function to calculate the total amount spent by each customer. Directly multiplying fields and ordering does not correctly sum the expenditures per customer; instead, you should group by the relevant identifiers and aggregate the results before ordering.",
        "ground_truth_sql": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "For the customer who paid 124.05 in 2012/8/24, how much did he/she spend during the January of 2012? And what is the date and expenses exactly?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'; expense and the consumption has the similar meaning.",
        "error_sql": "SELECT SUM(Price) AS total_spent, Date FROM transactions_1k \nWHERE CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-24' AND Price = 124.05) \nAND Date LIKE '2012-01%' \nGROUP BY Date;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen querying for specific dates or time-related conditions, ensure to use the correct identifiers for both the date format and the combinations with other table columns. Next time, consider joining tables when you need to correlate information from different sources, especially when filtering based on conditions from another table. Additionally, double-check if the fields being grouped or selected match the expected schema, as aggregation or formatting can vary based on the context.",
        "ground_truth_sql": "SELECT T1.CustomerID, T2.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Price = 124.05 AND T2.Date = '201201'",
        "difficulty": "moderate"
    },
    {
        "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'",
        "error_sql": "SELECT G.Country \nFROM transactions_1k AS T \nINNER JOIN gasstations AS G ON T.GasStationID = G.GasStationID \nWHERE T.Date = '2012-08-24' AND T.Amount = 548.4;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you are referencing the correct columns to match the intended criteria in your SQL queries. In this case, the correct column to check for the spent amount was `Price`, not `Amount`. Always double-check column names and their data types in the schema to avoid using incorrect ones.",
        "ground_truth_sql": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
        "difficulty": "simple"
    },
    {
        "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
        "hint": "'2012/8/25' can be represented by '2012-08-25'",
        "error_sql": "SELECT CAST(COUNT(CASE WHEN Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*) AS REAL) AS percentage_eur\nFROM customers\nWHERE CustomerID IN (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Date = '2012-08-25'\n);",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure to properly count the total number of customers participating in the specific transaction date, and use appropriate aggregation functions like `SUM` or `COUNT` tailored for your logic instead of relying solely on `COUNT(*)`. Also, utilize `IIF` for conditional counting if the database supports it, or use `CASE WHEN` for broader SQL compatibility. Double-check that your joins and conditions reflect the data relationships clearly to avoid miscounting.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
        "difficulty": "simple"
    },
    {
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "hint": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
        "error_sql": "SELECT \n    (COALESCE((SELECT Consumption FROM yearmonth WHERE CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' AND Amount = 634.8) AND Date = '2012') , 0) - \n    COALESCE((SELECT Consumption FROM yearmonth WHERE CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' AND Amount = 634.8) AND Date = '2013') , 0)) / \n    COALESCE((SELECT Consumption FROM yearmonth WHERE CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' AND Amount = 634.8) AND Date = '2012') , 1) AS consumption_decrease_rate;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen constructing SQL queries, particularly those involving aggregate functions and conditional logic, it's essential to ensure that the conditions align with the broader logical structure of the query. In the erroneous queries, the use of subqueries and COALESCE could lead to subtle misalignments, especially if the date format isn't correctly handled or if the aggregation logic miscalculates zero values. To avoid such mistakes, clearly define the expected outputs and test simpler versions of your queries to confirm their correctness before complexity is added. Additionally, utilizing aggregate functions like `SUM` with conditional logic directly within the main query can simplify the overall structure and reduce the likelihood of errors.",
        "ground_truth_sql": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "difficulty": "challenging"
    },
    {
        "question": "Which gas station has the highest amount of revenue?",
        "hint": "",
        "error_sql": "SELECT G.GasStationID, SUM(T.Price) AS TotalRevenue \nFROM transactions_1k AS T \nJOIN gasstations AS G ON T.GasStationID = G.GasStationID \nGROUP BY G.GasStationID \nORDER BY TotalRevenue DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure that you specify the correct aggregation function directly in your SQL query. While the first query you wrote appears correct, if it didn't yield the expected results, check for potential issues such as data type mismatches or missing records in relevant tables. Always validate your assumptions by testing intermediate results, like checking individual sums per gas station, to confirm data integrity before final aggregation.",
        "ground_truth_sql": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
        "difficulty": "simple"
    },
    {
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "hint": "January 2012 refers to the Date value = '201201'",
        "error_sql": "SELECT SUM(Amount) \nFROM transactions_1k \nWHERE CustomerID = 38508 \nAND Date = '201201';",
        "compiler_hint": "You can only execute one statement at a time.",
        "reflective_cot": "### Tip:\nEnsure that you fully understand the schema and relationships between tables before forming your SQL queries. Specifically, pay attention to how joins between tables can impact your ability to access relevant data. Also, remember to verify the date format and adjust your WHERE conditions accordingly to directly align with the data you intend to filter, especially when dealing with time periods.",
        "ground_truth_sql": "SELECT SUM(T1.Price) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "difficulty": "moderate"
    },
    {
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "hint": "Description of products contains full name",
        "error_sql": "SELECT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID GROUP BY T1.ProductID ORDER BY SUM(T2.Amount) DESC LIMIT 5;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nAlways verify the aggregation logic in your SQL queries. In your initial query, you used `SUM(T2.Amount)` but referenced the `Description` field from the products table later on, leading to confusion in the expected result. Ensure that you're joining and aggregating based on the correct identifiers, and double-check to ensure you are pulling the correct data after aggregation.",
        "ground_truth_sql": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "difficulty": "simple"
    },
    {
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "hint": "average price per single item = Total(price) / Total(amount)",
        "error_sql": "SELECT C.CustomerID, AVG(T.Price / T.Amount) AS AveragePrice, C.Currency \nFROM transactions_1k AS T \nJOIN customers AS C ON T.CustomerID = C.CustomerID \nGROUP BY C.CustomerID \nORDER BY SUM(T.Price) DESC \nLIMIT 1;",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nEnsure you have a clear understanding of the requirements before writing the SQL query. In this case, the focus should have been on identifying the customer with the highest total spending rather than just grouping by `CustomerID`. Additionally, make sure to derive any necessary results (like finding the top customer) in subqueries if needed, to avoid incorrect aggregations or assumptions in the main query. Always double-check the use of aggregates and ensures that you're not aggregating values incorrectly, as it can lead to flawed results.",
        "ground_truth_sql": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "difficulty": "moderate"
    },
    {
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "hint": "August of 2012 refers to the Date value = '201208' ; Price per unit of product = Price / Amount;",
        "error_sql": "SELECT Y.CustomerID, Y.Consumption \nFROM yearmonth AS Y \nINNER JOIN transactions_1k AS T ON Y.CustomerID = T.CustomerID \nWHERE T.ProductID = 5 AND (T.Price / T.Amount) > 29.00 AND Y.Date = '201208';",
        "compiler_hint": null,
        "reflective_cot": "### Tip:\nWhen working with dates in SQL, ensure that the date format matches the expected storage format in the database or use appropriate functions (like `strftime`) to extract the required components correctly. Additionally, always validate join conditions and filtering criteria to ensure they accurately reflect the intended logic for the query.",
        "ground_truth_sql": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "difficulty": "moderate"
    }
]